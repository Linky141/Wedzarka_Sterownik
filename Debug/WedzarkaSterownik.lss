
WedzarkaSterownik.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000068d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000224  00800060  000068d0  00006964  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000030  00800284  00800284  00006b88  2**0
                  ALLOC
  3 .stab         0000864c  00000000  00000000  00006b88  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004064  00000000  00000000  0000f1d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000030  00000000  00000000  00013238  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 01 	jmp	0x312	; 0x312 <__ctors_end>
       4:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
       8:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
       c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      10:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      14:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      18:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      1c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      20:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      24:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      28:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      2c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      30:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      34:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      38:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      3c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      40:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      44:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      48:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      4c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      50:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      54:	c1 20       	and	r12, r1
      56:	cb 22       	and	r12, r27
      58:	cb 22       	and	r12, r27
      5a:	cb 22       	and	r12, r27
      5c:	cb 22       	and	r12, r27
      5e:	cb 22       	and	r12, r27
      60:	cb 22       	and	r12, r27
      62:	a4 21       	and	r26, r4
      64:	cb 22       	and	r12, r27
      66:	82 22       	and	r8, r18
      68:	cb 22       	and	r12, r27
      6a:	cb 22       	and	r12, r27
      6c:	cb 22       	and	r12, r27
      6e:	cb 22       	and	r12, r27
      70:	cb 22       	and	r12, r27
      72:	cb 22       	and	r12, r27
      74:	cb 22       	and	r12, r27
      76:	cb 22       	and	r12, r27
      78:	cb 22       	and	r12, r27
      7a:	cb 22       	and	r12, r27
      7c:	cb 22       	and	r12, r27
      7e:	ca 21       	and	r28, r10
      80:	f0 21       	and	r31, r0
      82:	0c 21       	and	r16, r12
      84:	cb 22       	and	r12, r27
      86:	e6 20       	and	r14, r6
      88:	16 22       	and	r1, r22
      8a:	cb 22       	and	r12, r27
      8c:	cb 22       	and	r12, r27
      8e:	cb 22       	and	r12, r27
      90:	cb 22       	and	r12, r27
      92:	cb 22       	and	r12, r27
      94:	cb 22       	and	r12, r27
      96:	cb 22       	and	r12, r27
      98:	cb 22       	and	r12, r27
      9a:	cb 22       	and	r12, r27
      9c:	cb 22       	and	r12, r27
      9e:	cb 22       	and	r12, r27
      a0:	cb 22       	and	r12, r27
      a2:	cb 22       	and	r12, r27
      a4:	cb 22       	and	r12, r27
      a6:	cb 22       	and	r12, r27
      a8:	cb 22       	and	r12, r27
      aa:	cb 22       	and	r12, r27
      ac:	cb 22       	and	r12, r27
      ae:	cb 22       	and	r12, r27
      b0:	cb 22       	and	r12, r27
      b2:	cb 22       	and	r12, r27
      b4:	cb 22       	and	r12, r27
      b6:	cb 22       	and	r12, r27
      b8:	cb 22       	and	r12, r27
      ba:	cb 22       	and	r12, r27
      bc:	cb 22       	and	r12, r27
      be:	cb 22       	and	r12, r27
      c0:	3a 22       	and	r3, r26
      c2:	cb 22       	and	r12, r27
      c4:	5e 22       	and	r5, r30
      c6:	cb 22       	and	r12, r27
      c8:	cb 22       	and	r12, r27
      ca:	cb 22       	and	r12, r27
      cc:	cb 22       	and	r12, r27
      ce:	cb 22       	and	r12, r27
      d0:	cb 22       	and	r12, r27
      d2:	cb 22       	and	r12, r27
      d4:	cb 22       	and	r12, r27
      d6:	cb 22       	and	r12, r27
      d8:	cb 22       	and	r12, r27
      da:	cb 22       	and	r12, r27
      dc:	cb 22       	and	r12, r27
      de:	cb 22       	and	r12, r27
      e0:	cb 22       	and	r12, r27
      e2:	cb 22       	and	r12, r27
      e4:	cb 22       	and	r12, r27
      e6:	cb 22       	and	r12, r27
      e8:	cb 22       	and	r12, r27
      ea:	cb 22       	and	r12, r27
      ec:	cb 22       	and	r12, r27
      ee:	cb 22       	and	r12, r27
      f0:	cb 22       	and	r12, r27
      f2:	cb 22       	and	r12, r27
      f4:	cb 22       	and	r12, r27
      f6:	cb 22       	and	r12, r27
      f8:	cb 22       	and	r12, r27
      fa:	cb 22       	and	r12, r27
      fc:	cb 22       	and	r12, r27
      fe:	cb 22       	and	r12, r27
     100:	58 21       	and	r21, r8
     102:	32 21       	and	r19, r2
     104:	7e 21       	and	r23, r14
     106:	e8 28       	or	r14, r8
     108:	1d 29       	or	r17, r13
     10a:	1d 29       	or	r17, r13
     10c:	1d 29       	or	r17, r13
     10e:	1d 29       	or	r17, r13
     110:	1d 29       	or	r17, r13
     112:	1d 29       	or	r17, r13
     114:	96 26       	eor	r9, r22
     116:	1d 29       	or	r17, r13
     118:	32 27       	eor	r19, r18
     11a:	1d 29       	or	r17, r13
     11c:	1d 29       	or	r17, r13
     11e:	1d 29       	or	r17, r13
     120:	1d 29       	or	r17, r13
     122:	1d 29       	or	r17, r13
     124:	1d 29       	or	r17, r13
     126:	1d 29       	or	r17, r13
     128:	1d 29       	or	r17, r13
     12a:	1d 29       	or	r17, r13
     12c:	1d 29       	or	r17, r13
     12e:	1d 29       	or	r17, r13
     130:	b1 26       	eor	r11, r17
     132:	cc 26       	eor	r12, r28
     134:	2a 26       	eor	r2, r26
     136:	1d 29       	or	r17, r13
     138:	0f 26       	eor	r0, r31
     13a:	e7 26       	eor	r14, r23
     13c:	1d 29       	or	r17, r13
     13e:	1d 29       	or	r17, r13
     140:	aa 28       	or	r10, r10
     142:	4b 27       	eor	r20, r27
     144:	b4 27       	eor	r27, r20
     146:	1d 29       	or	r17, r13
     148:	02 29       	or	r16, r2
     14a:	1d 29       	or	r17, r13
     14c:	1d 29       	or	r17, r13
     14e:	1d 29       	or	r17, r13
     150:	1d 29       	or	r17, r13
     152:	1d 29       	or	r17, r13
     154:	1d 29       	or	r17, r13
     156:	1d 29       	or	r17, r13
     158:	1d 29       	or	r17, r13
     15a:	1d 29       	or	r17, r13
     15c:	1d 29       	or	r17, r13
     15e:	1d 29       	or	r17, r13
     160:	1d 29       	or	r17, r13
     162:	d1 28       	or	r13, r1
     164:	1d 29       	or	r17, r13
     166:	23 28       	or	r2, r3
     168:	1d 29       	or	r17, r13
     16a:	1d 29       	or	r17, r13
     16c:	64 28       	or	r6, r4
     16e:	1d 29       	or	r17, r13
     170:	1d 29       	or	r17, r13
     172:	00 27       	eor	r16, r16
     174:	1d 29       	or	r17, r13
     176:	19 27       	eor	r17, r25
     178:	1d 29       	or	r17, r13
     17a:	1d 29       	or	r17, r13
     17c:	1d 29       	or	r17, r13
     17e:	1d 29       	or	r17, r13
     180:	86 28       	or	r8, r6
     182:	4b 27       	eor	r20, r27
     184:	70 27       	eor	r23, r16
     186:	1d 29       	or	r17, r13
     188:	02 29       	or	r16, r2
     18a:	1d 29       	or	r17, r13
     18c:	1d 29       	or	r17, r13
     18e:	1d 29       	or	r17, r13
     190:	1d 29       	or	r17, r13
     192:	1d 29       	or	r17, r13
     194:	1d 29       	or	r17, r13
     196:	1d 29       	or	r17, r13
     198:	1d 29       	or	r17, r13
     19a:	1d 29       	or	r17, r13
     19c:	1d 29       	or	r17, r13
     19e:	1d 29       	or	r17, r13
     1a0:	1d 29       	or	r17, r13
     1a2:	d1 28       	or	r13, r1
     1a4:	1d 29       	or	r17, r13
     1a6:	04 28       	or	r0, r4
     1a8:	1d 29       	or	r17, r13
     1aa:	1d 29       	or	r17, r13
     1ac:	45 28       	or	r4, r5
     1ae:	1d 29       	or	r17, r13
     1b0:	1d 29       	or	r17, r13
     1b2:	60 26       	eor	r6, r16
     1b4:	45 26       	eor	r4, r21
     1b6:	7b 26       	eor	r7, r27
     1b8:	e8 2a       	or	r14, r24
     1ba:	f1 2a       	or	r15, r17
     1bc:	f1 2a       	or	r15, r17
     1be:	f1 2a       	or	r15, r17
     1c0:	f1 2a       	or	r15, r17
     1c2:	f1 2a       	or	r15, r17
     1c4:	f1 2a       	or	r15, r17
     1c6:	b0 29       	or	r27, r0
     1c8:	f1 2a       	or	r15, r17
     1ca:	c8 29       	or	r28, r8
     1cc:	f1 2a       	or	r15, r17
     1ce:	f1 2a       	or	r15, r17
     1d0:	f1 2a       	or	r15, r17
     1d2:	f1 2a       	or	r15, r17
     1d4:	f1 2a       	or	r15, r17
     1d6:	f1 2a       	or	r15, r17
     1d8:	f1 2a       	or	r15, r17
     1da:	f1 2a       	or	r15, r17
     1dc:	f1 2a       	or	r15, r17
     1de:	f1 2a       	or	r15, r17
     1e0:	f1 2a       	or	r15, r17
     1e2:	b5 29       	or	r27, r5
     1e4:	ba 29       	or	r27, r10
     1e6:	9c 29       	or	r25, r12
     1e8:	f1 2a       	or	r15, r17
     1ea:	97 29       	or	r25, r7
     1ec:	bf 29       	or	r27, r15
     1ee:	f1 2a       	or	r15, r17
     1f0:	f1 2a       	or	r15, r17
     1f2:	b7 2a       	or	r11, r23
     1f4:	cb 29       	or	r28, r11
     1f6:	01 2a       	or	r0, r17
     1f8:	f1 2a       	or	r15, r17
     1fa:	ec 2a       	or	r14, r28
     1fc:	f1 2a       	or	r15, r17
     1fe:	f1 2a       	or	r15, r17
     200:	f1 2a       	or	r15, r17
     202:	f1 2a       	or	r15, r17
     204:	f1 2a       	or	r15, r17
     206:	f1 2a       	or	r15, r17
     208:	f1 2a       	or	r15, r17
     20a:	f1 2a       	or	r15, r17
     20c:	f1 2a       	or	r15, r17
     20e:	f1 2a       	or	r15, r17
     210:	f1 2a       	or	r15, r17
     212:	f1 2a       	or	r15, r17
     214:	d7 2a       	or	r13, r23
     216:	f1 2a       	or	r15, r17
     218:	4c 2a       	or	r4, r28
     21a:	f1 2a       	or	r15, r17
     21c:	f1 2a       	or	r15, r17
     21e:	7f 2a       	or	r7, r31
     220:	f1 2a       	or	r15, r17
     222:	f1 2a       	or	r15, r17
     224:	c2 29       	or	r28, r2
     226:	f1 2a       	or	r15, r17
     228:	c5 29       	or	r28, r5
     22a:	f1 2a       	or	r15, r17
     22c:	f1 2a       	or	r15, r17
     22e:	f1 2a       	or	r15, r17
     230:	f1 2a       	or	r15, r17
     232:	9a 2a       	or	r9, r26
     234:	cb 29       	or	r28, r11
     236:	da 29       	or	r29, r10
     238:	f1 2a       	or	r15, r17
     23a:	ec 2a       	or	r14, r28
     23c:	f1 2a       	or	r15, r17
     23e:	f1 2a       	or	r15, r17
     240:	f1 2a       	or	r15, r17
     242:	f1 2a       	or	r15, r17
     244:	f1 2a       	or	r15, r17
     246:	f1 2a       	or	r15, r17
     248:	f1 2a       	or	r15, r17
     24a:	f1 2a       	or	r15, r17
     24c:	f1 2a       	or	r15, r17
     24e:	f1 2a       	or	r15, r17
     250:	f1 2a       	or	r15, r17
     252:	f1 2a       	or	r15, r17
     254:	d7 2a       	or	r13, r23
     256:	f1 2a       	or	r15, r17
     258:	34 2a       	or	r3, r20
     25a:	f1 2a       	or	r15, r17
     25c:	f1 2a       	or	r15, r17
     25e:	67 2a       	or	r6, r23
     260:	f1 2a       	or	r15, r17
     262:	f1 2a       	or	r15, r17
     264:	a6 29       	or	r26, r6
     266:	a1 29       	or	r26, r1
     268:	ab 29       	or	r26, r11
     26a:	e3 31       	cpi	r30, 0x13	; 19
     26c:	eb 31       	cpi	r30, 0x1B	; 27
     26e:	eb 31       	cpi	r30, 0x1B	; 27
     270:	eb 31       	cpi	r30, 0x1B	; 27
     272:	eb 31       	cpi	r30, 0x1B	; 27
     274:	eb 31       	cpi	r30, 0x1B	; 27
     276:	eb 31       	cpi	r30, 0x1B	; 27
     278:	eb 31       	cpi	r30, 0x1B	; 27
     27a:	eb 31       	cpi	r30, 0x1B	; 27
     27c:	eb 31       	cpi	r30, 0x1B	; 27
     27e:	eb 31       	cpi	r30, 0x1B	; 27
     280:	eb 31       	cpi	r30, 0x1B	; 27
     282:	eb 31       	cpi	r30, 0x1B	; 27
     284:	eb 31       	cpi	r30, 0x1B	; 27
     286:	eb 31       	cpi	r30, 0x1B	; 27
     288:	eb 31       	cpi	r30, 0x1B	; 27
     28a:	eb 31       	cpi	r30, 0x1B	; 27
     28c:	eb 31       	cpi	r30, 0x1B	; 27
     28e:	eb 31       	cpi	r30, 0x1B	; 27
     290:	eb 31       	cpi	r30, 0x1B	; 27
     292:	eb 31       	cpi	r30, 0x1B	; 27
     294:	eb 31       	cpi	r30, 0x1B	; 27
     296:	eb 31       	cpi	r30, 0x1B	; 27
     298:	eb 31       	cpi	r30, 0x1B	; 27
     29a:	eb 31       	cpi	r30, 0x1B	; 27
     29c:	eb 31       	cpi	r30, 0x1B	; 27
     29e:	eb 31       	cpi	r30, 0x1B	; 27
     2a0:	eb 31       	cpi	r30, 0x1B	; 27
     2a2:	eb 31       	cpi	r30, 0x1B	; 27
     2a4:	99 31       	cpi	r25, 0x19	; 25
     2a6:	ad 30       	cpi	r26, 0x0D	; 13
     2a8:	e3 30       	cpi	r30, 0x03	; 3
     2aa:	eb 31       	cpi	r30, 0x1B	; 27
     2ac:	b9 31       	cpi	r27, 0x19	; 25
     2ae:	eb 31       	cpi	r30, 0x1B	; 27
     2b0:	eb 31       	cpi	r30, 0x1B	; 27
     2b2:	eb 31       	cpi	r30, 0x1B	; 27
     2b4:	eb 31       	cpi	r30, 0x1B	; 27
     2b6:	eb 31       	cpi	r30, 0x1B	; 27
     2b8:	eb 31       	cpi	r30, 0x1B	; 27
     2ba:	eb 31       	cpi	r30, 0x1B	; 27
     2bc:	eb 31       	cpi	r30, 0x1B	; 27
     2be:	eb 31       	cpi	r30, 0x1B	; 27
     2c0:	eb 31       	cpi	r30, 0x1B	; 27
     2c2:	eb 31       	cpi	r30, 0x1B	; 27
     2c4:	eb 31       	cpi	r30, 0x1B	; 27
     2c6:	d2 31       	cpi	r29, 0x12	; 18
     2c8:	eb 31       	cpi	r30, 0x1B	; 27
     2ca:	2e 31       	cpi	r18, 0x1E	; 30
     2cc:	eb 31       	cpi	r30, 0x1B	; 27
     2ce:	eb 31       	cpi	r30, 0x1B	; 27
     2d0:	61 31       	cpi	r22, 0x11	; 17
     2d2:	eb 31       	cpi	r30, 0x1B	; 27
     2d4:	eb 31       	cpi	r30, 0x1B	; 27
     2d6:	eb 31       	cpi	r30, 0x1B	; 27
     2d8:	eb 31       	cpi	r30, 0x1B	; 27
     2da:	eb 31       	cpi	r30, 0x1B	; 27
     2dc:	eb 31       	cpi	r30, 0x1B	; 27
     2de:	eb 31       	cpi	r30, 0x1B	; 27
     2e0:	eb 31       	cpi	r30, 0x1B	; 27
     2e2:	eb 31       	cpi	r30, 0x1B	; 27
     2e4:	7c 31       	cpi	r23, 0x1C	; 28
     2e6:	ad 30       	cpi	r26, 0x0D	; 13
     2e8:	bc 30       	cpi	r27, 0x0C	; 12
     2ea:	eb 31       	cpi	r30, 0x1B	; 27
     2ec:	b9 31       	cpi	r27, 0x19	; 25
     2ee:	eb 31       	cpi	r30, 0x1B	; 27
     2f0:	eb 31       	cpi	r30, 0x1B	; 27
     2f2:	eb 31       	cpi	r30, 0x1B	; 27
     2f4:	eb 31       	cpi	r30, 0x1B	; 27
     2f6:	eb 31       	cpi	r30, 0x1B	; 27
     2f8:	eb 31       	cpi	r30, 0x1B	; 27
     2fa:	eb 31       	cpi	r30, 0x1B	; 27
     2fc:	eb 31       	cpi	r30, 0x1B	; 27
     2fe:	eb 31       	cpi	r30, 0x1B	; 27
     300:	eb 31       	cpi	r30, 0x1B	; 27
     302:	eb 31       	cpi	r30, 0x1B	; 27
     304:	eb 31       	cpi	r30, 0x1B	; 27
     306:	d2 31       	cpi	r29, 0x12	; 18
     308:	eb 31       	cpi	r30, 0x1B	; 27
     30a:	16 31       	cpi	r17, 0x16	; 22
     30c:	eb 31       	cpi	r30, 0x1B	; 27
     30e:	eb 31       	cpi	r30, 0x1B	; 27
     310:	49 31       	cpi	r20, 0x19	; 25

00000312 <__ctors_end>:
     312:	11 24       	eor	r1, r1
     314:	1f be       	out	0x3f, r1	; 63
     316:	cf e5       	ldi	r28, 0x5F	; 95
     318:	d4 e0       	ldi	r29, 0x04	; 4
     31a:	de bf       	out	0x3e, r29	; 62
     31c:	cd bf       	out	0x3d, r28	; 61

0000031e <__do_copy_data>:
     31e:	12 e0       	ldi	r17, 0x02	; 2
     320:	a0 e6       	ldi	r26, 0x60	; 96
     322:	b0 e0       	ldi	r27, 0x00	; 0
     324:	e0 ed       	ldi	r30, 0xD0	; 208
     326:	f8 e6       	ldi	r31, 0x68	; 104
     328:	02 c0       	rjmp	.+4      	; 0x32e <__do_copy_data+0x10>
     32a:	05 90       	lpm	r0, Z+
     32c:	0d 92       	st	X+, r0
     32e:	a4 38       	cpi	r26, 0x84	; 132
     330:	b1 07       	cpc	r27, r17
     332:	d9 f7       	brne	.-10     	; 0x32a <__do_copy_data+0xc>

00000334 <__do_clear_bss>:
     334:	22 e0       	ldi	r18, 0x02	; 2
     336:	a4 e8       	ldi	r26, 0x84	; 132
     338:	b2 e0       	ldi	r27, 0x02	; 2
     33a:	01 c0       	rjmp	.+2      	; 0x33e <.do_clear_bss_start>

0000033c <.do_clear_bss_loop>:
     33c:	1d 92       	st	X+, r1

0000033e <.do_clear_bss_start>:
     33e:	a4 3b       	cpi	r26, 0xB4	; 180
     340:	b2 07       	cpc	r27, r18
     342:	e1 f7       	brne	.-8      	; 0x33c <.do_clear_bss_loop>
     344:	0e 94 1c 15 	call	0x2a38	; 0x2a38 <main>
     348:	0c 94 66 34 	jmp	0x68cc	; 0x68cc <_exit>

0000034c <__bad_interrupt>:
     34c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000350 <DEVCOMMAND_ExecuteCommand>:
/* CONNECT HEADER */
#include "../HEADERS/DEV_COMMAND.h"

/* BODY OF FUNCTIONS */
void DEVCOMMAND_ExecuteCommand(int location, int page, bool ledStatus, int time) {
     350:	cf 93       	push	r28
     352:	df 93       	push	r29
     354:	cd b7       	in	r28, 0x3d	; 61
     356:	de b7       	in	r29, 0x3e	; 62
     358:	27 97       	sbiw	r28, 0x07	; 7
     35a:	0f b6       	in	r0, 0x3f	; 63
     35c:	f8 94       	cli
     35e:	de bf       	out	0x3e, r29	; 62
     360:	0f be       	out	0x3f, r0	; 63
     362:	cd bf       	out	0x3d, r28	; 61
     364:	9a 83       	std	Y+2, r25	; 0x02
     366:	89 83       	std	Y+1, r24	; 0x01
     368:	7c 83       	std	Y+4, r23	; 0x04
     36a:	6b 83       	std	Y+3, r22	; 0x03
     36c:	4d 83       	std	Y+5, r20	; 0x05
     36e:	3f 83       	std	Y+7, r19	; 0x07
     370:	2e 83       	std	Y+6, r18	; 0x06

	if (location == 1) {
     372:	89 81       	ldd	r24, Y+1	; 0x01
     374:	9a 81       	ldd	r25, Y+2	; 0x02
     376:	81 30       	cpi	r24, 0x01	; 1
     378:	91 05       	cpc	r25, r1
     37a:	c9 f5       	brne	.+114    	; 0x3ee <DEVCOMMAND_ExecuteCommand+0x9e>
		if (page == 1)
     37c:	8b 81       	ldd	r24, Y+3	; 0x03
     37e:	9c 81       	ldd	r25, Y+4	; 0x04
     380:	81 30       	cpi	r24, 0x01	; 1
     382:	91 05       	cpc	r25, r1
     384:	41 f4       	brne	.+16     	; 0x396 <DEVCOMMAND_ExecuteCommand+0x46>
			UARTCOMMUNICATION_send(COMMADN1PAGE1, time);
     386:	8e 81       	ldd	r24, Y+6	; 0x06
     388:	9f 81       	ldd	r25, Y+7	; 0x07
     38a:	bc 01       	movw	r22, r24
     38c:	84 e6       	ldi	r24, 0x64	; 100
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     394:	26 c0       	rjmp	.+76     	; 0x3e2 <DEVCOMMAND_ExecuteCommand+0x92>
		else if (page == 2)
     396:	8b 81       	ldd	r24, Y+3	; 0x03
     398:	9c 81       	ldd	r25, Y+4	; 0x04
     39a:	82 30       	cpi	r24, 0x02	; 2
     39c:	91 05       	cpc	r25, r1
     39e:	41 f4       	brne	.+16     	; 0x3b0 <DEVCOMMAND_ExecuteCommand+0x60>
			UARTCOMMUNICATION_send(COMMADN1PAGE2, time);
     3a0:	8e 81       	ldd	r24, Y+6	; 0x06
     3a2:	9f 81       	ldd	r25, Y+7	; 0x07
     3a4:	bc 01       	movw	r22, r24
     3a6:	8a e6       	ldi	r24, 0x6A	; 106
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     3ae:	19 c0       	rjmp	.+50     	; 0x3e2 <DEVCOMMAND_ExecuteCommand+0x92>
		else if (page == 3)
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	83 30       	cpi	r24, 0x03	; 3
     3b6:	91 05       	cpc	r25, r1
     3b8:	41 f4       	brne	.+16     	; 0x3ca <DEVCOMMAND_ExecuteCommand+0x7a>
			UARTCOMMUNICATION_send(COMMADN1PAGE3, time);
     3ba:	8e 81       	ldd	r24, Y+6	; 0x06
     3bc:	9f 81       	ldd	r25, Y+7	; 0x07
     3be:	bc 01       	movw	r22, r24
     3c0:	80 e7       	ldi	r24, 0x70	; 112
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     3c8:	0c c0       	rjmp	.+24     	; 0x3e2 <DEVCOMMAND_ExecuteCommand+0x92>
		else if (page == 4)
     3ca:	8b 81       	ldd	r24, Y+3	; 0x03
     3cc:	9c 81       	ldd	r25, Y+4	; 0x04
     3ce:	84 30       	cpi	r24, 0x04	; 4
     3d0:	91 05       	cpc	r25, r1
     3d2:	39 f4       	brne	.+14     	; 0x3e2 <DEVCOMMAND_ExecuteCommand+0x92>
			UARTCOMMUNICATION_send(COMMADN1PAGE4, time);
     3d4:	8e 81       	ldd	r24, Y+6	; 0x06
     3d6:	9f 81       	ldd	r25, Y+7	; 0x07
     3d8:	bc 01       	movw	r22, r24
     3da:	86 e7       	ldi	r24, 0x76	; 118
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
		DEVCOMMAND_LedInfoBlink(100, ledStatus);
     3e2:	6d 81       	ldd	r22, Y+5	; 0x05
     3e4:	84 e6       	ldi	r24, 0x64	; 100
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	0e 94 ba 02 	call	0x574	; 0x574 <DEVCOMMAND_LedInfoBlink>
     3ec:	b9 c0       	rjmp	.+370    	; 0x560 <__stack+0x101>
	} else if (location == 2) {
     3ee:	89 81       	ldd	r24, Y+1	; 0x01
     3f0:	9a 81       	ldd	r25, Y+2	; 0x02
     3f2:	82 30       	cpi	r24, 0x02	; 2
     3f4:	91 05       	cpc	r25, r1
     3f6:	c9 f5       	brne	.+114    	; 0x46a <__stack+0xb>
		if (page == 1)
     3f8:	8b 81       	ldd	r24, Y+3	; 0x03
     3fa:	9c 81       	ldd	r25, Y+4	; 0x04
     3fc:	81 30       	cpi	r24, 0x01	; 1
     3fe:	91 05       	cpc	r25, r1
     400:	41 f4       	brne	.+16     	; 0x412 <DEVCOMMAND_ExecuteCommand+0xc2>
			UARTCOMMUNICATION_send(COMMADN2PAGE1, time);
     402:	8e 81       	ldd	r24, Y+6	; 0x06
     404:	9f 81       	ldd	r25, Y+7	; 0x07
     406:	bc 01       	movw	r22, r24
     408:	8c e7       	ldi	r24, 0x7C	; 124
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     410:	26 c0       	rjmp	.+76     	; 0x45e <DEVCOMMAND_ExecuteCommand+0x10e>
		else if (page == 2)
     412:	8b 81       	ldd	r24, Y+3	; 0x03
     414:	9c 81       	ldd	r25, Y+4	; 0x04
     416:	82 30       	cpi	r24, 0x02	; 2
     418:	91 05       	cpc	r25, r1
     41a:	41 f4       	brne	.+16     	; 0x42c <DEVCOMMAND_ExecuteCommand+0xdc>
			UARTCOMMUNICATION_send(COMMADN2PAGE2, time);
     41c:	8e 81       	ldd	r24, Y+6	; 0x06
     41e:	9f 81       	ldd	r25, Y+7	; 0x07
     420:	bc 01       	movw	r22, r24
     422:	82 e8       	ldi	r24, 0x82	; 130
     424:	90 e0       	ldi	r25, 0x00	; 0
     426:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     42a:	19 c0       	rjmp	.+50     	; 0x45e <DEVCOMMAND_ExecuteCommand+0x10e>
		else if (page == 3)
     42c:	8b 81       	ldd	r24, Y+3	; 0x03
     42e:	9c 81       	ldd	r25, Y+4	; 0x04
     430:	83 30       	cpi	r24, 0x03	; 3
     432:	91 05       	cpc	r25, r1
     434:	41 f4       	brne	.+16     	; 0x446 <DEVCOMMAND_ExecuteCommand+0xf6>
			UARTCOMMUNICATION_send(COMMADN2PAGE3, time);
     436:	8e 81       	ldd	r24, Y+6	; 0x06
     438:	9f 81       	ldd	r25, Y+7	; 0x07
     43a:	bc 01       	movw	r22, r24
     43c:	88 e8       	ldi	r24, 0x88	; 136
     43e:	90 e0       	ldi	r25, 0x00	; 0
     440:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     444:	0c c0       	rjmp	.+24     	; 0x45e <DEVCOMMAND_ExecuteCommand+0x10e>
		else if (page == 4)
     446:	8b 81       	ldd	r24, Y+3	; 0x03
     448:	9c 81       	ldd	r25, Y+4	; 0x04
     44a:	84 30       	cpi	r24, 0x04	; 4
     44c:	91 05       	cpc	r25, r1
     44e:	39 f4       	brne	.+14     	; 0x45e <DEVCOMMAND_ExecuteCommand+0x10e>
			UARTCOMMUNICATION_send(COMMADN2PAGE4, time);
     450:	8e 81       	ldd	r24, Y+6	; 0x06
     452:	9f 81       	ldd	r25, Y+7	; 0x07
     454:	bc 01       	movw	r22, r24
     456:	8e e8       	ldi	r24, 0x8E	; 142
     458:	90 e0       	ldi	r25, 0x00	; 0
     45a:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
		DEVCOMMAND_LedInfoBlink(100, ledStatus);
     45e:	6d 81       	ldd	r22, Y+5	; 0x05
     460:	84 e6       	ldi	r24, 0x64	; 100
     462:	90 e0       	ldi	r25, 0x00	; 0
     464:	0e 94 ba 02 	call	0x574	; 0x574 <DEVCOMMAND_LedInfoBlink>
     468:	7b c0       	rjmp	.+246    	; 0x560 <__stack+0x101>
	} else if (location == 3) {
     46a:	89 81       	ldd	r24, Y+1	; 0x01
     46c:	9a 81       	ldd	r25, Y+2	; 0x02
     46e:	83 30       	cpi	r24, 0x03	; 3
     470:	91 05       	cpc	r25, r1
     472:	c9 f5       	brne	.+114    	; 0x4e6 <__stack+0x87>
		if (page == 1)
     474:	8b 81       	ldd	r24, Y+3	; 0x03
     476:	9c 81       	ldd	r25, Y+4	; 0x04
     478:	81 30       	cpi	r24, 0x01	; 1
     47a:	91 05       	cpc	r25, r1
     47c:	41 f4       	brne	.+16     	; 0x48e <__stack+0x2f>
			UARTCOMMUNICATION_send(COMMADN3PAGE1, time);
     47e:	8e 81       	ldd	r24, Y+6	; 0x06
     480:	9f 81       	ldd	r25, Y+7	; 0x07
     482:	bc 01       	movw	r22, r24
     484:	84 e9       	ldi	r24, 0x94	; 148
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     48c:	26 c0       	rjmp	.+76     	; 0x4da <__stack+0x7b>
		else if (page == 2)
     48e:	8b 81       	ldd	r24, Y+3	; 0x03
     490:	9c 81       	ldd	r25, Y+4	; 0x04
     492:	82 30       	cpi	r24, 0x02	; 2
     494:	91 05       	cpc	r25, r1
     496:	41 f4       	brne	.+16     	; 0x4a8 <__stack+0x49>
			UARTCOMMUNICATION_send(COMMADN3PAGE2, time);
     498:	8e 81       	ldd	r24, Y+6	; 0x06
     49a:	9f 81       	ldd	r25, Y+7	; 0x07
     49c:	bc 01       	movw	r22, r24
     49e:	8a e9       	ldi	r24, 0x9A	; 154
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     4a6:	19 c0       	rjmp	.+50     	; 0x4da <__stack+0x7b>
		else if (page == 3)
     4a8:	8b 81       	ldd	r24, Y+3	; 0x03
     4aa:	9c 81       	ldd	r25, Y+4	; 0x04
     4ac:	83 30       	cpi	r24, 0x03	; 3
     4ae:	91 05       	cpc	r25, r1
     4b0:	41 f4       	brne	.+16     	; 0x4c2 <__stack+0x63>
			UARTCOMMUNICATION_send(COMMADN3PAGE3, time);
     4b2:	8e 81       	ldd	r24, Y+6	; 0x06
     4b4:	9f 81       	ldd	r25, Y+7	; 0x07
     4b6:	bc 01       	movw	r22, r24
     4b8:	80 ea       	ldi	r24, 0xA0	; 160
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     4c0:	0c c0       	rjmp	.+24     	; 0x4da <__stack+0x7b>
		else if (page == 4)
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	84 30       	cpi	r24, 0x04	; 4
     4c8:	91 05       	cpc	r25, r1
     4ca:	39 f4       	brne	.+14     	; 0x4da <__stack+0x7b>
			UARTCOMMUNICATION_send(COMMADN3PAGE4, time);
     4cc:	8e 81       	ldd	r24, Y+6	; 0x06
     4ce:	9f 81       	ldd	r25, Y+7	; 0x07
     4d0:	bc 01       	movw	r22, r24
     4d2:	86 ea       	ldi	r24, 0xA6	; 166
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
		DEVCOMMAND_LedInfoBlink(100, ledStatus);
     4da:	6d 81       	ldd	r22, Y+5	; 0x05
     4dc:	84 e6       	ldi	r24, 0x64	; 100
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	0e 94 ba 02 	call	0x574	; 0x574 <DEVCOMMAND_LedInfoBlink>
     4e4:	3d c0       	rjmp	.+122    	; 0x560 <__stack+0x101>
	} else if (location == 4) {
     4e6:	89 81       	ldd	r24, Y+1	; 0x01
     4e8:	9a 81       	ldd	r25, Y+2	; 0x02
     4ea:	84 30       	cpi	r24, 0x04	; 4
     4ec:	91 05       	cpc	r25, r1
     4ee:	c1 f5       	brne	.+112    	; 0x560 <__stack+0x101>
		if (page == 1)
     4f0:	8b 81       	ldd	r24, Y+3	; 0x03
     4f2:	9c 81       	ldd	r25, Y+4	; 0x04
     4f4:	81 30       	cpi	r24, 0x01	; 1
     4f6:	91 05       	cpc	r25, r1
     4f8:	41 f4       	brne	.+16     	; 0x50a <__stack+0xab>
			UARTCOMMUNICATION_send(COMMADN4PAGE1, time);
     4fa:	8e 81       	ldd	r24, Y+6	; 0x06
     4fc:	9f 81       	ldd	r25, Y+7	; 0x07
     4fe:	bc 01       	movw	r22, r24
     500:	8c ea       	ldi	r24, 0xAC	; 172
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     508:	26 c0       	rjmp	.+76     	; 0x556 <__stack+0xf7>
		else if (page == 2)
     50a:	8b 81       	ldd	r24, Y+3	; 0x03
     50c:	9c 81       	ldd	r25, Y+4	; 0x04
     50e:	82 30       	cpi	r24, 0x02	; 2
     510:	91 05       	cpc	r25, r1
     512:	41 f4       	brne	.+16     	; 0x524 <__stack+0xc5>
			UARTCOMMUNICATION_send(COMMADN4PAGE2, time);
     514:	8e 81       	ldd	r24, Y+6	; 0x06
     516:	9f 81       	ldd	r25, Y+7	; 0x07
     518:	bc 01       	movw	r22, r24
     51a:	82 eb       	ldi	r24, 0xB2	; 178
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     522:	19 c0       	rjmp	.+50     	; 0x556 <__stack+0xf7>
		else if (page == 3)
     524:	8b 81       	ldd	r24, Y+3	; 0x03
     526:	9c 81       	ldd	r25, Y+4	; 0x04
     528:	83 30       	cpi	r24, 0x03	; 3
     52a:	91 05       	cpc	r25, r1
     52c:	41 f4       	brne	.+16     	; 0x53e <__stack+0xdf>
			UARTCOMMUNICATION_send(COMMADN4PAGE3, time);
     52e:	8e 81       	ldd	r24, Y+6	; 0x06
     530:	9f 81       	ldd	r25, Y+7	; 0x07
     532:	bc 01       	movw	r22, r24
     534:	88 eb       	ldi	r24, 0xB8	; 184
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
     53c:	0c c0       	rjmp	.+24     	; 0x556 <__stack+0xf7>
		else if (page == 4)
     53e:	8b 81       	ldd	r24, Y+3	; 0x03
     540:	9c 81       	ldd	r25, Y+4	; 0x04
     542:	84 30       	cpi	r24, 0x04	; 4
     544:	91 05       	cpc	r25, r1
     546:	39 f4       	brne	.+14     	; 0x556 <__stack+0xf7>
			UARTCOMMUNICATION_send(COMMADN4PAGE4, time);
     548:	8e 81       	ldd	r24, Y+6	; 0x06
     54a:	9f 81       	ldd	r25, Y+7	; 0x07
     54c:	bc 01       	movw	r22, r24
     54e:	8e eb       	ldi	r24, 0xBE	; 190
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	0e 94 ff 14 	call	0x29fe	; 0x29fe <UARTCOMMUNICATION_send>
		DEVCOMMAND_LedInfoBlink(100, ledStatus);
     556:	6d 81       	ldd	r22, Y+5	; 0x05
     558:	84 e6       	ldi	r24, 0x64	; 100
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 ba 02 	call	0x574	; 0x574 <DEVCOMMAND_LedInfoBlink>
	}
	return;
     560:	00 00       	nop
}
     562:	27 96       	adiw	r28, 0x07	; 7
     564:	0f b6       	in	r0, 0x3f	; 63
     566:	f8 94       	cli
     568:	de bf       	out	0x3e, r29	; 62
     56a:	0f be       	out	0x3f, r0	; 63
     56c:	cd bf       	out	0x3d, r28	; 61
     56e:	df 91       	pop	r29
     570:	cf 91       	pop	r28
     572:	08 95       	ret

00000574 <DEVCOMMAND_LedInfoBlink>:

void DEVCOMMAND_LedInfoBlink(int time, bool ledStatus) {
     574:	cf 93       	push	r28
     576:	df 93       	push	r29
     578:	00 d0       	rcall	.+0      	; 0x57a <DEVCOMMAND_LedInfoBlink+0x6>
     57a:	1f 92       	push	r1
     57c:	cd b7       	in	r28, 0x3d	; 61
     57e:	de b7       	in	r29, 0x3e	; 62
     580:	9a 83       	std	Y+2, r25	; 0x02
     582:	89 83       	std	Y+1, r24	; 0x01
     584:	6b 83       	std	Y+3, r22	; 0x03
	if (ledStatus) {
     586:	8b 81       	ldd	r24, Y+3	; 0x03
     588:	88 23       	and	r24, r24
     58a:	49 f0       	breq	.+18     	; 0x59e <DEVCOMMAND_LedInfoBlink+0x2a>
		LedControl_ON(100);
     58c:	84 e6       	ldi	r24, 0x64	; 100
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
		LedControl_OFF(100);
     594:	84 e6       	ldi	r24, 0x64	; 100
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
     59c:	04 c0       	rjmp	.+8      	; 0x5a6 <DEVCOMMAND_LedInfoBlink+0x32>
	} else
		DELAY_ms(200);
     59e:	88 ec       	ldi	r24, 0xC8	; 200
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	return;
     5a6:	00 00       	nop
}
     5a8:	0f 90       	pop	r0
     5aa:	0f 90       	pop	r0
     5ac:	0f 90       	pop	r0
     5ae:	df 91       	pop	r29
     5b0:	cf 91       	pop	r28
     5b2:	08 95       	ret

000005b4 <LCDEXPLOITING_SetLctBrightness>:
 *      Author: Tomasz Bielas
 */

#include "../HEADERS/LCD_EXPLOITING.h"

void LCDEXPLOITING_SetLctBrightness(int val) {
     5b4:	cf 93       	push	r28
     5b6:	df 93       	push	r29
     5b8:	00 d0       	rcall	.+0      	; 0x5ba <LCDEXPLOITING_SetLctBrightness+0x6>
     5ba:	00 d0       	rcall	.+0      	; 0x5bc <LCDEXPLOITING_SetLctBrightness+0x8>
     5bc:	cd b7       	in	r28, 0x3d	; 61
     5be:	de b7       	in	r29, 0x3e	; 62
     5c0:	9c 83       	std	Y+4, r25	; 0x04
     5c2:	8b 83       	std	Y+3, r24	; 0x03
	if (val < 0 || val > 100)
     5c4:	8b 81       	ldd	r24, Y+3	; 0x03
     5c6:	9c 81       	ldd	r25, Y+4	; 0x04
     5c8:	99 23       	and	r25, r25
     5ca:	2c f0       	brlt	.+10     	; 0x5d6 <LCDEXPLOITING_SetLctBrightness+0x22>
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	85 36       	cpi	r24, 0x65	; 101
     5d2:	91 05       	cpc	r25, r1
     5d4:	0c f0       	brlt	.+2      	; 0x5d8 <LCDEXPLOITING_SetLctBrightness+0x24>
		return;
     5d6:	0f c0       	rjmp	.+30     	; 0x5f6 <LCDEXPLOITING_SetLctBrightness+0x42>
	int tmp = 100 - val;
     5d8:	24 e6       	ldi	r18, 0x64	; 100
     5da:	30 e0       	ldi	r19, 0x00	; 0
     5dc:	8b 81       	ldd	r24, Y+3	; 0x03
     5de:	9c 81       	ldd	r25, Y+4	; 0x04
     5e0:	a9 01       	movw	r20, r18
     5e2:	48 1b       	sub	r20, r24
     5e4:	59 0b       	sbc	r21, r25
     5e6:	ca 01       	movw	r24, r20
     5e8:	9a 83       	std	Y+2, r25	; 0x02
     5ea:	89 83       	std	Y+1, r24	; 0x01
	PWM_SetDutyCycle(1, tmp);
     5ec:	89 81       	ldd	r24, Y+1	; 0x01
     5ee:	68 2f       	mov	r22, r24
     5f0:	81 e0       	ldi	r24, 0x01	; 1
     5f2:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <PWM_SetDutyCycle>
}
     5f6:	0f 90       	pop	r0
     5f8:	0f 90       	pop	r0
     5fa:	0f 90       	pop	r0
     5fc:	0f 90       	pop	r0
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <screen_show_initialize>:

void screen_show_initialize(bool ledStatus,
		struct LCDEXPLOITING_AllPages *lcdPageLabbles,
		struct SettingsMenu_values *settinsgMenu_values) {
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	cd b7       	in	r28, 0x3d	; 61
     60a:	de b7       	in	r29, 0x3e	; 62
     60c:	63 97       	sbiw	r28, 0x13	; 19
     60e:	0f b6       	in	r0, 0x3f	; 63
     610:	f8 94       	cli
     612:	de bf       	out	0x3e, r29	; 62
     614:	0f be       	out	0x3f, r0	; 63
     616:	cd bf       	out	0x3d, r28	; 61
     618:	8f 87       	std	Y+15, r24	; 0x0f
     61a:	79 8b       	std	Y+17, r23	; 0x11
     61c:	68 8b       	std	Y+16, r22	; 0x10
     61e:	5b 8b       	std	Y+19, r21	; 0x13
     620:	4a 8b       	std	Y+18, r20	; 0x12

	LCD_Clear();
     622:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_XYPrintf(3, 0, "Waiting for");
     626:	84 ec       	ldi	r24, 0xC4	; 196
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	89 2f       	mov	r24, r25
     62c:	8f 93       	push	r24
     62e:	84 ec       	ldi	r24, 0xC4	; 196
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	8f 93       	push	r24
     634:	1f 92       	push	r1
     636:	1f 92       	push	r1
     638:	1f 92       	push	r1
     63a:	83 e0       	ldi	r24, 0x03	; 3
     63c:	8f 93       	push	r24
     63e:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     642:	0f 90       	pop	r0
     644:	0f 90       	pop	r0
     646:	0f 90       	pop	r0
     648:	0f 90       	pop	r0
     64a:	0f 90       	pop	r0
     64c:	0f 90       	pop	r0
	LCD_XYPrintf(3, 1, "connection");
     64e:	80 ed       	ldi	r24, 0xD0	; 208
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	89 2f       	mov	r24, r25
     654:	8f 93       	push	r24
     656:	80 ed       	ldi	r24, 0xD0	; 208
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	8f 93       	push	r24
     65c:	1f 92       	push	r1
     65e:	81 e0       	ldi	r24, 0x01	; 1
     660:	8f 93       	push	r24
     662:	1f 92       	push	r1
     664:	83 e0       	ldi	r24, 0x03	; 3
     666:	8f 93       	push	r24
     668:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     66c:	0f 90       	pop	r0
     66e:	0f 90       	pop	r0
     670:	0f 90       	pop	r0
     672:	0f 90       	pop	r0
     674:	0f 90       	pop	r0
     676:	0f 90       	pop	r0
	UART_Printf("RTW!\n");		//redy to write
     678:	8b ed       	ldi	r24, 0xDB	; 219
     67a:	90 e0       	ldi	r25, 0x00	; 0
     67c:	89 2f       	mov	r24, r25
     67e:	8f 93       	push	r24
     680:	8b ed       	ldi	r24, 0xDB	; 219
     682:	90 e0       	ldi	r25, 0x00	; 0
     684:	8f 93       	push	r24
     686:	0e 94 4c 30 	call	0x6098	; 0x6098 <UART_Printf>
     68a:	0f 90       	pop	r0
     68c:	0f 90       	pop	r0

	UART_RxString(lcdPageLabbles->page1.field1);
     68e:	88 89       	ldd	r24, Y+16	; 0x10
     690:	99 89       	ldd	r25, Y+17	; 0x11
     692:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     696:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     69a:	60 e0       	ldi	r22, 0x00	; 0
     69c:	80 e0       	ldi	r24, 0x00	; 0
     69e:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     6a2:	8a 89       	ldd	r24, Y+18	; 0x12
     6a4:	9b 89       	ldd	r25, Y+19	; 0x13
     6a6:	fc 01       	movw	r30, r24
     6a8:	80 85       	ldd	r24, Z+8	; 0x08
     6aa:	88 23       	and	r24, r24
     6ac:	d9 f0       	breq	.+54     	; 0x6e4 <screen_show_initialize+0xe0>
		LCD_XYPrintf(0, 0, "11:%s", lcdPageLabbles->page1.field1);
     6ae:	88 89       	ldd	r24, Y+16	; 0x10
     6b0:	99 89       	ldd	r25, Y+17	; 0x11
     6b2:	29 2f       	mov	r18, r25
     6b4:	2f 93       	push	r18
     6b6:	8f 93       	push	r24
     6b8:	81 ee       	ldi	r24, 0xE1	; 225
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	89 2f       	mov	r24, r25
     6be:	8f 93       	push	r24
     6c0:	81 ee       	ldi	r24, 0xE1	; 225
     6c2:	90 e0       	ldi	r25, 0x00	; 0
     6c4:	8f 93       	push	r24
     6c6:	1f 92       	push	r1
     6c8:	1f 92       	push	r1
     6ca:	1f 92       	push	r1
     6cc:	1f 92       	push	r1
     6ce:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     6d2:	8d b7       	in	r24, 0x3d	; 61
     6d4:	9e b7       	in	r25, 0x3e	; 62
     6d6:	08 96       	adiw	r24, 0x08	; 8
     6d8:	0f b6       	in	r0, 0x3f	; 63
     6da:	f8 94       	cli
     6dc:	de bf       	out	0x3e, r29	; 62
     6de:	0f be       	out	0x3f, r0	; 63
     6e0:	cd bf       	out	0x3d, r28	; 61
     6e2:	13 c0       	rjmp	.+38     	; 0x70a <screen_show_initialize+0x106>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     6e4:	87 ee       	ldi	r24, 0xE7	; 231
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	89 2f       	mov	r24, r25
     6ea:	8f 93       	push	r24
     6ec:	87 ee       	ldi	r24, 0xE7	; 231
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	8f 93       	push	r24
     6f2:	1f 92       	push	r1
     6f4:	1f 92       	push	r1
     6f6:	1f 92       	push	r1
     6f8:	1f 92       	push	r1
     6fa:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     6fe:	0f 90       	pop	r0
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	0f 90       	pop	r0
     708:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(1);
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page1.field2);
     712:	88 89       	ldd	r24, Y+16	; 0x10
     714:	99 89       	ldd	r25, Y+17	; 0x11
     716:	09 96       	adiw	r24, 0x09	; 9
     718:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     71c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     720:	60 e0       	ldi	r22, 0x00	; 0
     722:	80 e0       	ldi	r24, 0x00	; 0
     724:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     728:	8a 89       	ldd	r24, Y+18	; 0x12
     72a:	9b 89       	ldd	r25, Y+19	; 0x13
     72c:	fc 01       	movw	r30, r24
     72e:	80 85       	ldd	r24, Z+8	; 0x08
     730:	88 23       	and	r24, r24
     732:	e1 f0       	breq	.+56     	; 0x76c <screen_show_initialize+0x168>
		LCD_XYPrintf(0, 0, "12:%s", lcdPageLabbles->page1.field2);
     734:	88 89       	ldd	r24, Y+16	; 0x10
     736:	99 89       	ldd	r25, Y+17	; 0x11
     738:	09 96       	adiw	r24, 0x09	; 9
     73a:	29 2f       	mov	r18, r25
     73c:	2f 93       	push	r18
     73e:	8f 93       	push	r24
     740:	83 ef       	ldi	r24, 0xF3	; 243
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	89 2f       	mov	r24, r25
     746:	8f 93       	push	r24
     748:	83 ef       	ldi	r24, 0xF3	; 243
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	8f 93       	push	r24
     74e:	1f 92       	push	r1
     750:	1f 92       	push	r1
     752:	1f 92       	push	r1
     754:	1f 92       	push	r1
     756:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     75a:	8d b7       	in	r24, 0x3d	; 61
     75c:	9e b7       	in	r25, 0x3e	; 62
     75e:	08 96       	adiw	r24, 0x08	; 8
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	f8 94       	cli
     764:	de bf       	out	0x3e, r29	; 62
     766:	0f be       	out	0x3f, r0	; 63
     768:	cd bf       	out	0x3d, r28	; 61
     76a:	13 c0       	rjmp	.+38     	; 0x792 <screen_show_initialize+0x18e>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     76c:	87 ee       	ldi	r24, 0xE7	; 231
     76e:	90 e0       	ldi	r25, 0x00	; 0
     770:	89 2f       	mov	r24, r25
     772:	8f 93       	push	r24
     774:	87 ee       	ldi	r24, 0xE7	; 231
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	8f 93       	push	r24
     77a:	1f 92       	push	r1
     77c:	1f 92       	push	r1
     77e:	1f 92       	push	r1
     780:	1f 92       	push	r1
     782:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     786:	0f 90       	pop	r0
     788:	0f 90       	pop	r0
     78a:	0f 90       	pop	r0
     78c:	0f 90       	pop	r0
     78e:	0f 90       	pop	r0
     790:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(2);
     792:	82 e0       	ldi	r24, 0x02	; 2
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page1.field3);
     79a:	88 89       	ldd	r24, Y+16	; 0x10
     79c:	99 89       	ldd	r25, Y+17	; 0x11
     79e:	42 96       	adiw	r24, 0x12	; 18
     7a0:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     7a4:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     7a8:	60 e0       	ldi	r22, 0x00	; 0
     7aa:	80 e0       	ldi	r24, 0x00	; 0
     7ac:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     7b0:	8a 89       	ldd	r24, Y+18	; 0x12
     7b2:	9b 89       	ldd	r25, Y+19	; 0x13
     7b4:	fc 01       	movw	r30, r24
     7b6:	80 85       	ldd	r24, Z+8	; 0x08
     7b8:	88 23       	and	r24, r24
     7ba:	e1 f0       	breq	.+56     	; 0x7f4 <screen_show_initialize+0x1f0>
		LCD_XYPrintf(0, 0, "13:%s", lcdPageLabbles->page1.field3);
     7bc:	88 89       	ldd	r24, Y+16	; 0x10
     7be:	99 89       	ldd	r25, Y+17	; 0x11
     7c0:	42 96       	adiw	r24, 0x12	; 18
     7c2:	29 2f       	mov	r18, r25
     7c4:	2f 93       	push	r18
     7c6:	8f 93       	push	r24
     7c8:	89 ef       	ldi	r24, 0xF9	; 249
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	89 2f       	mov	r24, r25
     7ce:	8f 93       	push	r24
     7d0:	89 ef       	ldi	r24, 0xF9	; 249
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	8f 93       	push	r24
     7d6:	1f 92       	push	r1
     7d8:	1f 92       	push	r1
     7da:	1f 92       	push	r1
     7dc:	1f 92       	push	r1
     7de:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     7e2:	8d b7       	in	r24, 0x3d	; 61
     7e4:	9e b7       	in	r25, 0x3e	; 62
     7e6:	08 96       	adiw	r24, 0x08	; 8
     7e8:	0f b6       	in	r0, 0x3f	; 63
     7ea:	f8 94       	cli
     7ec:	de bf       	out	0x3e, r29	; 62
     7ee:	0f be       	out	0x3f, r0	; 63
     7f0:	cd bf       	out	0x3d, r28	; 61
     7f2:	13 c0       	rjmp	.+38     	; 0x81a <screen_show_initialize+0x216>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     7f4:	87 ee       	ldi	r24, 0xE7	; 231
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	89 2f       	mov	r24, r25
     7fa:	8f 93       	push	r24
     7fc:	87 ee       	ldi	r24, 0xE7	; 231
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	8f 93       	push	r24
     802:	1f 92       	push	r1
     804:	1f 92       	push	r1
     806:	1f 92       	push	r1
     808:	1f 92       	push	r1
     80a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     80e:	0f 90       	pop	r0
     810:	0f 90       	pop	r0
     812:	0f 90       	pop	r0
     814:	0f 90       	pop	r0
     816:	0f 90       	pop	r0
     818:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(3);
     81a:	83 e0       	ldi	r24, 0x03	; 3
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page1.field4);
     822:	88 89       	ldd	r24, Y+16	; 0x10
     824:	99 89       	ldd	r25, Y+17	; 0x11
     826:	4b 96       	adiw	r24, 0x1b	; 27
     828:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     82c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     830:	60 e0       	ldi	r22, 0x00	; 0
     832:	80 e0       	ldi	r24, 0x00	; 0
     834:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     838:	8a 89       	ldd	r24, Y+18	; 0x12
     83a:	9b 89       	ldd	r25, Y+19	; 0x13
     83c:	fc 01       	movw	r30, r24
     83e:	80 85       	ldd	r24, Z+8	; 0x08
     840:	88 23       	and	r24, r24
     842:	e1 f0       	breq	.+56     	; 0x87c <screen_show_initialize+0x278>
		LCD_XYPrintf(0, 0, "14:%s", lcdPageLabbles->page1.field4);
     844:	88 89       	ldd	r24, Y+16	; 0x10
     846:	99 89       	ldd	r25, Y+17	; 0x11
     848:	4b 96       	adiw	r24, 0x1b	; 27
     84a:	29 2f       	mov	r18, r25
     84c:	2f 93       	push	r18
     84e:	8f 93       	push	r24
     850:	8f ef       	ldi	r24, 0xFF	; 255
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	89 2f       	mov	r24, r25
     856:	8f 93       	push	r24
     858:	8f ef       	ldi	r24, 0xFF	; 255
     85a:	90 e0       	ldi	r25, 0x00	; 0
     85c:	8f 93       	push	r24
     85e:	1f 92       	push	r1
     860:	1f 92       	push	r1
     862:	1f 92       	push	r1
     864:	1f 92       	push	r1
     866:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     86a:	8d b7       	in	r24, 0x3d	; 61
     86c:	9e b7       	in	r25, 0x3e	; 62
     86e:	08 96       	adiw	r24, 0x08	; 8
     870:	0f b6       	in	r0, 0x3f	; 63
     872:	f8 94       	cli
     874:	de bf       	out	0x3e, r29	; 62
     876:	0f be       	out	0x3f, r0	; 63
     878:	cd bf       	out	0x3d, r28	; 61
     87a:	13 c0       	rjmp	.+38     	; 0x8a2 <screen_show_initialize+0x29e>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     87c:	87 ee       	ldi	r24, 0xE7	; 231
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	89 2f       	mov	r24, r25
     882:	8f 93       	push	r24
     884:	87 ee       	ldi	r24, 0xE7	; 231
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	8f 93       	push	r24
     88a:	1f 92       	push	r1
     88c:	1f 92       	push	r1
     88e:	1f 92       	push	r1
     890:	1f 92       	push	r1
     892:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     896:	0f 90       	pop	r0
     898:	0f 90       	pop	r0
     89a:	0f 90       	pop	r0
     89c:	0f 90       	pop	r0
     89e:	0f 90       	pop	r0
     8a0:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(4);
     8a2:	84 e0       	ldi	r24, 0x04	; 4
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page2.field1);
     8aa:	88 89       	ldd	r24, Y+16	; 0x10
     8ac:	99 89       	ldd	r25, Y+17	; 0x11
     8ae:	84 96       	adiw	r24, 0x24	; 36
     8b0:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     8b4:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     8b8:	60 e0       	ldi	r22, 0x00	; 0
     8ba:	80 e0       	ldi	r24, 0x00	; 0
     8bc:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     8c0:	8a 89       	ldd	r24, Y+18	; 0x12
     8c2:	9b 89       	ldd	r25, Y+19	; 0x13
     8c4:	fc 01       	movw	r30, r24
     8c6:	80 85       	ldd	r24, Z+8	; 0x08
     8c8:	88 23       	and	r24, r24
     8ca:	e1 f0       	breq	.+56     	; 0x904 <screen_show_initialize+0x300>
		LCD_XYPrintf(0, 0, "21:%s", lcdPageLabbles->page2.field1);
     8cc:	88 89       	ldd	r24, Y+16	; 0x10
     8ce:	99 89       	ldd	r25, Y+17	; 0x11
     8d0:	84 96       	adiw	r24, 0x24	; 36
     8d2:	29 2f       	mov	r18, r25
     8d4:	2f 93       	push	r18
     8d6:	8f 93       	push	r24
     8d8:	85 e0       	ldi	r24, 0x05	; 5
     8da:	91 e0       	ldi	r25, 0x01	; 1
     8dc:	89 2f       	mov	r24, r25
     8de:	8f 93       	push	r24
     8e0:	85 e0       	ldi	r24, 0x05	; 5
     8e2:	91 e0       	ldi	r25, 0x01	; 1
     8e4:	8f 93       	push	r24
     8e6:	1f 92       	push	r1
     8e8:	1f 92       	push	r1
     8ea:	1f 92       	push	r1
     8ec:	1f 92       	push	r1
     8ee:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     8f2:	8d b7       	in	r24, 0x3d	; 61
     8f4:	9e b7       	in	r25, 0x3e	; 62
     8f6:	08 96       	adiw	r24, 0x08	; 8
     8f8:	0f b6       	in	r0, 0x3f	; 63
     8fa:	f8 94       	cli
     8fc:	de bf       	out	0x3e, r29	; 62
     8fe:	0f be       	out	0x3f, r0	; 63
     900:	cd bf       	out	0x3d, r28	; 61
     902:	13 c0       	rjmp	.+38     	; 0x92a <screen_show_initialize+0x326>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     904:	87 ee       	ldi	r24, 0xE7	; 231
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	89 2f       	mov	r24, r25
     90a:	8f 93       	push	r24
     90c:	87 ee       	ldi	r24, 0xE7	; 231
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	8f 93       	push	r24
     912:	1f 92       	push	r1
     914:	1f 92       	push	r1
     916:	1f 92       	push	r1
     918:	1f 92       	push	r1
     91a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     91e:	0f 90       	pop	r0
     920:	0f 90       	pop	r0
     922:	0f 90       	pop	r0
     924:	0f 90       	pop	r0
     926:	0f 90       	pop	r0
     928:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(5);
     92a:	85 e0       	ldi	r24, 0x05	; 5
     92c:	90 e0       	ldi	r25, 0x00	; 0
     92e:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page2.field2);
     932:	88 89       	ldd	r24, Y+16	; 0x10
     934:	99 89       	ldd	r25, Y+17	; 0x11
     936:	8d 96       	adiw	r24, 0x2d	; 45
     938:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     93c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     940:	60 e0       	ldi	r22, 0x00	; 0
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     948:	8a 89       	ldd	r24, Y+18	; 0x12
     94a:	9b 89       	ldd	r25, Y+19	; 0x13
     94c:	fc 01       	movw	r30, r24
     94e:	80 85       	ldd	r24, Z+8	; 0x08
     950:	88 23       	and	r24, r24
     952:	e1 f0       	breq	.+56     	; 0x98c <screen_show_initialize+0x388>
		LCD_XYPrintf(0, 0, "22:%s", lcdPageLabbles->page2.field2);
     954:	88 89       	ldd	r24, Y+16	; 0x10
     956:	99 89       	ldd	r25, Y+17	; 0x11
     958:	8d 96       	adiw	r24, 0x2d	; 45
     95a:	29 2f       	mov	r18, r25
     95c:	2f 93       	push	r18
     95e:	8f 93       	push	r24
     960:	8b e0       	ldi	r24, 0x0B	; 11
     962:	91 e0       	ldi	r25, 0x01	; 1
     964:	89 2f       	mov	r24, r25
     966:	8f 93       	push	r24
     968:	8b e0       	ldi	r24, 0x0B	; 11
     96a:	91 e0       	ldi	r25, 0x01	; 1
     96c:	8f 93       	push	r24
     96e:	1f 92       	push	r1
     970:	1f 92       	push	r1
     972:	1f 92       	push	r1
     974:	1f 92       	push	r1
     976:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     97a:	8d b7       	in	r24, 0x3d	; 61
     97c:	9e b7       	in	r25, 0x3e	; 62
     97e:	08 96       	adiw	r24, 0x08	; 8
     980:	0f b6       	in	r0, 0x3f	; 63
     982:	f8 94       	cli
     984:	de bf       	out	0x3e, r29	; 62
     986:	0f be       	out	0x3f, r0	; 63
     988:	cd bf       	out	0x3d, r28	; 61
     98a:	13 c0       	rjmp	.+38     	; 0x9b2 <screen_show_initialize+0x3ae>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     98c:	87 ee       	ldi	r24, 0xE7	; 231
     98e:	90 e0       	ldi	r25, 0x00	; 0
     990:	89 2f       	mov	r24, r25
     992:	8f 93       	push	r24
     994:	87 ee       	ldi	r24, 0xE7	; 231
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	8f 93       	push	r24
     99a:	1f 92       	push	r1
     99c:	1f 92       	push	r1
     99e:	1f 92       	push	r1
     9a0:	1f 92       	push	r1
     9a2:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     9a6:	0f 90       	pop	r0
     9a8:	0f 90       	pop	r0
     9aa:	0f 90       	pop	r0
     9ac:	0f 90       	pop	r0
     9ae:	0f 90       	pop	r0
     9b0:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(6);
     9b2:	86 e0       	ldi	r24, 0x06	; 6
     9b4:	90 e0       	ldi	r25, 0x00	; 0
     9b6:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page2.field3);
     9ba:	88 89       	ldd	r24, Y+16	; 0x10
     9bc:	99 89       	ldd	r25, Y+17	; 0x11
     9be:	c6 96       	adiw	r24, 0x36	; 54
     9c0:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     9c4:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     9c8:	60 e0       	ldi	r22, 0x00	; 0
     9ca:	80 e0       	ldi	r24, 0x00	; 0
     9cc:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     9d0:	8a 89       	ldd	r24, Y+18	; 0x12
     9d2:	9b 89       	ldd	r25, Y+19	; 0x13
     9d4:	fc 01       	movw	r30, r24
     9d6:	80 85       	ldd	r24, Z+8	; 0x08
     9d8:	88 23       	and	r24, r24
     9da:	e1 f0       	breq	.+56     	; 0xa14 <screen_show_initialize+0x410>
		LCD_XYPrintf(0, 0, "23:%s", lcdPageLabbles->page2.field3);
     9dc:	88 89       	ldd	r24, Y+16	; 0x10
     9de:	99 89       	ldd	r25, Y+17	; 0x11
     9e0:	c6 96       	adiw	r24, 0x36	; 54
     9e2:	29 2f       	mov	r18, r25
     9e4:	2f 93       	push	r18
     9e6:	8f 93       	push	r24
     9e8:	81 e1       	ldi	r24, 0x11	; 17
     9ea:	91 e0       	ldi	r25, 0x01	; 1
     9ec:	89 2f       	mov	r24, r25
     9ee:	8f 93       	push	r24
     9f0:	81 e1       	ldi	r24, 0x11	; 17
     9f2:	91 e0       	ldi	r25, 0x01	; 1
     9f4:	8f 93       	push	r24
     9f6:	1f 92       	push	r1
     9f8:	1f 92       	push	r1
     9fa:	1f 92       	push	r1
     9fc:	1f 92       	push	r1
     9fe:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     a02:	8d b7       	in	r24, 0x3d	; 61
     a04:	9e b7       	in	r25, 0x3e	; 62
     a06:	08 96       	adiw	r24, 0x08	; 8
     a08:	0f b6       	in	r0, 0x3f	; 63
     a0a:	f8 94       	cli
     a0c:	de bf       	out	0x3e, r29	; 62
     a0e:	0f be       	out	0x3f, r0	; 63
     a10:	cd bf       	out	0x3d, r28	; 61
     a12:	13 c0       	rjmp	.+38     	; 0xa3a <screen_show_initialize+0x436>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     a14:	87 ee       	ldi	r24, 0xE7	; 231
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	89 2f       	mov	r24, r25
     a1a:	8f 93       	push	r24
     a1c:	87 ee       	ldi	r24, 0xE7	; 231
     a1e:	90 e0       	ldi	r25, 0x00	; 0
     a20:	8f 93       	push	r24
     a22:	1f 92       	push	r1
     a24:	1f 92       	push	r1
     a26:	1f 92       	push	r1
     a28:	1f 92       	push	r1
     a2a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     a2e:	0f 90       	pop	r0
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	0f 90       	pop	r0
     a38:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(7);
     a3a:	87 e0       	ldi	r24, 0x07	; 7
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page2.field4);
     a42:	88 89       	ldd	r24, Y+16	; 0x10
     a44:	99 89       	ldd	r25, Y+17	; 0x11
     a46:	cf 96       	adiw	r24, 0x3f	; 63
     a48:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     a4c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     a50:	60 e0       	ldi	r22, 0x00	; 0
     a52:	80 e0       	ldi	r24, 0x00	; 0
     a54:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     a58:	8a 89       	ldd	r24, Y+18	; 0x12
     a5a:	9b 89       	ldd	r25, Y+19	; 0x13
     a5c:	fc 01       	movw	r30, r24
     a5e:	80 85       	ldd	r24, Z+8	; 0x08
     a60:	88 23       	and	r24, r24
     a62:	e1 f0       	breq	.+56     	; 0xa9c <screen_show_initialize+0x498>
		LCD_XYPrintf(0, 0, "24:%s", lcdPageLabbles->page2.field4);
     a64:	88 89       	ldd	r24, Y+16	; 0x10
     a66:	99 89       	ldd	r25, Y+17	; 0x11
     a68:	cf 96       	adiw	r24, 0x3f	; 63
     a6a:	29 2f       	mov	r18, r25
     a6c:	2f 93       	push	r18
     a6e:	8f 93       	push	r24
     a70:	87 e1       	ldi	r24, 0x17	; 23
     a72:	91 e0       	ldi	r25, 0x01	; 1
     a74:	89 2f       	mov	r24, r25
     a76:	8f 93       	push	r24
     a78:	87 e1       	ldi	r24, 0x17	; 23
     a7a:	91 e0       	ldi	r25, 0x01	; 1
     a7c:	8f 93       	push	r24
     a7e:	1f 92       	push	r1
     a80:	1f 92       	push	r1
     a82:	1f 92       	push	r1
     a84:	1f 92       	push	r1
     a86:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     a8a:	8d b7       	in	r24, 0x3d	; 61
     a8c:	9e b7       	in	r25, 0x3e	; 62
     a8e:	08 96       	adiw	r24, 0x08	; 8
     a90:	0f b6       	in	r0, 0x3f	; 63
     a92:	f8 94       	cli
     a94:	de bf       	out	0x3e, r29	; 62
     a96:	0f be       	out	0x3f, r0	; 63
     a98:	cd bf       	out	0x3d, r28	; 61
     a9a:	13 c0       	rjmp	.+38     	; 0xac2 <screen_show_initialize+0x4be>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     a9c:	87 ee       	ldi	r24, 0xE7	; 231
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	89 2f       	mov	r24, r25
     aa2:	8f 93       	push	r24
     aa4:	87 ee       	ldi	r24, 0xE7	; 231
     aa6:	90 e0       	ldi	r25, 0x00	; 0
     aa8:	8f 93       	push	r24
     aaa:	1f 92       	push	r1
     aac:	1f 92       	push	r1
     aae:	1f 92       	push	r1
     ab0:	1f 92       	push	r1
     ab2:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     ab6:	0f 90       	pop	r0
     ab8:	0f 90       	pop	r0
     aba:	0f 90       	pop	r0
     abc:	0f 90       	pop	r0
     abe:	0f 90       	pop	r0
     ac0:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(8);
     ac2:	88 e0       	ldi	r24, 0x08	; 8
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page3.field1);
     aca:	88 89       	ldd	r24, Y+16	; 0x10
     acc:	99 89       	ldd	r25, Y+17	; 0x11
     ace:	88 5b       	subi	r24, 0xB8	; 184
     ad0:	9f 4f       	sbci	r25, 0xFF	; 255
     ad2:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     ad6:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     ada:	60 e0       	ldi	r22, 0x00	; 0
     adc:	80 e0       	ldi	r24, 0x00	; 0
     ade:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     ae2:	8a 89       	ldd	r24, Y+18	; 0x12
     ae4:	9b 89       	ldd	r25, Y+19	; 0x13
     ae6:	fc 01       	movw	r30, r24
     ae8:	80 85       	ldd	r24, Z+8	; 0x08
     aea:	88 23       	and	r24, r24
     aec:	e9 f0       	breq	.+58     	; 0xb28 <screen_show_initialize+0x524>
		LCD_XYPrintf(0, 0, "31:%s", lcdPageLabbles->page3.field1);
     aee:	88 89       	ldd	r24, Y+16	; 0x10
     af0:	99 89       	ldd	r25, Y+17	; 0x11
     af2:	88 5b       	subi	r24, 0xB8	; 184
     af4:	9f 4f       	sbci	r25, 0xFF	; 255
     af6:	29 2f       	mov	r18, r25
     af8:	2f 93       	push	r18
     afa:	8f 93       	push	r24
     afc:	8d e1       	ldi	r24, 0x1D	; 29
     afe:	91 e0       	ldi	r25, 0x01	; 1
     b00:	89 2f       	mov	r24, r25
     b02:	8f 93       	push	r24
     b04:	8d e1       	ldi	r24, 0x1D	; 29
     b06:	91 e0       	ldi	r25, 0x01	; 1
     b08:	8f 93       	push	r24
     b0a:	1f 92       	push	r1
     b0c:	1f 92       	push	r1
     b0e:	1f 92       	push	r1
     b10:	1f 92       	push	r1
     b12:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     b16:	8d b7       	in	r24, 0x3d	; 61
     b18:	9e b7       	in	r25, 0x3e	; 62
     b1a:	08 96       	adiw	r24, 0x08	; 8
     b1c:	0f b6       	in	r0, 0x3f	; 63
     b1e:	f8 94       	cli
     b20:	de bf       	out	0x3e, r29	; 62
     b22:	0f be       	out	0x3f, r0	; 63
     b24:	cd bf       	out	0x3d, r28	; 61
     b26:	13 c0       	rjmp	.+38     	; 0xb4e <screen_show_initialize+0x54a>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     b28:	87 ee       	ldi	r24, 0xE7	; 231
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	89 2f       	mov	r24, r25
     b2e:	8f 93       	push	r24
     b30:	87 ee       	ldi	r24, 0xE7	; 231
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	8f 93       	push	r24
     b36:	1f 92       	push	r1
     b38:	1f 92       	push	r1
     b3a:	1f 92       	push	r1
     b3c:	1f 92       	push	r1
     b3e:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     b42:	0f 90       	pop	r0
     b44:	0f 90       	pop	r0
     b46:	0f 90       	pop	r0
     b48:	0f 90       	pop	r0
     b4a:	0f 90       	pop	r0
     b4c:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(9);
     b4e:	89 e0       	ldi	r24, 0x09	; 9
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page3.field2);
     b56:	88 89       	ldd	r24, Y+16	; 0x10
     b58:	99 89       	ldd	r25, Y+17	; 0x11
     b5a:	8f 5a       	subi	r24, 0xAF	; 175
     b5c:	9f 4f       	sbci	r25, 0xFF	; 255
     b5e:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     b62:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     b66:	60 e0       	ldi	r22, 0x00	; 0
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     b6e:	8a 89       	ldd	r24, Y+18	; 0x12
     b70:	9b 89       	ldd	r25, Y+19	; 0x13
     b72:	fc 01       	movw	r30, r24
     b74:	80 85       	ldd	r24, Z+8	; 0x08
     b76:	88 23       	and	r24, r24
     b78:	e9 f0       	breq	.+58     	; 0xbb4 <screen_show_initialize+0x5b0>
		LCD_XYPrintf(0, 0, "32:%s", lcdPageLabbles->page3.field2);
     b7a:	88 89       	ldd	r24, Y+16	; 0x10
     b7c:	99 89       	ldd	r25, Y+17	; 0x11
     b7e:	8f 5a       	subi	r24, 0xAF	; 175
     b80:	9f 4f       	sbci	r25, 0xFF	; 255
     b82:	29 2f       	mov	r18, r25
     b84:	2f 93       	push	r18
     b86:	8f 93       	push	r24
     b88:	83 e2       	ldi	r24, 0x23	; 35
     b8a:	91 e0       	ldi	r25, 0x01	; 1
     b8c:	89 2f       	mov	r24, r25
     b8e:	8f 93       	push	r24
     b90:	83 e2       	ldi	r24, 0x23	; 35
     b92:	91 e0       	ldi	r25, 0x01	; 1
     b94:	8f 93       	push	r24
     b96:	1f 92       	push	r1
     b98:	1f 92       	push	r1
     b9a:	1f 92       	push	r1
     b9c:	1f 92       	push	r1
     b9e:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     ba2:	8d b7       	in	r24, 0x3d	; 61
     ba4:	9e b7       	in	r25, 0x3e	; 62
     ba6:	08 96       	adiw	r24, 0x08	; 8
     ba8:	0f b6       	in	r0, 0x3f	; 63
     baa:	f8 94       	cli
     bac:	de bf       	out	0x3e, r29	; 62
     bae:	0f be       	out	0x3f, r0	; 63
     bb0:	cd bf       	out	0x3d, r28	; 61
     bb2:	13 c0       	rjmp	.+38     	; 0xbda <screen_show_initialize+0x5d6>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     bb4:	87 ee       	ldi	r24, 0xE7	; 231
     bb6:	90 e0       	ldi	r25, 0x00	; 0
     bb8:	89 2f       	mov	r24, r25
     bba:	8f 93       	push	r24
     bbc:	87 ee       	ldi	r24, 0xE7	; 231
     bbe:	90 e0       	ldi	r25, 0x00	; 0
     bc0:	8f 93       	push	r24
     bc2:	1f 92       	push	r1
     bc4:	1f 92       	push	r1
     bc6:	1f 92       	push	r1
     bc8:	1f 92       	push	r1
     bca:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     bce:	0f 90       	pop	r0
     bd0:	0f 90       	pop	r0
     bd2:	0f 90       	pop	r0
     bd4:	0f 90       	pop	r0
     bd6:	0f 90       	pop	r0
     bd8:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(10);
     bda:	8a e0       	ldi	r24, 0x0A	; 10
     bdc:	90 e0       	ldi	r25, 0x00	; 0
     bde:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page3.field3);
     be2:	88 89       	ldd	r24, Y+16	; 0x10
     be4:	99 89       	ldd	r25, Y+17	; 0x11
     be6:	86 5a       	subi	r24, 0xA6	; 166
     be8:	9f 4f       	sbci	r25, 0xFF	; 255
     bea:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     bee:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     bf2:	60 e0       	ldi	r22, 0x00	; 0
     bf4:	80 e0       	ldi	r24, 0x00	; 0
     bf6:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     bfa:	8a 89       	ldd	r24, Y+18	; 0x12
     bfc:	9b 89       	ldd	r25, Y+19	; 0x13
     bfe:	fc 01       	movw	r30, r24
     c00:	80 85       	ldd	r24, Z+8	; 0x08
     c02:	88 23       	and	r24, r24
     c04:	e9 f0       	breq	.+58     	; 0xc40 <screen_show_initialize+0x63c>
		LCD_XYPrintf(0, 0, "33:%s", lcdPageLabbles->page3.field3);
     c06:	88 89       	ldd	r24, Y+16	; 0x10
     c08:	99 89       	ldd	r25, Y+17	; 0x11
     c0a:	86 5a       	subi	r24, 0xA6	; 166
     c0c:	9f 4f       	sbci	r25, 0xFF	; 255
     c0e:	29 2f       	mov	r18, r25
     c10:	2f 93       	push	r18
     c12:	8f 93       	push	r24
     c14:	89 e2       	ldi	r24, 0x29	; 41
     c16:	91 e0       	ldi	r25, 0x01	; 1
     c18:	89 2f       	mov	r24, r25
     c1a:	8f 93       	push	r24
     c1c:	89 e2       	ldi	r24, 0x29	; 41
     c1e:	91 e0       	ldi	r25, 0x01	; 1
     c20:	8f 93       	push	r24
     c22:	1f 92       	push	r1
     c24:	1f 92       	push	r1
     c26:	1f 92       	push	r1
     c28:	1f 92       	push	r1
     c2a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     c2e:	8d b7       	in	r24, 0x3d	; 61
     c30:	9e b7       	in	r25, 0x3e	; 62
     c32:	08 96       	adiw	r24, 0x08	; 8
     c34:	0f b6       	in	r0, 0x3f	; 63
     c36:	f8 94       	cli
     c38:	de bf       	out	0x3e, r29	; 62
     c3a:	0f be       	out	0x3f, r0	; 63
     c3c:	cd bf       	out	0x3d, r28	; 61
     c3e:	13 c0       	rjmp	.+38     	; 0xc66 <screen_show_initialize+0x662>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     c40:	87 ee       	ldi	r24, 0xE7	; 231
     c42:	90 e0       	ldi	r25, 0x00	; 0
     c44:	89 2f       	mov	r24, r25
     c46:	8f 93       	push	r24
     c48:	87 ee       	ldi	r24, 0xE7	; 231
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	8f 93       	push	r24
     c4e:	1f 92       	push	r1
     c50:	1f 92       	push	r1
     c52:	1f 92       	push	r1
     c54:	1f 92       	push	r1
     c56:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     c5a:	0f 90       	pop	r0
     c5c:	0f 90       	pop	r0
     c5e:	0f 90       	pop	r0
     c60:	0f 90       	pop	r0
     c62:	0f 90       	pop	r0
     c64:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(11);
     c66:	8b e0       	ldi	r24, 0x0B	; 11
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page3.field4);
     c6e:	88 89       	ldd	r24, Y+16	; 0x10
     c70:	99 89       	ldd	r25, Y+17	; 0x11
     c72:	8d 59       	subi	r24, 0x9D	; 157
     c74:	9f 4f       	sbci	r25, 0xFF	; 255
     c76:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     c7a:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     c7e:	60 e0       	ldi	r22, 0x00	; 0
     c80:	80 e0       	ldi	r24, 0x00	; 0
     c82:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     c86:	8a 89       	ldd	r24, Y+18	; 0x12
     c88:	9b 89       	ldd	r25, Y+19	; 0x13
     c8a:	fc 01       	movw	r30, r24
     c8c:	80 85       	ldd	r24, Z+8	; 0x08
     c8e:	88 23       	and	r24, r24
     c90:	e9 f0       	breq	.+58     	; 0xccc <screen_show_initialize+0x6c8>
		LCD_XYPrintf(0, 0, "34:%s", lcdPageLabbles->page3.field4);
     c92:	88 89       	ldd	r24, Y+16	; 0x10
     c94:	99 89       	ldd	r25, Y+17	; 0x11
     c96:	8d 59       	subi	r24, 0x9D	; 157
     c98:	9f 4f       	sbci	r25, 0xFF	; 255
     c9a:	29 2f       	mov	r18, r25
     c9c:	2f 93       	push	r18
     c9e:	8f 93       	push	r24
     ca0:	8f e2       	ldi	r24, 0x2F	; 47
     ca2:	91 e0       	ldi	r25, 0x01	; 1
     ca4:	89 2f       	mov	r24, r25
     ca6:	8f 93       	push	r24
     ca8:	8f e2       	ldi	r24, 0x2F	; 47
     caa:	91 e0       	ldi	r25, 0x01	; 1
     cac:	8f 93       	push	r24
     cae:	1f 92       	push	r1
     cb0:	1f 92       	push	r1
     cb2:	1f 92       	push	r1
     cb4:	1f 92       	push	r1
     cb6:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     cba:	8d b7       	in	r24, 0x3d	; 61
     cbc:	9e b7       	in	r25, 0x3e	; 62
     cbe:	08 96       	adiw	r24, 0x08	; 8
     cc0:	0f b6       	in	r0, 0x3f	; 63
     cc2:	f8 94       	cli
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	0f be       	out	0x3f, r0	; 63
     cc8:	cd bf       	out	0x3d, r28	; 61
     cca:	13 c0       	rjmp	.+38     	; 0xcf2 <screen_show_initialize+0x6ee>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     ccc:	87 ee       	ldi	r24, 0xE7	; 231
     cce:	90 e0       	ldi	r25, 0x00	; 0
     cd0:	89 2f       	mov	r24, r25
     cd2:	8f 93       	push	r24
     cd4:	87 ee       	ldi	r24, 0xE7	; 231
     cd6:	90 e0       	ldi	r25, 0x00	; 0
     cd8:	8f 93       	push	r24
     cda:	1f 92       	push	r1
     cdc:	1f 92       	push	r1
     cde:	1f 92       	push	r1
     ce0:	1f 92       	push	r1
     ce2:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     ce6:	0f 90       	pop	r0
     ce8:	0f 90       	pop	r0
     cea:	0f 90       	pop	r0
     cec:	0f 90       	pop	r0
     cee:	0f 90       	pop	r0
     cf0:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(12);
     cf2:	8c e0       	ldi	r24, 0x0C	; 12
     cf4:	90 e0       	ldi	r25, 0x00	; 0
     cf6:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page4.field1);
     cfa:	88 89       	ldd	r24, Y+16	; 0x10
     cfc:	99 89       	ldd	r25, Y+17	; 0x11
     cfe:	84 59       	subi	r24, 0x94	; 148
     d00:	9f 4f       	sbci	r25, 0xFF	; 255
     d02:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     d06:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     d0a:	60 e0       	ldi	r22, 0x00	; 0
     d0c:	80 e0       	ldi	r24, 0x00	; 0
     d0e:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     d12:	8a 89       	ldd	r24, Y+18	; 0x12
     d14:	9b 89       	ldd	r25, Y+19	; 0x13
     d16:	fc 01       	movw	r30, r24
     d18:	80 85       	ldd	r24, Z+8	; 0x08
     d1a:	88 23       	and	r24, r24
     d1c:	e9 f0       	breq	.+58     	; 0xd58 <screen_show_initialize+0x754>
		LCD_XYPrintf(0, 0, "41:%s", lcdPageLabbles->page4.field1);
     d1e:	88 89       	ldd	r24, Y+16	; 0x10
     d20:	99 89       	ldd	r25, Y+17	; 0x11
     d22:	84 59       	subi	r24, 0x94	; 148
     d24:	9f 4f       	sbci	r25, 0xFF	; 255
     d26:	29 2f       	mov	r18, r25
     d28:	2f 93       	push	r18
     d2a:	8f 93       	push	r24
     d2c:	85 e3       	ldi	r24, 0x35	; 53
     d2e:	91 e0       	ldi	r25, 0x01	; 1
     d30:	89 2f       	mov	r24, r25
     d32:	8f 93       	push	r24
     d34:	85 e3       	ldi	r24, 0x35	; 53
     d36:	91 e0       	ldi	r25, 0x01	; 1
     d38:	8f 93       	push	r24
     d3a:	1f 92       	push	r1
     d3c:	1f 92       	push	r1
     d3e:	1f 92       	push	r1
     d40:	1f 92       	push	r1
     d42:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     d46:	8d b7       	in	r24, 0x3d	; 61
     d48:	9e b7       	in	r25, 0x3e	; 62
     d4a:	08 96       	adiw	r24, 0x08	; 8
     d4c:	0f b6       	in	r0, 0x3f	; 63
     d4e:	f8 94       	cli
     d50:	de bf       	out	0x3e, r29	; 62
     d52:	0f be       	out	0x3f, r0	; 63
     d54:	cd bf       	out	0x3d, r28	; 61
     d56:	13 c0       	rjmp	.+38     	; 0xd7e <screen_show_initialize+0x77a>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     d58:	87 ee       	ldi	r24, 0xE7	; 231
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	89 2f       	mov	r24, r25
     d5e:	8f 93       	push	r24
     d60:	87 ee       	ldi	r24, 0xE7	; 231
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	8f 93       	push	r24
     d66:	1f 92       	push	r1
     d68:	1f 92       	push	r1
     d6a:	1f 92       	push	r1
     d6c:	1f 92       	push	r1
     d6e:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	0f 90       	pop	r0
     d78:	0f 90       	pop	r0
     d7a:	0f 90       	pop	r0
     d7c:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(13);
     d7e:	8d e0       	ldi	r24, 0x0D	; 13
     d80:	90 e0       	ldi	r25, 0x00	; 0
     d82:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page4.field2);
     d86:	88 89       	ldd	r24, Y+16	; 0x10
     d88:	99 89       	ldd	r25, Y+17	; 0x11
     d8a:	8b 58       	subi	r24, 0x8B	; 139
     d8c:	9f 4f       	sbci	r25, 0xFF	; 255
     d8e:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     d92:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     d96:	60 e0       	ldi	r22, 0x00	; 0
     d98:	80 e0       	ldi	r24, 0x00	; 0
     d9a:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     d9e:	8a 89       	ldd	r24, Y+18	; 0x12
     da0:	9b 89       	ldd	r25, Y+19	; 0x13
     da2:	fc 01       	movw	r30, r24
     da4:	80 85       	ldd	r24, Z+8	; 0x08
     da6:	88 23       	and	r24, r24
     da8:	e9 f0       	breq	.+58     	; 0xde4 <screen_show_initialize+0x7e0>
		LCD_XYPrintf(0, 0, "42:%s", lcdPageLabbles->page4.field2);
     daa:	88 89       	ldd	r24, Y+16	; 0x10
     dac:	99 89       	ldd	r25, Y+17	; 0x11
     dae:	8b 58       	subi	r24, 0x8B	; 139
     db0:	9f 4f       	sbci	r25, 0xFF	; 255
     db2:	29 2f       	mov	r18, r25
     db4:	2f 93       	push	r18
     db6:	8f 93       	push	r24
     db8:	8b e3       	ldi	r24, 0x3B	; 59
     dba:	91 e0       	ldi	r25, 0x01	; 1
     dbc:	89 2f       	mov	r24, r25
     dbe:	8f 93       	push	r24
     dc0:	8b e3       	ldi	r24, 0x3B	; 59
     dc2:	91 e0       	ldi	r25, 0x01	; 1
     dc4:	8f 93       	push	r24
     dc6:	1f 92       	push	r1
     dc8:	1f 92       	push	r1
     dca:	1f 92       	push	r1
     dcc:	1f 92       	push	r1
     dce:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     dd2:	8d b7       	in	r24, 0x3d	; 61
     dd4:	9e b7       	in	r25, 0x3e	; 62
     dd6:	08 96       	adiw	r24, 0x08	; 8
     dd8:	0f b6       	in	r0, 0x3f	; 63
     dda:	f8 94       	cli
     ddc:	de bf       	out	0x3e, r29	; 62
     dde:	0f be       	out	0x3f, r0	; 63
     de0:	cd bf       	out	0x3d, r28	; 61
     de2:	13 c0       	rjmp	.+38     	; 0xe0a <screen_show_initialize+0x806>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     de4:	87 ee       	ldi	r24, 0xE7	; 231
     de6:	90 e0       	ldi	r25, 0x00	; 0
     de8:	89 2f       	mov	r24, r25
     dea:	8f 93       	push	r24
     dec:	87 ee       	ldi	r24, 0xE7	; 231
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	8f 93       	push	r24
     df2:	1f 92       	push	r1
     df4:	1f 92       	push	r1
     df6:	1f 92       	push	r1
     df8:	1f 92       	push	r1
     dfa:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     dfe:	0f 90       	pop	r0
     e00:	0f 90       	pop	r0
     e02:	0f 90       	pop	r0
     e04:	0f 90       	pop	r0
     e06:	0f 90       	pop	r0
     e08:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(14);
     e0a:	8e e0       	ldi	r24, 0x0E	; 14
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page4.field3);
     e12:	88 89       	ldd	r24, Y+16	; 0x10
     e14:	99 89       	ldd	r25, Y+17	; 0x11
     e16:	82 58       	subi	r24, 0x82	; 130
     e18:	9f 4f       	sbci	r25, 0xFF	; 255
     e1a:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     e1e:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     e22:	60 e0       	ldi	r22, 0x00	; 0
     e24:	80 e0       	ldi	r24, 0x00	; 0
     e26:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     e2a:	8a 89       	ldd	r24, Y+18	; 0x12
     e2c:	9b 89       	ldd	r25, Y+19	; 0x13
     e2e:	fc 01       	movw	r30, r24
     e30:	80 85       	ldd	r24, Z+8	; 0x08
     e32:	88 23       	and	r24, r24
     e34:	e9 f0       	breq	.+58     	; 0xe70 <screen_show_initialize+0x86c>
		LCD_XYPrintf(0, 0, "43:%s", lcdPageLabbles->page4.field3);
     e36:	88 89       	ldd	r24, Y+16	; 0x10
     e38:	99 89       	ldd	r25, Y+17	; 0x11
     e3a:	82 58       	subi	r24, 0x82	; 130
     e3c:	9f 4f       	sbci	r25, 0xFF	; 255
     e3e:	29 2f       	mov	r18, r25
     e40:	2f 93       	push	r18
     e42:	8f 93       	push	r24
     e44:	81 e4       	ldi	r24, 0x41	; 65
     e46:	91 e0       	ldi	r25, 0x01	; 1
     e48:	89 2f       	mov	r24, r25
     e4a:	8f 93       	push	r24
     e4c:	81 e4       	ldi	r24, 0x41	; 65
     e4e:	91 e0       	ldi	r25, 0x01	; 1
     e50:	8f 93       	push	r24
     e52:	1f 92       	push	r1
     e54:	1f 92       	push	r1
     e56:	1f 92       	push	r1
     e58:	1f 92       	push	r1
     e5a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     e5e:	8d b7       	in	r24, 0x3d	; 61
     e60:	9e b7       	in	r25, 0x3e	; 62
     e62:	08 96       	adiw	r24, 0x08	; 8
     e64:	0f b6       	in	r0, 0x3f	; 63
     e66:	f8 94       	cli
     e68:	de bf       	out	0x3e, r29	; 62
     e6a:	0f be       	out	0x3f, r0	; 63
     e6c:	cd bf       	out	0x3d, r28	; 61
     e6e:	13 c0       	rjmp	.+38     	; 0xe96 <screen_show_initialize+0x892>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     e70:	87 ee       	ldi	r24, 0xE7	; 231
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	89 2f       	mov	r24, r25
     e76:	8f 93       	push	r24
     e78:	87 ee       	ldi	r24, 0xE7	; 231
     e7a:	90 e0       	ldi	r25, 0x00	; 0
     e7c:	8f 93       	push	r24
     e7e:	1f 92       	push	r1
     e80:	1f 92       	push	r1
     e82:	1f 92       	push	r1
     e84:	1f 92       	push	r1
     e86:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     e8a:	0f 90       	pop	r0
     e8c:	0f 90       	pop	r0
     e8e:	0f 90       	pop	r0
     e90:	0f 90       	pop	r0
     e92:	0f 90       	pop	r0
     e94:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(15);
     e96:	8f e0       	ldi	r24, 0x0F	; 15
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>

	UART_RxString(lcdPageLabbles->page4.field4);
     e9e:	88 89       	ldd	r24, Y+16	; 0x10
     ea0:	99 89       	ldd	r25, Y+17	; 0x11
     ea2:	89 57       	subi	r24, 0x79	; 121
     ea4:	9f 4f       	sbci	r25, 0xFF	; 255
     ea6:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <UART_RxString>
	LCD_Clear();
     eaa:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_SetCursor(0, 0);
     eae:	60 e0       	ldi	r22, 0x00	; 0
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	if (settinsgMenu_values->debugMode == 1)
     eb6:	8a 89       	ldd	r24, Y+18	; 0x12
     eb8:	9b 89       	ldd	r25, Y+19	; 0x13
     eba:	fc 01       	movw	r30, r24
     ebc:	80 85       	ldd	r24, Z+8	; 0x08
     ebe:	88 23       	and	r24, r24
     ec0:	e9 f0       	breq	.+58     	; 0xefc <screen_show_initialize+0x8f8>
		LCD_XYPrintf(0, 0, "44:%s", lcdPageLabbles->page4.field4);
     ec2:	88 89       	ldd	r24, Y+16	; 0x10
     ec4:	99 89       	ldd	r25, Y+17	; 0x11
     ec6:	89 57       	subi	r24, 0x79	; 121
     ec8:	9f 4f       	sbci	r25, 0xFF	; 255
     eca:	29 2f       	mov	r18, r25
     ecc:	2f 93       	push	r18
     ece:	8f 93       	push	r24
     ed0:	87 e4       	ldi	r24, 0x47	; 71
     ed2:	91 e0       	ldi	r25, 0x01	; 1
     ed4:	89 2f       	mov	r24, r25
     ed6:	8f 93       	push	r24
     ed8:	87 e4       	ldi	r24, 0x47	; 71
     eda:	91 e0       	ldi	r25, 0x01	; 1
     edc:	8f 93       	push	r24
     ede:	1f 92       	push	r1
     ee0:	1f 92       	push	r1
     ee2:	1f 92       	push	r1
     ee4:	1f 92       	push	r1
     ee6:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     eea:	8d b7       	in	r24, 0x3d	; 61
     eec:	9e b7       	in	r25, 0x3e	; 62
     eee:	08 96       	adiw	r24, 0x08	; 8
     ef0:	0f b6       	in	r0, 0x3f	; 63
     ef2:	f8 94       	cli
     ef4:	de bf       	out	0x3e, r29	; 62
     ef6:	0f be       	out	0x3f, r0	; 63
     ef8:	cd bf       	out	0x3d, r28	; 61
     efa:	13 c0       	rjmp	.+38     	; 0xf22 <screen_show_initialize+0x91e>
	else
		LCD_XYPrintf(0, 0, "Please wait");
     efc:	87 ee       	ldi	r24, 0xE7	; 231
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	89 2f       	mov	r24, r25
     f02:	8f 93       	push	r24
     f04:	87 ee       	ldi	r24, 0xE7	; 231
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	8f 93       	push	r24
     f0a:	1f 92       	push	r1
     f0c:	1f 92       	push	r1
     f0e:	1f 92       	push	r1
     f10:	1f 92       	push	r1
     f12:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
     f16:	0f 90       	pop	r0
     f18:	0f 90       	pop	r0
     f1a:	0f 90       	pop	r0
     f1c:	0f 90       	pop	r0
     f1e:	0f 90       	pop	r0
     f20:	0f 90       	pop	r0
	LCDEXPLOITING_DrawLoading(16);
     f22:	80 e1       	ldi	r24, 0x10	; 16
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	0e 94 08 0b 	call	0x1610	; 0x1610 <LCDEXPLOITING_DrawLoading>
     f2a:	80 e0       	ldi	r24, 0x00	; 0
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	aa ef       	ldi	r26, 0xFA	; 250
     f30:	b3 e4       	ldi	r27, 0x43	; 67
     f32:	89 83       	std	Y+1, r24	; 0x01
     f34:	9a 83       	std	Y+2, r25	; 0x02
     f36:	ab 83       	std	Y+3, r26	; 0x03
     f38:	bc 83       	std	Y+4, r27	; 0x04

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     f3a:	20 e0       	ldi	r18, 0x00	; 0
     f3c:	30 e0       	ldi	r19, 0x00	; 0
     f3e:	4a e7       	ldi	r20, 0x7A	; 122
     f40:	53 e4       	ldi	r21, 0x43	; 67
     f42:	69 81       	ldd	r22, Y+1	; 0x01
     f44:	7a 81       	ldd	r23, Y+2	; 0x02
     f46:	8b 81       	ldd	r24, Y+3	; 0x03
     f48:	9c 81       	ldd	r25, Y+4	; 0x04
     f4a:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
     f4e:	dc 01       	movw	r26, r24
     f50:	cb 01       	movw	r24, r22
     f52:	8d 83       	std	Y+5, r24	; 0x05
     f54:	9e 83       	std	Y+6, r25	; 0x06
     f56:	af 83       	std	Y+7, r26	; 0x07
     f58:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
     f5a:	20 e0       	ldi	r18, 0x00	; 0
     f5c:	30 e0       	ldi	r19, 0x00	; 0
     f5e:	40 e8       	ldi	r20, 0x80	; 128
     f60:	5f e3       	ldi	r21, 0x3F	; 63
     f62:	6d 81       	ldd	r22, Y+5	; 0x05
     f64:	7e 81       	ldd	r23, Y+6	; 0x06
     f66:	8f 81       	ldd	r24, Y+7	; 0x07
     f68:	98 85       	ldd	r25, Y+8	; 0x08
     f6a:	0e 94 b5 32 	call	0x656a	; 0x656a <__cmpsf2>
     f6e:	88 23       	and	r24, r24
     f70:	2c f4       	brge	.+10     	; 0xf7c <screen_show_initialize+0x978>
		__ticks = 1;
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	9a 87       	std	Y+10, r25	; 0x0a
     f78:	89 87       	std	Y+9, r24	; 0x09
     f7a:	3f c0       	rjmp	.+126    	; 0xffa <screen_show_initialize+0x9f6>
	else if (__tmp > 65535)
     f7c:	20 e0       	ldi	r18, 0x00	; 0
     f7e:	3f ef       	ldi	r19, 0xFF	; 255
     f80:	4f e7       	ldi	r20, 0x7F	; 127
     f82:	57 e4       	ldi	r21, 0x47	; 71
     f84:	6d 81       	ldd	r22, Y+5	; 0x05
     f86:	7e 81       	ldd	r23, Y+6	; 0x06
     f88:	8f 81       	ldd	r24, Y+7	; 0x07
     f8a:	98 85       	ldd	r25, Y+8	; 0x08
     f8c:	0e 94 ff 33 	call	0x67fe	; 0x67fe <__gesf2>
     f90:	18 16       	cp	r1, r24
     f92:	4c f5       	brge	.+82     	; 0xfe6 <screen_show_initialize+0x9e2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f94:	20 e0       	ldi	r18, 0x00	; 0
     f96:	30 e0       	ldi	r19, 0x00	; 0
     f98:	40 e2       	ldi	r20, 0x20	; 32
     f9a:	51 e4       	ldi	r21, 0x41	; 65
     f9c:	69 81       	ldd	r22, Y+1	; 0x01
     f9e:	7a 81       	ldd	r23, Y+2	; 0x02
     fa0:	8b 81       	ldd	r24, Y+3	; 0x03
     fa2:	9c 81       	ldd	r25, Y+4	; 0x04
     fa4:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
     fa8:	dc 01       	movw	r26, r24
     faa:	cb 01       	movw	r24, r22
     fac:	bc 01       	movw	r22, r24
     fae:	cd 01       	movw	r24, r26
     fb0:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
     fb4:	dc 01       	movw	r26, r24
     fb6:	cb 01       	movw	r24, r22
     fb8:	9a 87       	std	Y+10, r25	; 0x0a
     fba:	89 87       	std	Y+9, r24	; 0x09
     fbc:	0f c0       	rjmp	.+30     	; 0xfdc <screen_show_initialize+0x9d8>
     fbe:	89 e1       	ldi	r24, 0x19	; 25
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	9c 87       	std	Y+12, r25	; 0x0c
     fc4:	8b 87       	std	Y+11, r24	; 0x0b
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     fc6:	8b 85       	ldd	r24, Y+11	; 0x0b
     fc8:	9c 85       	ldd	r25, Y+12	; 0x0c
     fca:	01 97       	sbiw	r24, 0x01	; 1
     fcc:	f1 f7       	brne	.-4      	; 0xfca <screen_show_initialize+0x9c6>
     fce:	9c 87       	std	Y+12, r25	; 0x0c
     fd0:	8b 87       	std	Y+11, r24	; 0x0b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     fd2:	89 85       	ldd	r24, Y+9	; 0x09
     fd4:	9a 85       	ldd	r25, Y+10	; 0x0a
     fd6:	01 97       	sbiw	r24, 0x01	; 1
     fd8:	9a 87       	std	Y+10, r25	; 0x0a
     fda:	89 87       	std	Y+9, r24	; 0x09
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     fdc:	89 85       	ldd	r24, Y+9	; 0x09
     fde:	9a 85       	ldd	r25, Y+10	; 0x0a
     fe0:	00 97       	sbiw	r24, 0x00	; 0
     fe2:	69 f7       	brne	.-38     	; 0xfbe <screen_show_initialize+0x9ba>
     fe4:	14 c0       	rjmp	.+40     	; 0x100e <screen_show_initialize+0xa0a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     fe6:	6d 81       	ldd	r22, Y+5	; 0x05
     fe8:	7e 81       	ldd	r23, Y+6	; 0x06
     fea:	8f 81       	ldd	r24, Y+7	; 0x07
     fec:	98 85       	ldd	r25, Y+8	; 0x08
     fee:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
     ff2:	dc 01       	movw	r26, r24
     ff4:	cb 01       	movw	r24, r22
     ff6:	9a 87       	std	Y+10, r25	; 0x0a
     ff8:	89 87       	std	Y+9, r24	; 0x09
     ffa:	89 85       	ldd	r24, Y+9	; 0x09
     ffc:	9a 85       	ldd	r25, Y+10	; 0x0a
     ffe:	9e 87       	std	Y+14, r25	; 0x0e
    1000:	8d 87       	std	Y+13, r24	; 0x0d
    1002:	8d 85       	ldd	r24, Y+13	; 0x0d
    1004:	9e 85       	ldd	r25, Y+14	; 0x0e
    1006:	01 97       	sbiw	r24, 0x01	; 1
    1008:	f1 f7       	brne	.-4      	; 0x1006 <screen_show_initialize+0xa02>
    100a:	9e 87       	std	Y+14, r25	; 0x0e
    100c:	8d 87       	std	Y+13, r24	; 0x0d

	_delay_ms(500);
	LCD_Clear();
    100e:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_XYPrintf(0, 0, "initialization");
    1012:	8d e4       	ldi	r24, 0x4D	; 77
    1014:	91 e0       	ldi	r25, 0x01	; 1
    1016:	89 2f       	mov	r24, r25
    1018:	8f 93       	push	r24
    101a:	8d e4       	ldi	r24, 0x4D	; 77
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	8f 93       	push	r24
    1020:	1f 92       	push	r1
    1022:	1f 92       	push	r1
    1024:	1f 92       	push	r1
    1026:	1f 92       	push	r1
    1028:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    102c:	0f 90       	pop	r0
    102e:	0f 90       	pop	r0
    1030:	0f 90       	pop	r0
    1032:	0f 90       	pop	r0
    1034:	0f 90       	pop	r0
    1036:	0f 90       	pop	r0
	LCD_XYPrintf(0, 1, "completed");
    1038:	8c e5       	ldi	r24, 0x5C	; 92
    103a:	91 e0       	ldi	r25, 0x01	; 1
    103c:	89 2f       	mov	r24, r25
    103e:	8f 93       	push	r24
    1040:	8c e5       	ldi	r24, 0x5C	; 92
    1042:	91 e0       	ldi	r25, 0x01	; 1
    1044:	8f 93       	push	r24
    1046:	1f 92       	push	r1
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	8f 93       	push	r24
    104c:	1f 92       	push	r1
    104e:	1f 92       	push	r1
    1050:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1054:	0f 90       	pop	r0
    1056:	0f 90       	pop	r0
    1058:	0f 90       	pop	r0
    105a:	0f 90       	pop	r0
    105c:	0f 90       	pop	r0
    105e:	0f 90       	pop	r0
	if (ledStatus) {
    1060:	8f 85       	ldd	r24, Y+15	; 0x0f
    1062:	88 23       	and	r24, r24
    1064:	29 f1       	breq	.+74     	; 0x10b0 <screen_show_initialize+0xaac>
		LedControl_OFF(125);
    1066:	8d e7       	ldi	r24, 0x7D	; 125
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
		LedControl_ON(125);
    106e:	8d e7       	ldi	r24, 0x7D	; 125
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
		LedControl_OFF(125);
    1076:	8d e7       	ldi	r24, 0x7D	; 125
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
		LedControl_ON(125);
    107e:	8d e7       	ldi	r24, 0x7D	; 125
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
		LedControl_OFF(125);
    1086:	8d e7       	ldi	r24, 0x7D	; 125
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
		LedControl_ON(125);
    108e:	8d e7       	ldi	r24, 0x7D	; 125
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
		LedControl_OFF(125);
    1096:	8d e7       	ldi	r24, 0x7D	; 125
    1098:	90 e0       	ldi	r25, 0x00	; 0
    109a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
		LedControl_ON(125);
    109e:	8d e7       	ldi	r24, 0x7D	; 125
    10a0:	90 e0       	ldi	r25, 0x00	; 0
    10a2:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
		LedControl_OFF(200);
    10a6:	88 ec       	ldi	r24, 0xC8	; 200
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
    10ae:	04 c0       	rjmp	.+8      	; 0x10b8 <screen_show_initialize+0xab4>
	} else
		DELAY_ms(1200);
    10b0:	80 eb       	ldi	r24, 0xB0	; 176
    10b2:	94 e0       	ldi	r25, 0x04	; 4
    10b4:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	LCD_Clear();
    10b8:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
}
    10bc:	63 96       	adiw	r28, 0x13	; 19
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	f8 94       	cli
    10c2:	de bf       	out	0x3e, r29	; 62
    10c4:	0f be       	out	0x3f, r0	; 63
    10c6:	cd bf       	out	0x3d, r28	; 61
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	08 95       	ret

000010ce <LCDEXPLOITING_showPage>:

void LCDEXPLOITING_showPage(int page,
		struct LCDEXPLOITING_AllPages *lcdPageLabbles) {
    10ce:	cf 93       	push	r28
    10d0:	df 93       	push	r29
    10d2:	00 d0       	rcall	.+0      	; 0x10d4 <LCDEXPLOITING_showPage+0x6>
    10d4:	00 d0       	rcall	.+0      	; 0x10d6 <LCDEXPLOITING_showPage+0x8>
    10d6:	00 d0       	rcall	.+0      	; 0x10d8 <LCDEXPLOITING_showPage+0xa>
    10d8:	cd b7       	in	r28, 0x3d	; 61
    10da:	de b7       	in	r29, 0x3e	; 62
    10dc:	9c 83       	std	Y+4, r25	; 0x04
    10de:	8b 83       	std	Y+3, r24	; 0x03
    10e0:	7e 83       	std	Y+6, r23	; 0x06
    10e2:	6d 83       	std	Y+5, r22	; 0x05
	LCD_Clear();
    10e4:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	int space;
	if (page == 1) {
    10e8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ea:	9c 81       	ldd	r25, Y+4	; 0x04
    10ec:	81 30       	cpi	r24, 0x01	; 1
    10ee:	91 05       	cpc	r25, r1
    10f0:	09 f0       	breq	.+2      	; 0x10f4 <LCDEXPLOITING_showPage+0x26>
    10f2:	88 c0       	rjmp	.+272    	; 0x1204 <LCDEXPLOITING_showPage+0x136>
		LCD_XYPrintf(0, 0, "%s", lcdPageLabbles->page1.field1);
    10f4:	8d 81       	ldd	r24, Y+5	; 0x05
    10f6:	9e 81       	ldd	r25, Y+6	; 0x06
    10f8:	29 2f       	mov	r18, r25
    10fa:	2f 93       	push	r18
    10fc:	8f 93       	push	r24
    10fe:	86 e6       	ldi	r24, 0x66	; 102
    1100:	91 e0       	ldi	r25, 0x01	; 1
    1102:	89 2f       	mov	r24, r25
    1104:	8f 93       	push	r24
    1106:	86 e6       	ldi	r24, 0x66	; 102
    1108:	91 e0       	ldi	r25, 0x01	; 1
    110a:	8f 93       	push	r24
    110c:	1f 92       	push	r1
    110e:	1f 92       	push	r1
    1110:	1f 92       	push	r1
    1112:	1f 92       	push	r1
    1114:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1118:	8d b7       	in	r24, 0x3d	; 61
    111a:	9e b7       	in	r25, 0x3e	; 62
    111c:	08 96       	adiw	r24, 0x08	; 8
    111e:	0f b6       	in	r0, 0x3f	; 63
    1120:	f8 94       	cli
    1122:	de bf       	out	0x3e, r29	; 62
    1124:	0f be       	out	0x3f, r0	; 63
    1126:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page1.field2);
    1128:	8d 81       	ldd	r24, Y+5	; 0x05
    112a:	9e 81       	ldd	r25, Y+6	; 0x06
    112c:	09 96       	adiw	r24, 0x09	; 9
    112e:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    1132:	9a 83       	std	Y+2, r25	; 0x02
    1134:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 0, "%s", lcdPageLabbles->page1.field2);
    1136:	8d 81       	ldd	r24, Y+5	; 0x05
    1138:	9e 81       	ldd	r25, Y+6	; 0x06
    113a:	9c 01       	movw	r18, r24
    113c:	27 5f       	subi	r18, 0xF7	; 247
    113e:	3f 4f       	sbci	r19, 0xFF	; 255
    1140:	89 81       	ldd	r24, Y+1	; 0x01
    1142:	9a 81       	ldd	r25, Y+2	; 0x02
    1144:	09 96       	adiw	r24, 0x09	; 9
    1146:	43 2f       	mov	r20, r19
    1148:	4f 93       	push	r20
    114a:	2f 93       	push	r18
    114c:	26 e6       	ldi	r18, 0x66	; 102
    114e:	31 e0       	ldi	r19, 0x01	; 1
    1150:	23 2f       	mov	r18, r19
    1152:	2f 93       	push	r18
    1154:	26 e6       	ldi	r18, 0x66	; 102
    1156:	31 e0       	ldi	r19, 0x01	; 1
    1158:	2f 93       	push	r18
    115a:	1f 92       	push	r1
    115c:	1f 92       	push	r1
    115e:	29 2f       	mov	r18, r25
    1160:	2f 93       	push	r18
    1162:	8f 93       	push	r24
    1164:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1168:	8d b7       	in	r24, 0x3d	; 61
    116a:	9e b7       	in	r25, 0x3e	; 62
    116c:	08 96       	adiw	r24, 0x08	; 8
    116e:	0f b6       	in	r0, 0x3f	; 63
    1170:	f8 94       	cli
    1172:	de bf       	out	0x3e, r29	; 62
    1174:	0f be       	out	0x3f, r0	; 63
    1176:	cd bf       	out	0x3d, r28	; 61
		LCD_XYPrintf(0, 1, "%s", lcdPageLabbles->page1.field3);
    1178:	8d 81       	ldd	r24, Y+5	; 0x05
    117a:	9e 81       	ldd	r25, Y+6	; 0x06
    117c:	42 96       	adiw	r24, 0x12	; 18
    117e:	29 2f       	mov	r18, r25
    1180:	2f 93       	push	r18
    1182:	8f 93       	push	r24
    1184:	86 e6       	ldi	r24, 0x66	; 102
    1186:	91 e0       	ldi	r25, 0x01	; 1
    1188:	89 2f       	mov	r24, r25
    118a:	8f 93       	push	r24
    118c:	86 e6       	ldi	r24, 0x66	; 102
    118e:	91 e0       	ldi	r25, 0x01	; 1
    1190:	8f 93       	push	r24
    1192:	1f 92       	push	r1
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	8f 93       	push	r24
    1198:	1f 92       	push	r1
    119a:	1f 92       	push	r1
    119c:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    11a0:	8d b7       	in	r24, 0x3d	; 61
    11a2:	9e b7       	in	r25, 0x3e	; 62
    11a4:	08 96       	adiw	r24, 0x08	; 8
    11a6:	0f b6       	in	r0, 0x3f	; 63
    11a8:	f8 94       	cli
    11aa:	de bf       	out	0x3e, r29	; 62
    11ac:	0f be       	out	0x3f, r0	; 63
    11ae:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page1.field4);
    11b0:	8d 81       	ldd	r24, Y+5	; 0x05
    11b2:	9e 81       	ldd	r25, Y+6	; 0x06
    11b4:	4b 96       	adiw	r24, 0x1b	; 27
    11b6:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    11ba:	9a 83       	std	Y+2, r25	; 0x02
    11bc:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 1, "%s", lcdPageLabbles->page1.field4);
    11be:	8d 81       	ldd	r24, Y+5	; 0x05
    11c0:	9e 81       	ldd	r25, Y+6	; 0x06
    11c2:	9c 01       	movw	r18, r24
    11c4:	25 5e       	subi	r18, 0xE5	; 229
    11c6:	3f 4f       	sbci	r19, 0xFF	; 255
    11c8:	89 81       	ldd	r24, Y+1	; 0x01
    11ca:	9a 81       	ldd	r25, Y+2	; 0x02
    11cc:	09 96       	adiw	r24, 0x09	; 9
    11ce:	43 2f       	mov	r20, r19
    11d0:	4f 93       	push	r20
    11d2:	2f 93       	push	r18
    11d4:	26 e6       	ldi	r18, 0x66	; 102
    11d6:	31 e0       	ldi	r19, 0x01	; 1
    11d8:	23 2f       	mov	r18, r19
    11da:	2f 93       	push	r18
    11dc:	26 e6       	ldi	r18, 0x66	; 102
    11de:	31 e0       	ldi	r19, 0x01	; 1
    11e0:	2f 93       	push	r18
    11e2:	1f 92       	push	r1
    11e4:	21 e0       	ldi	r18, 0x01	; 1
    11e6:	2f 93       	push	r18
    11e8:	29 2f       	mov	r18, r25
    11ea:	2f 93       	push	r18
    11ec:	8f 93       	push	r24
    11ee:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    11f2:	8d b7       	in	r24, 0x3d	; 61
    11f4:	9e b7       	in	r25, 0x3e	; 62
    11f6:	08 96       	adiw	r24, 0x08	; 8
    11f8:	0f b6       	in	r0, 0x3f	; 63
    11fa:	f8 94       	cli
    11fc:	de bf       	out	0x3e, r29	; 62
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	cd bf       	out	0x3d, r28	; 61
    1202:	b4 c1       	rjmp	.+872    	; 0x156c <LCDEXPLOITING_showPage+0x49e>
	} else if (page == 2) {
    1204:	8b 81       	ldd	r24, Y+3	; 0x03
    1206:	9c 81       	ldd	r25, Y+4	; 0x04
    1208:	82 30       	cpi	r24, 0x02	; 2
    120a:	91 05       	cpc	r25, r1
    120c:	09 f0       	breq	.+2      	; 0x1210 <LCDEXPLOITING_showPage+0x142>
    120e:	89 c0       	rjmp	.+274    	; 0x1322 <LCDEXPLOITING_showPage+0x254>
		LCD_XYPrintf(0, 0, "%s", lcdPageLabbles->page2.field1);
    1210:	8d 81       	ldd	r24, Y+5	; 0x05
    1212:	9e 81       	ldd	r25, Y+6	; 0x06
    1214:	84 96       	adiw	r24, 0x24	; 36
    1216:	29 2f       	mov	r18, r25
    1218:	2f 93       	push	r18
    121a:	8f 93       	push	r24
    121c:	86 e6       	ldi	r24, 0x66	; 102
    121e:	91 e0       	ldi	r25, 0x01	; 1
    1220:	89 2f       	mov	r24, r25
    1222:	8f 93       	push	r24
    1224:	86 e6       	ldi	r24, 0x66	; 102
    1226:	91 e0       	ldi	r25, 0x01	; 1
    1228:	8f 93       	push	r24
    122a:	1f 92       	push	r1
    122c:	1f 92       	push	r1
    122e:	1f 92       	push	r1
    1230:	1f 92       	push	r1
    1232:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1236:	8d b7       	in	r24, 0x3d	; 61
    1238:	9e b7       	in	r25, 0x3e	; 62
    123a:	08 96       	adiw	r24, 0x08	; 8
    123c:	0f b6       	in	r0, 0x3f	; 63
    123e:	f8 94       	cli
    1240:	de bf       	out	0x3e, r29	; 62
    1242:	0f be       	out	0x3f, r0	; 63
    1244:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page2.field2);
    1246:	8d 81       	ldd	r24, Y+5	; 0x05
    1248:	9e 81       	ldd	r25, Y+6	; 0x06
    124a:	8d 96       	adiw	r24, 0x2d	; 45
    124c:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    1250:	9a 83       	std	Y+2, r25	; 0x02
    1252:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 0, "%s", lcdPageLabbles->page2.field2);
    1254:	8d 81       	ldd	r24, Y+5	; 0x05
    1256:	9e 81       	ldd	r25, Y+6	; 0x06
    1258:	9c 01       	movw	r18, r24
    125a:	23 5d       	subi	r18, 0xD3	; 211
    125c:	3f 4f       	sbci	r19, 0xFF	; 255
    125e:	89 81       	ldd	r24, Y+1	; 0x01
    1260:	9a 81       	ldd	r25, Y+2	; 0x02
    1262:	09 96       	adiw	r24, 0x09	; 9
    1264:	43 2f       	mov	r20, r19
    1266:	4f 93       	push	r20
    1268:	2f 93       	push	r18
    126a:	26 e6       	ldi	r18, 0x66	; 102
    126c:	31 e0       	ldi	r19, 0x01	; 1
    126e:	23 2f       	mov	r18, r19
    1270:	2f 93       	push	r18
    1272:	26 e6       	ldi	r18, 0x66	; 102
    1274:	31 e0       	ldi	r19, 0x01	; 1
    1276:	2f 93       	push	r18
    1278:	1f 92       	push	r1
    127a:	1f 92       	push	r1
    127c:	29 2f       	mov	r18, r25
    127e:	2f 93       	push	r18
    1280:	8f 93       	push	r24
    1282:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1286:	8d b7       	in	r24, 0x3d	; 61
    1288:	9e b7       	in	r25, 0x3e	; 62
    128a:	08 96       	adiw	r24, 0x08	; 8
    128c:	0f b6       	in	r0, 0x3f	; 63
    128e:	f8 94       	cli
    1290:	de bf       	out	0x3e, r29	; 62
    1292:	0f be       	out	0x3f, r0	; 63
    1294:	cd bf       	out	0x3d, r28	; 61
		LCD_XYPrintf(0, 1, "%s", lcdPageLabbles->page2.field3);
    1296:	8d 81       	ldd	r24, Y+5	; 0x05
    1298:	9e 81       	ldd	r25, Y+6	; 0x06
    129a:	c6 96       	adiw	r24, 0x36	; 54
    129c:	29 2f       	mov	r18, r25
    129e:	2f 93       	push	r18
    12a0:	8f 93       	push	r24
    12a2:	86 e6       	ldi	r24, 0x66	; 102
    12a4:	91 e0       	ldi	r25, 0x01	; 1
    12a6:	89 2f       	mov	r24, r25
    12a8:	8f 93       	push	r24
    12aa:	86 e6       	ldi	r24, 0x66	; 102
    12ac:	91 e0       	ldi	r25, 0x01	; 1
    12ae:	8f 93       	push	r24
    12b0:	1f 92       	push	r1
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	8f 93       	push	r24
    12b6:	1f 92       	push	r1
    12b8:	1f 92       	push	r1
    12ba:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    12be:	8d b7       	in	r24, 0x3d	; 61
    12c0:	9e b7       	in	r25, 0x3e	; 62
    12c2:	08 96       	adiw	r24, 0x08	; 8
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	f8 94       	cli
    12c8:	de bf       	out	0x3e, r29	; 62
    12ca:	0f be       	out	0x3f, r0	; 63
    12cc:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page2.field4);
    12ce:	8d 81       	ldd	r24, Y+5	; 0x05
    12d0:	9e 81       	ldd	r25, Y+6	; 0x06
    12d2:	cf 96       	adiw	r24, 0x3f	; 63
    12d4:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    12d8:	9a 83       	std	Y+2, r25	; 0x02
    12da:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 1, "%s", lcdPageLabbles->page2.field4);
    12dc:	8d 81       	ldd	r24, Y+5	; 0x05
    12de:	9e 81       	ldd	r25, Y+6	; 0x06
    12e0:	9c 01       	movw	r18, r24
    12e2:	21 5c       	subi	r18, 0xC1	; 193
    12e4:	3f 4f       	sbci	r19, 0xFF	; 255
    12e6:	89 81       	ldd	r24, Y+1	; 0x01
    12e8:	9a 81       	ldd	r25, Y+2	; 0x02
    12ea:	09 96       	adiw	r24, 0x09	; 9
    12ec:	43 2f       	mov	r20, r19
    12ee:	4f 93       	push	r20
    12f0:	2f 93       	push	r18
    12f2:	26 e6       	ldi	r18, 0x66	; 102
    12f4:	31 e0       	ldi	r19, 0x01	; 1
    12f6:	23 2f       	mov	r18, r19
    12f8:	2f 93       	push	r18
    12fa:	26 e6       	ldi	r18, 0x66	; 102
    12fc:	31 e0       	ldi	r19, 0x01	; 1
    12fe:	2f 93       	push	r18
    1300:	1f 92       	push	r1
    1302:	21 e0       	ldi	r18, 0x01	; 1
    1304:	2f 93       	push	r18
    1306:	29 2f       	mov	r18, r25
    1308:	2f 93       	push	r18
    130a:	8f 93       	push	r24
    130c:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1310:	8d b7       	in	r24, 0x3d	; 61
    1312:	9e b7       	in	r25, 0x3e	; 62
    1314:	08 96       	adiw	r24, 0x08	; 8
    1316:	0f b6       	in	r0, 0x3f	; 63
    1318:	f8 94       	cli
    131a:	de bf       	out	0x3e, r29	; 62
    131c:	0f be       	out	0x3f, r0	; 63
    131e:	cd bf       	out	0x3d, r28	; 61
    1320:	25 c1       	rjmp	.+586    	; 0x156c <LCDEXPLOITING_showPage+0x49e>
	} else if (page == 3) {
    1322:	8b 81       	ldd	r24, Y+3	; 0x03
    1324:	9c 81       	ldd	r25, Y+4	; 0x04
    1326:	83 30       	cpi	r24, 0x03	; 3
    1328:	91 05       	cpc	r25, r1
    132a:	09 f0       	breq	.+2      	; 0x132e <LCDEXPLOITING_showPage+0x260>
    132c:	8d c0       	rjmp	.+282    	; 0x1448 <LCDEXPLOITING_showPage+0x37a>
		LCD_XYPrintf(0, 0, "%s", lcdPageLabbles->page3.field1);
    132e:	8d 81       	ldd	r24, Y+5	; 0x05
    1330:	9e 81       	ldd	r25, Y+6	; 0x06
    1332:	88 5b       	subi	r24, 0xB8	; 184
    1334:	9f 4f       	sbci	r25, 0xFF	; 255
    1336:	29 2f       	mov	r18, r25
    1338:	2f 93       	push	r18
    133a:	8f 93       	push	r24
    133c:	86 e6       	ldi	r24, 0x66	; 102
    133e:	91 e0       	ldi	r25, 0x01	; 1
    1340:	89 2f       	mov	r24, r25
    1342:	8f 93       	push	r24
    1344:	86 e6       	ldi	r24, 0x66	; 102
    1346:	91 e0       	ldi	r25, 0x01	; 1
    1348:	8f 93       	push	r24
    134a:	1f 92       	push	r1
    134c:	1f 92       	push	r1
    134e:	1f 92       	push	r1
    1350:	1f 92       	push	r1
    1352:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1356:	8d b7       	in	r24, 0x3d	; 61
    1358:	9e b7       	in	r25, 0x3e	; 62
    135a:	08 96       	adiw	r24, 0x08	; 8
    135c:	0f b6       	in	r0, 0x3f	; 63
    135e:	f8 94       	cli
    1360:	de bf       	out	0x3e, r29	; 62
    1362:	0f be       	out	0x3f, r0	; 63
    1364:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page3.field2);
    1366:	8d 81       	ldd	r24, Y+5	; 0x05
    1368:	9e 81       	ldd	r25, Y+6	; 0x06
    136a:	8f 5a       	subi	r24, 0xAF	; 175
    136c:	9f 4f       	sbci	r25, 0xFF	; 255
    136e:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    1372:	9a 83       	std	Y+2, r25	; 0x02
    1374:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 0, "%s", lcdPageLabbles->page3.field2);
    1376:	8d 81       	ldd	r24, Y+5	; 0x05
    1378:	9e 81       	ldd	r25, Y+6	; 0x06
    137a:	9c 01       	movw	r18, r24
    137c:	2f 5a       	subi	r18, 0xAF	; 175
    137e:	3f 4f       	sbci	r19, 0xFF	; 255
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	9a 81       	ldd	r25, Y+2	; 0x02
    1384:	09 96       	adiw	r24, 0x09	; 9
    1386:	43 2f       	mov	r20, r19
    1388:	4f 93       	push	r20
    138a:	2f 93       	push	r18
    138c:	26 e6       	ldi	r18, 0x66	; 102
    138e:	31 e0       	ldi	r19, 0x01	; 1
    1390:	23 2f       	mov	r18, r19
    1392:	2f 93       	push	r18
    1394:	26 e6       	ldi	r18, 0x66	; 102
    1396:	31 e0       	ldi	r19, 0x01	; 1
    1398:	2f 93       	push	r18
    139a:	1f 92       	push	r1
    139c:	1f 92       	push	r1
    139e:	29 2f       	mov	r18, r25
    13a0:	2f 93       	push	r18
    13a2:	8f 93       	push	r24
    13a4:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    13a8:	8d b7       	in	r24, 0x3d	; 61
    13aa:	9e b7       	in	r25, 0x3e	; 62
    13ac:	08 96       	adiw	r24, 0x08	; 8
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	f8 94       	cli
    13b2:	de bf       	out	0x3e, r29	; 62
    13b4:	0f be       	out	0x3f, r0	; 63
    13b6:	cd bf       	out	0x3d, r28	; 61
		LCD_XYPrintf(0, 1, "%s", lcdPageLabbles->page3.field3);
    13b8:	8d 81       	ldd	r24, Y+5	; 0x05
    13ba:	9e 81       	ldd	r25, Y+6	; 0x06
    13bc:	86 5a       	subi	r24, 0xA6	; 166
    13be:	9f 4f       	sbci	r25, 0xFF	; 255
    13c0:	29 2f       	mov	r18, r25
    13c2:	2f 93       	push	r18
    13c4:	8f 93       	push	r24
    13c6:	86 e6       	ldi	r24, 0x66	; 102
    13c8:	91 e0       	ldi	r25, 0x01	; 1
    13ca:	89 2f       	mov	r24, r25
    13cc:	8f 93       	push	r24
    13ce:	86 e6       	ldi	r24, 0x66	; 102
    13d0:	91 e0       	ldi	r25, 0x01	; 1
    13d2:	8f 93       	push	r24
    13d4:	1f 92       	push	r1
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	8f 93       	push	r24
    13da:	1f 92       	push	r1
    13dc:	1f 92       	push	r1
    13de:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    13e2:	8d b7       	in	r24, 0x3d	; 61
    13e4:	9e b7       	in	r25, 0x3e	; 62
    13e6:	08 96       	adiw	r24, 0x08	; 8
    13e8:	0f b6       	in	r0, 0x3f	; 63
    13ea:	f8 94       	cli
    13ec:	de bf       	out	0x3e, r29	; 62
    13ee:	0f be       	out	0x3f, r0	; 63
    13f0:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page3.field4);
    13f2:	8d 81       	ldd	r24, Y+5	; 0x05
    13f4:	9e 81       	ldd	r25, Y+6	; 0x06
    13f6:	8d 59       	subi	r24, 0x9D	; 157
    13f8:	9f 4f       	sbci	r25, 0xFF	; 255
    13fa:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    13fe:	9a 83       	std	Y+2, r25	; 0x02
    1400:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 1, "%s", lcdPageLabbles->page3.field4);
    1402:	8d 81       	ldd	r24, Y+5	; 0x05
    1404:	9e 81       	ldd	r25, Y+6	; 0x06
    1406:	9c 01       	movw	r18, r24
    1408:	2d 59       	subi	r18, 0x9D	; 157
    140a:	3f 4f       	sbci	r19, 0xFF	; 255
    140c:	89 81       	ldd	r24, Y+1	; 0x01
    140e:	9a 81       	ldd	r25, Y+2	; 0x02
    1410:	09 96       	adiw	r24, 0x09	; 9
    1412:	43 2f       	mov	r20, r19
    1414:	4f 93       	push	r20
    1416:	2f 93       	push	r18
    1418:	26 e6       	ldi	r18, 0x66	; 102
    141a:	31 e0       	ldi	r19, 0x01	; 1
    141c:	23 2f       	mov	r18, r19
    141e:	2f 93       	push	r18
    1420:	26 e6       	ldi	r18, 0x66	; 102
    1422:	31 e0       	ldi	r19, 0x01	; 1
    1424:	2f 93       	push	r18
    1426:	1f 92       	push	r1
    1428:	21 e0       	ldi	r18, 0x01	; 1
    142a:	2f 93       	push	r18
    142c:	29 2f       	mov	r18, r25
    142e:	2f 93       	push	r18
    1430:	8f 93       	push	r24
    1432:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1436:	8d b7       	in	r24, 0x3d	; 61
    1438:	9e b7       	in	r25, 0x3e	; 62
    143a:	08 96       	adiw	r24, 0x08	; 8
    143c:	0f b6       	in	r0, 0x3f	; 63
    143e:	f8 94       	cli
    1440:	de bf       	out	0x3e, r29	; 62
    1442:	0f be       	out	0x3f, r0	; 63
    1444:	cd bf       	out	0x3d, r28	; 61
    1446:	92 c0       	rjmp	.+292    	; 0x156c <LCDEXPLOITING_showPage+0x49e>
	} else if (page == 4) {
    1448:	8b 81       	ldd	r24, Y+3	; 0x03
    144a:	9c 81       	ldd	r25, Y+4	; 0x04
    144c:	84 30       	cpi	r24, 0x04	; 4
    144e:	91 05       	cpc	r25, r1
    1450:	09 f0       	breq	.+2      	; 0x1454 <LCDEXPLOITING_showPage+0x386>
    1452:	8c c0       	rjmp	.+280    	; 0x156c <LCDEXPLOITING_showPage+0x49e>
		LCD_XYPrintf(0, 0, "%s", lcdPageLabbles->page4.field1);
    1454:	8d 81       	ldd	r24, Y+5	; 0x05
    1456:	9e 81       	ldd	r25, Y+6	; 0x06
    1458:	84 59       	subi	r24, 0x94	; 148
    145a:	9f 4f       	sbci	r25, 0xFF	; 255
    145c:	29 2f       	mov	r18, r25
    145e:	2f 93       	push	r18
    1460:	8f 93       	push	r24
    1462:	86 e6       	ldi	r24, 0x66	; 102
    1464:	91 e0       	ldi	r25, 0x01	; 1
    1466:	89 2f       	mov	r24, r25
    1468:	8f 93       	push	r24
    146a:	86 e6       	ldi	r24, 0x66	; 102
    146c:	91 e0       	ldi	r25, 0x01	; 1
    146e:	8f 93       	push	r24
    1470:	1f 92       	push	r1
    1472:	1f 92       	push	r1
    1474:	1f 92       	push	r1
    1476:	1f 92       	push	r1
    1478:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    147c:	8d b7       	in	r24, 0x3d	; 61
    147e:	9e b7       	in	r25, 0x3e	; 62
    1480:	08 96       	adiw	r24, 0x08	; 8
    1482:	0f b6       	in	r0, 0x3f	; 63
    1484:	f8 94       	cli
    1486:	de bf       	out	0x3e, r29	; 62
    1488:	0f be       	out	0x3f, r0	; 63
    148a:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page4.field2);
    148c:	8d 81       	ldd	r24, Y+5	; 0x05
    148e:	9e 81       	ldd	r25, Y+6	; 0x06
    1490:	8b 58       	subi	r24, 0x8B	; 139
    1492:	9f 4f       	sbci	r25, 0xFF	; 255
    1494:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    1498:	9a 83       	std	Y+2, r25	; 0x02
    149a:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 0, "%s", lcdPageLabbles->page4.field2);
    149c:	8d 81       	ldd	r24, Y+5	; 0x05
    149e:	9e 81       	ldd	r25, Y+6	; 0x06
    14a0:	9c 01       	movw	r18, r24
    14a2:	2b 58       	subi	r18, 0x8B	; 139
    14a4:	3f 4f       	sbci	r19, 0xFF	; 255
    14a6:	89 81       	ldd	r24, Y+1	; 0x01
    14a8:	9a 81       	ldd	r25, Y+2	; 0x02
    14aa:	09 96       	adiw	r24, 0x09	; 9
    14ac:	43 2f       	mov	r20, r19
    14ae:	4f 93       	push	r20
    14b0:	2f 93       	push	r18
    14b2:	26 e6       	ldi	r18, 0x66	; 102
    14b4:	31 e0       	ldi	r19, 0x01	; 1
    14b6:	23 2f       	mov	r18, r19
    14b8:	2f 93       	push	r18
    14ba:	26 e6       	ldi	r18, 0x66	; 102
    14bc:	31 e0       	ldi	r19, 0x01	; 1
    14be:	2f 93       	push	r18
    14c0:	1f 92       	push	r1
    14c2:	1f 92       	push	r1
    14c4:	29 2f       	mov	r18, r25
    14c6:	2f 93       	push	r18
    14c8:	8f 93       	push	r24
    14ca:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    14ce:	8d b7       	in	r24, 0x3d	; 61
    14d0:	9e b7       	in	r25, 0x3e	; 62
    14d2:	08 96       	adiw	r24, 0x08	; 8
    14d4:	0f b6       	in	r0, 0x3f	; 63
    14d6:	f8 94       	cli
    14d8:	de bf       	out	0x3e, r29	; 62
    14da:	0f be       	out	0x3f, r0	; 63
    14dc:	cd bf       	out	0x3d, r28	; 61
		LCD_XYPrintf(0, 1, "%s", lcdPageLabbles->page4.field3);
    14de:	8d 81       	ldd	r24, Y+5	; 0x05
    14e0:	9e 81       	ldd	r25, Y+6	; 0x06
    14e2:	82 58       	subi	r24, 0x82	; 130
    14e4:	9f 4f       	sbci	r25, 0xFF	; 255
    14e6:	29 2f       	mov	r18, r25
    14e8:	2f 93       	push	r18
    14ea:	8f 93       	push	r24
    14ec:	86 e6       	ldi	r24, 0x66	; 102
    14ee:	91 e0       	ldi	r25, 0x01	; 1
    14f0:	89 2f       	mov	r24, r25
    14f2:	8f 93       	push	r24
    14f4:	86 e6       	ldi	r24, 0x66	; 102
    14f6:	91 e0       	ldi	r25, 0x01	; 1
    14f8:	8f 93       	push	r24
    14fa:	1f 92       	push	r1
    14fc:	81 e0       	ldi	r24, 0x01	; 1
    14fe:	8f 93       	push	r24
    1500:	1f 92       	push	r1
    1502:	1f 92       	push	r1
    1504:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1508:	8d b7       	in	r24, 0x3d	; 61
    150a:	9e b7       	in	r25, 0x3e	; 62
    150c:	08 96       	adiw	r24, 0x08	; 8
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	de bf       	out	0x3e, r29	; 62
    1514:	0f be       	out	0x3f, r0	; 63
    1516:	cd bf       	out	0x3d, r28	; 61
		space = LCDEXPLOITING_howLong(lcdPageLabbles->page4.field4);
    1518:	8d 81       	ldd	r24, Y+5	; 0x05
    151a:	9e 81       	ldd	r25, Y+6	; 0x06
    151c:	89 57       	subi	r24, 0x79	; 121
    151e:	9f 4f       	sbci	r25, 0xFF	; 255
    1520:	0e 94 bf 0a 	call	0x157e	; 0x157e <LCDEXPLOITING_howLong>
    1524:	9a 83       	std	Y+2, r25	; 0x02
    1526:	89 83       	std	Y+1, r24	; 0x01
		LCD_XYPrintf((9 + space), 1, "%s", lcdPageLabbles->page4.field4);
    1528:	8d 81       	ldd	r24, Y+5	; 0x05
    152a:	9e 81       	ldd	r25, Y+6	; 0x06
    152c:	9c 01       	movw	r18, r24
    152e:	29 57       	subi	r18, 0x79	; 121
    1530:	3f 4f       	sbci	r19, 0xFF	; 255
    1532:	89 81       	ldd	r24, Y+1	; 0x01
    1534:	9a 81       	ldd	r25, Y+2	; 0x02
    1536:	09 96       	adiw	r24, 0x09	; 9
    1538:	43 2f       	mov	r20, r19
    153a:	4f 93       	push	r20
    153c:	2f 93       	push	r18
    153e:	26 e6       	ldi	r18, 0x66	; 102
    1540:	31 e0       	ldi	r19, 0x01	; 1
    1542:	23 2f       	mov	r18, r19
    1544:	2f 93       	push	r18
    1546:	26 e6       	ldi	r18, 0x66	; 102
    1548:	31 e0       	ldi	r19, 0x01	; 1
    154a:	2f 93       	push	r18
    154c:	1f 92       	push	r1
    154e:	21 e0       	ldi	r18, 0x01	; 1
    1550:	2f 93       	push	r18
    1552:	29 2f       	mov	r18, r25
    1554:	2f 93       	push	r18
    1556:	8f 93       	push	r24
    1558:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    155c:	8d b7       	in	r24, 0x3d	; 61
    155e:	9e b7       	in	r25, 0x3e	; 62
    1560:	08 96       	adiw	r24, 0x08	; 8
    1562:	0f b6       	in	r0, 0x3f	; 63
    1564:	f8 94       	cli
    1566:	de bf       	out	0x3e, r29	; 62
    1568:	0f be       	out	0x3f, r0	; 63
    156a:	cd bf       	out	0x3d, r28	; 61
	}

}
    156c:	26 96       	adiw	r28, 0x06	; 6
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	de bf       	out	0x3e, r29	; 62
    1574:	0f be       	out	0x3f, r0	; 63
    1576:	cd bf       	out	0x3d, r28	; 61
    1578:	df 91       	pop	r29
    157a:	cf 91       	pop	r28
    157c:	08 95       	ret

0000157e <LCDEXPLOITING_howLong>:
int LCDEXPLOITING_howLong(char *chars) {
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	cd b7       	in	r28, 0x3d	; 61
    1584:	de b7       	in	r29, 0x3e	; 62
    1586:	28 97       	sbiw	r28, 0x08	; 8
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	de bf       	out	0x3e, r29	; 62
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	cd bf       	out	0x3d, r28	; 61
    1592:	98 87       	std	Y+8, r25	; 0x08
    1594:	8f 83       	std	Y+7, r24	; 0x07
	int size = 0;
    1596:	1a 82       	std	Y+2, r1	; 0x02
    1598:	19 82       	std	Y+1, r1	; 0x01
	int specialSymbols=0;
    159a:	1c 82       	std	Y+4, r1	; 0x04
    159c:	1b 82       	std	Y+3, r1	; 0x03

	for(int clk=0; chars[clk] != '\0'; clk++){
    159e:	1e 82       	std	Y+6, r1	; 0x06
    15a0:	1d 82       	std	Y+5, r1	; 0x05
    15a2:	19 c0       	rjmp	.+50     	; 0x15d6 <LCDEXPLOITING_howLong+0x58>
		size++;
    15a4:	89 81       	ldd	r24, Y+1	; 0x01
    15a6:	9a 81       	ldd	r25, Y+2	; 0x02
    15a8:	01 96       	adiw	r24, 0x01	; 1
    15aa:	9a 83       	std	Y+2, r25	; 0x02
    15ac:	89 83       	std	Y+1, r24	; 0x01
		if(chars[clk] == '%') specialSymbols++;
    15ae:	8d 81       	ldd	r24, Y+5	; 0x05
    15b0:	9e 81       	ldd	r25, Y+6	; 0x06
    15b2:	2f 81       	ldd	r18, Y+7	; 0x07
    15b4:	38 85       	ldd	r19, Y+8	; 0x08
    15b6:	82 0f       	add	r24, r18
    15b8:	93 1f       	adc	r25, r19
    15ba:	fc 01       	movw	r30, r24
    15bc:	80 81       	ld	r24, Z
    15be:	85 32       	cpi	r24, 0x25	; 37
    15c0:	29 f4       	brne	.+10     	; 0x15cc <LCDEXPLOITING_howLong+0x4e>
    15c2:	8b 81       	ldd	r24, Y+3	; 0x03
    15c4:	9c 81       	ldd	r25, Y+4	; 0x04
    15c6:	01 96       	adiw	r24, 0x01	; 1
    15c8:	9c 83       	std	Y+4, r25	; 0x04
    15ca:	8b 83       	std	Y+3, r24	; 0x03
}
int LCDEXPLOITING_howLong(char *chars) {
	int size = 0;
	int specialSymbols=0;

	for(int clk=0; chars[clk] != '\0'; clk++){
    15cc:	8d 81       	ldd	r24, Y+5	; 0x05
    15ce:	9e 81       	ldd	r25, Y+6	; 0x06
    15d0:	01 96       	adiw	r24, 0x01	; 1
    15d2:	9e 83       	std	Y+6, r25	; 0x06
    15d4:	8d 83       	std	Y+5, r24	; 0x05
    15d6:	8d 81       	ldd	r24, Y+5	; 0x05
    15d8:	9e 81       	ldd	r25, Y+6	; 0x06
    15da:	2f 81       	ldd	r18, Y+7	; 0x07
    15dc:	38 85       	ldd	r19, Y+8	; 0x08
    15de:	82 0f       	add	r24, r18
    15e0:	93 1f       	adc	r25, r19
    15e2:	fc 01       	movw	r30, r24
    15e4:	80 81       	ld	r24, Z
    15e6:	88 23       	and	r24, r24
    15e8:	e9 f6       	brne	.-70     	; 0x15a4 <LCDEXPLOITING_howLong+0x26>
		size++;
		if(chars[clk] == '%') specialSymbols++;
	}
	return ((7 - size)+specialSymbols);
    15ea:	27 e0       	ldi	r18, 0x07	; 7
    15ec:	30 e0       	ldi	r19, 0x00	; 0
    15ee:	89 81       	ldd	r24, Y+1	; 0x01
    15f0:	9a 81       	ldd	r25, Y+2	; 0x02
    15f2:	28 1b       	sub	r18, r24
    15f4:	39 0b       	sbc	r19, r25
    15f6:	8b 81       	ldd	r24, Y+3	; 0x03
    15f8:	9c 81       	ldd	r25, Y+4	; 0x04
    15fa:	82 0f       	add	r24, r18
    15fc:	93 1f       	adc	r25, r19
}
    15fe:	28 96       	adiw	r28, 0x08	; 8
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	f8 94       	cli
    1604:	de bf       	out	0x3e, r29	; 62
    1606:	0f be       	out	0x3f, r0	; 63
    1608:	cd bf       	out	0x3d, r28	; 61
    160a:	df 91       	pop	r29
    160c:	cf 91       	pop	r28
    160e:	08 95       	ret

00001610 <LCDEXPLOITING_DrawLoading>:

void LCDEXPLOITING_DrawLoading(int length) {
    1610:	cf 93       	push	r28
    1612:	df 93       	push	r29
    1614:	00 d0       	rcall	.+0      	; 0x1616 <LCDEXPLOITING_DrawLoading+0x6>
    1616:	00 d0       	rcall	.+0      	; 0x1618 <LCDEXPLOITING_DrawLoading+0x8>
    1618:	cd b7       	in	r28, 0x3d	; 61
    161a:	de b7       	in	r29, 0x3e	; 62
    161c:	9c 83       	std	Y+4, r25	; 0x04
    161e:	8b 83       	std	Y+3, r24	; 0x03
	for (int clk = 0; clk < length; clk++){
    1620:	1a 82       	std	Y+2, r1	; 0x02
    1622:	19 82       	std	Y+1, r1	; 0x01
    1624:	1b c0       	rjmp	.+54     	; 0x165c <LCDEXPLOITING_DrawLoading+0x4c>
		LCD_XYPrintf(clk, 1, "%?");
    1626:	89 e6       	ldi	r24, 0x69	; 105
    1628:	91 e0       	ldi	r25, 0x01	; 1
    162a:	89 2f       	mov	r24, r25
    162c:	8f 93       	push	r24
    162e:	89 e6       	ldi	r24, 0x69	; 105
    1630:	91 e0       	ldi	r25, 0x01	; 1
    1632:	8f 93       	push	r24
    1634:	1f 92       	push	r1
    1636:	81 e0       	ldi	r24, 0x01	; 1
    1638:	8f 93       	push	r24
    163a:	8a 81       	ldd	r24, Y+2	; 0x02
    163c:	8f 93       	push	r24
    163e:	89 81       	ldd	r24, Y+1	; 0x01
    1640:	8f 93       	push	r24
    1642:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1646:	0f 90       	pop	r0
    1648:	0f 90       	pop	r0
    164a:	0f 90       	pop	r0
    164c:	0f 90       	pop	r0
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
	}
	return ((7 - size)+specialSymbols);
}

void LCDEXPLOITING_DrawLoading(int length) {
	for (int clk = 0; clk < length; clk++){
    1652:	89 81       	ldd	r24, Y+1	; 0x01
    1654:	9a 81       	ldd	r25, Y+2	; 0x02
    1656:	01 96       	adiw	r24, 0x01	; 1
    1658:	9a 83       	std	Y+2, r25	; 0x02
    165a:	89 83       	std	Y+1, r24	; 0x01
    165c:	29 81       	ldd	r18, Y+1	; 0x01
    165e:	3a 81       	ldd	r19, Y+2	; 0x02
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	28 17       	cp	r18, r24
    1666:	39 07       	cpc	r19, r25
    1668:	f4 f2       	brlt	.-68     	; 0x1626 <LCDEXPLOITING_DrawLoading+0x16>
		LCD_XYPrintf(clk, 1, "%?");
	}
}
    166a:	0f 90       	pop	r0
    166c:	0f 90       	pop	r0
    166e:	0f 90       	pop	r0
    1670:	0f 90       	pop	r0
    1672:	df 91       	pop	r29
    1674:	cf 91       	pop	r28
    1676:	08 95       	ret

00001678 <LedControl_ON>:
#include "../HEADERS/LEDcontrol.h"
#include "../HEADERS/PWM.h"
#include "../../Libraries/Headers/delay.h"

		/* FUNCTIONS */
		void LedControl_ON(int time) {
    1678:	cf 93       	push	r28
    167a:	df 93       	push	r29
    167c:	00 d0       	rcall	.+0      	; 0x167e <LedControl_ON+0x6>
    167e:	00 d0       	rcall	.+0      	; 0x1680 <LedControl_ON+0x8>
    1680:	00 d0       	rcall	.+0      	; 0x1682 <LedControl_ON+0xa>
    1682:	cd b7       	in	r28, 0x3d	; 61
    1684:	de b7       	in	r29, 0x3e	; 62
    1686:	9c 83       	std	Y+4, r25	; 0x04
    1688:	8b 83       	std	Y+3, r24	; 0x03
			for (int clk = 0; clk < 100; clk++) {
    168a:	1a 82       	std	Y+2, r1	; 0x02
    168c:	19 82       	std	Y+1, r1	; 0x01
    168e:	13 c0       	rjmp	.+38     	; 0x16b6 <LedControl_ON+0x3e>
				PWM_SetLedBrightness(clk);
    1690:	89 81       	ldd	r24, Y+1	; 0x01
    1692:	9a 81       	ldd	r25, Y+2	; 0x02
    1694:	0e 94 a8 0b 	call	0x1750	; 0x1750 <PWM_SetLedBrightness>
				DELAY_ms(time / 100);
    1698:	8b 81       	ldd	r24, Y+3	; 0x03
    169a:	9c 81       	ldd	r25, Y+4	; 0x04
    169c:	24 e6       	ldi	r18, 0x64	; 100
    169e:	30 e0       	ldi	r19, 0x00	; 0
    16a0:	b9 01       	movw	r22, r18
    16a2:	0e 94 00 32 	call	0x6400	; 0x6400 <__divmodhi4>
    16a6:	cb 01       	movw	r24, r22
    16a8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
#include "../HEADERS/PWM.h"
#include "../../Libraries/Headers/delay.h"

		/* FUNCTIONS */
		void LedControl_ON(int time) {
			for (int clk = 0; clk < 100; clk++) {
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
    16ae:	9a 81       	ldd	r25, Y+2	; 0x02
    16b0:	01 96       	adiw	r24, 0x01	; 1
    16b2:	9a 83       	std	Y+2, r25	; 0x02
    16b4:	89 83       	std	Y+1, r24	; 0x01
    16b6:	89 81       	ldd	r24, Y+1	; 0x01
    16b8:	9a 81       	ldd	r25, Y+2	; 0x02
    16ba:	84 36       	cpi	r24, 0x64	; 100
    16bc:	91 05       	cpc	r25, r1
    16be:	44 f3       	brlt	.-48     	; 0x1690 <LedControl_ON+0x18>
				PWM_SetLedBrightness(clk);
				DELAY_ms(time / 100);
			}
		}
    16c0:	26 96       	adiw	r28, 0x06	; 6
    16c2:	0f b6       	in	r0, 0x3f	; 63
    16c4:	f8 94       	cli
    16c6:	de bf       	out	0x3e, r29	; 62
    16c8:	0f be       	out	0x3f, r0	; 63
    16ca:	cd bf       	out	0x3d, r28	; 61
    16cc:	df 91       	pop	r29
    16ce:	cf 91       	pop	r28
    16d0:	08 95       	ret

000016d2 <LedControl_OFF>:

		void LedControl_OFF(int time) {
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	00 d0       	rcall	.+0      	; 0x16d8 <LedControl_OFF+0x6>
    16d8:	00 d0       	rcall	.+0      	; 0x16da <LedControl_OFF+0x8>
    16da:	00 d0       	rcall	.+0      	; 0x16dc <LedControl_OFF+0xa>
    16dc:	cd b7       	in	r28, 0x3d	; 61
    16de:	de b7       	in	r29, 0x3e	; 62
    16e0:	9c 83       	std	Y+4, r25	; 0x04
    16e2:	8b 83       	std	Y+3, r24	; 0x03
			for (int clk = 100; clk > 0; clk--) {
    16e4:	84 e6       	ldi	r24, 0x64	; 100
    16e6:	90 e0       	ldi	r25, 0x00	; 0
    16e8:	9a 83       	std	Y+2, r25	; 0x02
    16ea:	89 83       	std	Y+1, r24	; 0x01
    16ec:	13 c0       	rjmp	.+38     	; 0x1714 <LedControl_OFF+0x42>
				PWM_SetLedBrightness(clk);
    16ee:	89 81       	ldd	r24, Y+1	; 0x01
    16f0:	9a 81       	ldd	r25, Y+2	; 0x02
    16f2:	0e 94 a8 0b 	call	0x1750	; 0x1750 <PWM_SetLedBrightness>
				DELAY_ms(time / 100);
    16f6:	8b 81       	ldd	r24, Y+3	; 0x03
    16f8:	9c 81       	ldd	r25, Y+4	; 0x04
    16fa:	24 e6       	ldi	r18, 0x64	; 100
    16fc:	30 e0       	ldi	r19, 0x00	; 0
    16fe:	b9 01       	movw	r22, r18
    1700:	0e 94 00 32 	call	0x6400	; 0x6400 <__divmodhi4>
    1704:	cb 01       	movw	r24, r22
    1706:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				DELAY_ms(time / 100);
			}
		}

		void LedControl_OFF(int time) {
			for (int clk = 100; clk > 0; clk--) {
    170a:	89 81       	ldd	r24, Y+1	; 0x01
    170c:	9a 81       	ldd	r25, Y+2	; 0x02
    170e:	01 97       	sbiw	r24, 0x01	; 1
    1710:	9a 83       	std	Y+2, r25	; 0x02
    1712:	89 83       	std	Y+1, r24	; 0x01
    1714:	89 81       	ldd	r24, Y+1	; 0x01
    1716:	9a 81       	ldd	r25, Y+2	; 0x02
    1718:	18 16       	cp	r1, r24
    171a:	19 06       	cpc	r1, r25
    171c:	44 f3       	brlt	.-48     	; 0x16ee <LedControl_OFF+0x1c>
				PWM_SetLedBrightness(clk);
				DELAY_ms(time / 100);
			}
		}
    171e:	26 96       	adiw	r28, 0x06	; 6
    1720:	0f b6       	in	r0, 0x3f	; 63
    1722:	f8 94       	cli
    1724:	de bf       	out	0x3e, r29	; 62
    1726:	0f be       	out	0x3f, r0	; 63
    1728:	cd bf       	out	0x3d, r28	; 61
    172a:	df 91       	pop	r29
    172c:	cf 91       	pop	r28
    172e:	08 95       	ret

00001730 <LedControl_set>:

		void LedControl_set(int value) {
    1730:	cf 93       	push	r28
    1732:	df 93       	push	r29
    1734:	00 d0       	rcall	.+0      	; 0x1736 <LedControl_set+0x6>
    1736:	cd b7       	in	r28, 0x3d	; 61
    1738:	de b7       	in	r29, 0x3e	; 62
    173a:	9a 83       	std	Y+2, r25	; 0x02
    173c:	89 83       	std	Y+1, r24	; 0x01
			PWM_SetLedBrightness(value);
    173e:	89 81       	ldd	r24, Y+1	; 0x01
    1740:	9a 81       	ldd	r25, Y+2	; 0x02
    1742:	0e 94 a8 0b 	call	0x1750	; 0x1750 <PWM_SetLedBrightness>
		}
    1746:	0f 90       	pop	r0
    1748:	0f 90       	pop	r0
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	08 95       	ret

00001750 <PWM_SetLedBrightness>:

		void PWM_SetLedBrightness(int val) {
    1750:	cf 93       	push	r28
    1752:	df 93       	push	r29
    1754:	00 d0       	rcall	.+0      	; 0x1756 <PWM_SetLedBrightness+0x6>
    1756:	00 d0       	rcall	.+0      	; 0x1758 <PWM_SetLedBrightness+0x8>
    1758:	cd b7       	in	r28, 0x3d	; 61
    175a:	de b7       	in	r29, 0x3e	; 62
    175c:	9c 83       	std	Y+4, r25	; 0x04
    175e:	8b 83       	std	Y+3, r24	; 0x03
			if (val < 0 || val > 100)
    1760:	8b 81       	ldd	r24, Y+3	; 0x03
    1762:	9c 81       	ldd	r25, Y+4	; 0x04
    1764:	99 23       	and	r25, r25
    1766:	2c f0       	brlt	.+10     	; 0x1772 <PWM_SetLedBrightness+0x22>
    1768:	8b 81       	ldd	r24, Y+3	; 0x03
    176a:	9c 81       	ldd	r25, Y+4	; 0x04
    176c:	85 36       	cpi	r24, 0x65	; 101
    176e:	91 05       	cpc	r25, r1
    1770:	0c f0       	brlt	.+2      	; 0x1774 <PWM_SetLedBrightness+0x24>
				return;
    1772:	0f c0       	rjmp	.+30     	; 0x1792 <PWM_SetLedBrightness+0x42>
			int tmp = 100 - val;
    1774:	24 e6       	ldi	r18, 0x64	; 100
    1776:	30 e0       	ldi	r19, 0x00	; 0
    1778:	8b 81       	ldd	r24, Y+3	; 0x03
    177a:	9c 81       	ldd	r25, Y+4	; 0x04
    177c:	a9 01       	movw	r20, r18
    177e:	48 1b       	sub	r20, r24
    1780:	59 0b       	sbc	r21, r25
    1782:	ca 01       	movw	r24, r20
    1784:	9a 83       	std	Y+2, r25	; 0x02
    1786:	89 83       	std	Y+1, r24	; 0x01
			PWM_SetDutyCycle(2, tmp);
    1788:	89 81       	ldd	r24, Y+1	; 0x01
    178a:	68 2f       	mov	r22, r24
    178c:	82 e0       	ldi	r24, 0x02	; 2
    178e:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <PWM_SetDutyCycle>
		}
    1792:	0f 90       	pop	r0
    1794:	0f 90       	pop	r0
    1796:	0f 90       	pop	r0
    1798:	0f 90       	pop	r0
    179a:	df 91       	pop	r29
    179c:	cf 91       	pop	r28
    179e:	08 95       	ret

000017a0 <PWM_Init>:
/* CONNECT HEADER */
#include "../HEADERS/PWM.h"

/* BODY OF FUNCTIONS */
void PWM_Init() {
    17a0:	cf 93       	push	r28
    17a2:	df 93       	push	r29
    17a4:	cd b7       	in	r28, 0x3d	; 61
    17a6:	de b7       	in	r29, 0x3e	; 62
	DDRD |= (PWM_A | PWM_B);
    17a8:	81 e3       	ldi	r24, 0x31	; 49
    17aa:	90 e0       	ldi	r25, 0x00	; 0
    17ac:	21 e3       	ldi	r18, 0x31	; 49
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	f9 01       	movw	r30, r18
    17b2:	20 81       	ld	r18, Z
    17b4:	20 63       	ori	r18, 0x30	; 48
    17b6:	fc 01       	movw	r30, r24
    17b8:	20 83       	st	Z, r18
}
    17ba:	df 91       	pop	r29
    17bc:	cf 91       	pop	r28
    17be:	08 95       	ret

000017c0 <PWM_SetDutyCycle>:

void PWM_SetDutyCycle(uint8_t channel, uint8_t dutysCycle) {
    17c0:	cf 93       	push	r28
    17c2:	df 93       	push	r29
    17c4:	00 d0       	rcall	.+0      	; 0x17c6 <PWM_SetDutyCycle+0x6>
    17c6:	cd b7       	in	r28, 0x3d	; 61
    17c8:	de b7       	in	r29, 0x3e	; 62
    17ca:	89 83       	std	Y+1, r24	; 0x01
    17cc:	6a 83       	std	Y+2, r22	; 0x02
	dutysCycle *= 2.55;
    17ce:	8a 81       	ldd	r24, Y+2	; 0x02
    17d0:	88 2f       	mov	r24, r24
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	aa 27       	eor	r26, r26
    17d6:	97 fd       	sbrc	r25, 7
    17d8:	a0 95       	com	r26
    17da:	ba 2f       	mov	r27, r26
    17dc:	bc 01       	movw	r22, r24
    17de:	cd 01       	movw	r24, r26
    17e0:	0e 94 4f 33 	call	0x669e	; 0x669e <__floatsisf>
    17e4:	dc 01       	movw	r26, r24
    17e6:	cb 01       	movw	r24, r22
    17e8:	23 e3       	ldi	r18, 0x33	; 51
    17ea:	33 e3       	ldi	r19, 0x33	; 51
    17ec:	43 e2       	ldi	r20, 0x23	; 35
    17ee:	50 e4       	ldi	r21, 0x40	; 64
    17f0:	bc 01       	movw	r22, r24
    17f2:	cd 01       	movw	r24, r26
    17f4:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    17f8:	dc 01       	movw	r26, r24
    17fa:	cb 01       	movw	r24, r22
    17fc:	bc 01       	movw	r22, r24
    17fe:	cd 01       	movw	r24, r26
    1800:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    1804:	dc 01       	movw	r26, r24
    1806:	cb 01       	movw	r24, r22
    1808:	8a 83       	std	Y+2, r24	; 0x02

	switch (channel) {
    180a:	89 81       	ldd	r24, Y+1	; 0x01
    180c:	88 2f       	mov	r24, r24
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	81 30       	cpi	r24, 0x01	; 1
    1812:	91 05       	cpc	r25, r1
    1814:	21 f0       	breq	.+8      	; 0x181e <PWM_SetDutyCycle+0x5e>
    1816:	82 30       	cpi	r24, 0x02	; 2
    1818:	91 05       	cpc	r25, r1
    181a:	51 f0       	breq	.+20     	; 0x1830 <PWM_SetDutyCycle+0x70>
    181c:	12 c0       	rjmp	.+36     	; 0x1842 <PWM_SetDutyCycle+0x82>
	case 1:
		OCR1A = dutysCycle;    //Set the Duty Cycle between 0-100
    181e:	8a e4       	ldi	r24, 0x4A	; 74
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	2a 81       	ldd	r18, Y+2	; 0x02
    1824:	22 2f       	mov	r18, r18
    1826:	30 e0       	ldi	r19, 0x00	; 0
    1828:	fc 01       	movw	r30, r24
    182a:	31 83       	std	Z+1, r19	; 0x01
    182c:	20 83       	st	Z, r18
		break;
    182e:	09 c0       	rjmp	.+18     	; 0x1842 <PWM_SetDutyCycle+0x82>

	case 2:
		OCR1B = dutysCycle;    //Set the Duty Cycle between 0-100
    1830:	88 e4       	ldi	r24, 0x48	; 72
    1832:	90 e0       	ldi	r25, 0x00	; 0
    1834:	2a 81       	ldd	r18, Y+2	; 0x02
    1836:	22 2f       	mov	r18, r18
    1838:	30 e0       	ldi	r19, 0x00	; 0
    183a:	fc 01       	movw	r30, r24
    183c:	31 83       	std	Z+1, r19	; 0x01
    183e:	20 83       	st	Z, r18
		break;
    1840:	00 00       	nop
	}
}
    1842:	0f 90       	pop	r0
    1844:	0f 90       	pop	r0
    1846:	df 91       	pop	r29
    1848:	cf 91       	pop	r28
    184a:	08 95       	ret

0000184c <PWM_Start>:

void PWM_Start() {
    184c:	cf 93       	push	r28
    184e:	df 93       	push	r29
    1850:	cd b7       	in	r28, 0x3d	; 61
    1852:	de b7       	in	r29, 0x3e	; 62
	TCCR1A |= (1 << WGM10);
    1854:	8f e4       	ldi	r24, 0x4F	; 79
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	2f e4       	ldi	r18, 0x4F	; 79
    185a:	30 e0       	ldi	r19, 0x00	; 0
    185c:	f9 01       	movw	r30, r18
    185e:	20 81       	ld	r18, Z
    1860:	21 60       	ori	r18, 0x01	; 1
    1862:	fc 01       	movw	r30, r24
    1864:	20 83       	st	Z, r18
	TCCR1B |= (1 << WGM12);
    1866:	8e e4       	ldi	r24, 0x4E	; 78
    1868:	90 e0       	ldi	r25, 0x00	; 0
    186a:	2e e4       	ldi	r18, 0x4E	; 78
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	f9 01       	movw	r30, r18
    1870:	20 81       	ld	r18, Z
    1872:	28 60       	ori	r18, 0x08	; 8
    1874:	fc 01       	movw	r30, r24
    1876:	20 83       	st	Z, r18
	TCCR1A |= (1 << COM1A1) | (1 << COM1B1);
    1878:	8f e4       	ldi	r24, 0x4F	; 79
    187a:	90 e0       	ldi	r25, 0x00	; 0
    187c:	2f e4       	ldi	r18, 0x4F	; 79
    187e:	30 e0       	ldi	r19, 0x00	; 0
    1880:	f9 01       	movw	r30, r18
    1882:	20 81       	ld	r18, Z
    1884:	20 6a       	ori	r18, 0xA0	; 160
    1886:	fc 01       	movw	r30, r24
    1888:	20 83       	st	Z, r18
	TCCR1B |= (1 << CS10) | (1 << CS11);
    188a:	8e e4       	ldi	r24, 0x4E	; 78
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	2e e4       	ldi	r18, 0x4E	; 78
    1890:	30 e0       	ldi	r19, 0x00	; 0
    1892:	f9 01       	movw	r30, r18
    1894:	20 81       	ld	r18, Z
    1896:	23 60       	ori	r18, 0x03	; 3
    1898:	fc 01       	movw	r30, r24
    189a:	20 83       	st	Z, r18
	OCR1A = 0;
    189c:	8a e4       	ldi	r24, 0x4A	; 74
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	fc 01       	movw	r30, r24
    18a2:	11 82       	std	Z+1, r1	; 0x01
    18a4:	10 82       	st	Z, r1
	OCR1B = 0;
    18a6:	88 e4       	ldi	r24, 0x48	; 72
    18a8:	90 e0       	ldi	r25, 0x00	; 0
    18aa:	fc 01       	movw	r30, r24
    18ac:	11 82       	std	Z+1, r1	; 0x01
    18ae:	10 82       	st	Z, r1
}
    18b0:	df 91       	pop	r29
    18b2:	cf 91       	pop	r28
    18b4:	08 95       	ret

000018b6 <SettingsMenu_ShowMenu>:
 */

#include "../HEADERS/SettingsMenu.h"

/* FUNCTIONS */
void SettingsMenu_ShowMenu(struct SettingsMenu_values *settinsgMenu_values) {
    18b6:	cf 93       	push	r28
    18b8:	df 93       	push	r29
    18ba:	cd b7       	in	r28, 0x3d	; 61
    18bc:	de b7       	in	r29, 0x3e	; 62
    18be:	60 97       	sbiw	r28, 0x10	; 16
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	de bf       	out	0x3e, r29	; 62
    18c6:	0f be       	out	0x3f, r0	; 63
    18c8:	cd bf       	out	0x3d, r28	; 61
    18ca:	98 8b       	std	Y+16, r25	; 0x10
    18cc:	8f 87       	std	Y+15, r24	; 0x0f

	//creating temporary files for discard changes way
	struct SettingsMenu_values tmpValues;

	tmpValues.pwmBrightness = settinsgMenu_values->pwmBrightness;
    18ce:	8f 85       	ldd	r24, Y+15	; 0x0f
    18d0:	98 89       	ldd	r25, Y+16	; 0x10
    18d2:	fc 01       	movw	r30, r24
    18d4:	85 81       	ldd	r24, Z+5	; 0x05
    18d6:	96 81       	ldd	r25, Z+6	; 0x06
    18d8:	9f 83       	std	Y+7, r25	; 0x07
    18da:	8e 83       	std	Y+6, r24	; 0x06
	tmpValues.timeDelay = settinsgMenu_values->timeDelay;
    18dc:	8f 85       	ldd	r24, Y+15	; 0x0f
    18de:	98 89       	ldd	r25, Y+16	; 0x10
    18e0:	fc 01       	movw	r30, r24
    18e2:	81 85       	ldd	r24, Z+9	; 0x09
    18e4:	92 85       	ldd	r25, Z+10	; 0x0a
    18e6:	9b 87       	std	Y+11, r25	; 0x0b
    18e8:	8a 87       	std	Y+10, r24	; 0x0a
	tmpValues.ledStatus = settinsgMenu_values->ledStatus;
    18ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    18ec:	98 89       	ldd	r25, Y+16	; 0x10
    18ee:	fc 01       	movw	r30, r24
    18f0:	87 81       	ldd	r24, Z+7	; 0x07
    18f2:	88 87       	std	Y+8, r24	; 0x08
	tmpValues.debugMode = settinsgMenu_values->debugMode;
    18f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    18f6:	98 89       	ldd	r25, Y+16	; 0x10
    18f8:	fc 01       	movw	r30, r24
    18fa:	80 85       	ldd	r24, Z+8	; 0x08
    18fc:	89 87       	std	Y+9, r24	; 0x09
	tmpValues.showChangingPage = settinsgMenu_values->showChangingPage;
    18fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    1900:	98 89       	ldd	r25, Y+16	; 0x10
    1902:	fc 01       	movw	r30, r24
    1904:	83 85       	ldd	r24, Z+11	; 0x0b
    1906:	8c 87       	std	Y+12, r24	; 0x0c

	int settingsPage = 1;
    1908:	81 e0       	ldi	r24, 0x01	; 1
    190a:	90 e0       	ldi	r25, 0x00	; 0
    190c:	9e 87       	std	Y+14, r25	; 0x0e
    190e:	8d 87       	std	Y+13, r24	; 0x0d

	//showing button maping on screen
	LCD_Clear();
    1910:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_XYPrintf(0, 0, "%[");
    1914:	8c e6       	ldi	r24, 0x6C	; 108
    1916:	91 e0       	ldi	r25, 0x01	; 1
    1918:	89 2f       	mov	r24, r25
    191a:	8f 93       	push	r24
    191c:	8c e6       	ldi	r24, 0x6C	; 108
    191e:	91 e0       	ldi	r25, 0x01	; 1
    1920:	8f 93       	push	r24
    1922:	1f 92       	push	r1
    1924:	1f 92       	push	r1
    1926:	1f 92       	push	r1
    1928:	1f 92       	push	r1
    192a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    192e:	0f 90       	pop	r0
    1930:	0f 90       	pop	r0
    1932:	0f 90       	pop	r0
    1934:	0f 90       	pop	r0
    1936:	0f 90       	pop	r0
    1938:	0f 90       	pop	r0
	LCD_XYPrintf(15, 0, "%]");
    193a:	8f e6       	ldi	r24, 0x6F	; 111
    193c:	91 e0       	ldi	r25, 0x01	; 1
    193e:	89 2f       	mov	r24, r25
    1940:	8f 93       	push	r24
    1942:	8f e6       	ldi	r24, 0x6F	; 111
    1944:	91 e0       	ldi	r25, 0x01	; 1
    1946:	8f 93       	push	r24
    1948:	1f 92       	push	r1
    194a:	1f 92       	push	r1
    194c:	1f 92       	push	r1
    194e:	8f e0       	ldi	r24, 0x0F	; 15
    1950:	8f 93       	push	r24
    1952:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1956:	0f 90       	pop	r0
    1958:	0f 90       	pop	r0
    195a:	0f 90       	pop	r0
    195c:	0f 90       	pop	r0
    195e:	0f 90       	pop	r0
    1960:	0f 90       	pop	r0
	LCD_XYPrintf(0, 1, "%[");
    1962:	8c e6       	ldi	r24, 0x6C	; 108
    1964:	91 e0       	ldi	r25, 0x01	; 1
    1966:	89 2f       	mov	r24, r25
    1968:	8f 93       	push	r24
    196a:	8c e6       	ldi	r24, 0x6C	; 108
    196c:	91 e0       	ldi	r25, 0x01	; 1
    196e:	8f 93       	push	r24
    1970:	1f 92       	push	r1
    1972:	81 e0       	ldi	r24, 0x01	; 1
    1974:	8f 93       	push	r24
    1976:	1f 92       	push	r1
    1978:	1f 92       	push	r1
    197a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	0f 90       	pop	r0
    1986:	0f 90       	pop	r0
    1988:	0f 90       	pop	r0
	LCD_XYPrintf(15, 1, "%]");
    198a:	8f e6       	ldi	r24, 0x6F	; 111
    198c:	91 e0       	ldi	r25, 0x01	; 1
    198e:	89 2f       	mov	r24, r25
    1990:	8f 93       	push	r24
    1992:	8f e6       	ldi	r24, 0x6F	; 111
    1994:	91 e0       	ldi	r25, 0x01	; 1
    1996:	8f 93       	push	r24
    1998:	1f 92       	push	r1
    199a:	81 e0       	ldi	r24, 0x01	; 1
    199c:	8f 93       	push	r24
    199e:	1f 92       	push	r1
    19a0:	8f e0       	ldi	r24, 0x0F	; 15
    19a2:	8f 93       	push	r24
    19a4:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    19a8:	0f 90       	pop	r0
    19aa:	0f 90       	pop	r0
    19ac:	0f 90       	pop	r0
    19ae:	0f 90       	pop	r0
    19b0:	0f 90       	pop	r0
    19b2:	0f 90       	pop	r0
	LCD_XYPrintf(3, 0, "SAVE");
    19b4:	82 e7       	ldi	r24, 0x72	; 114
    19b6:	91 e0       	ldi	r25, 0x01	; 1
    19b8:	89 2f       	mov	r24, r25
    19ba:	8f 93       	push	r24
    19bc:	82 e7       	ldi	r24, 0x72	; 114
    19be:	91 e0       	ldi	r25, 0x01	; 1
    19c0:	8f 93       	push	r24
    19c2:	1f 92       	push	r1
    19c4:	1f 92       	push	r1
    19c6:	1f 92       	push	r1
    19c8:	83 e0       	ldi	r24, 0x03	; 3
    19ca:	8f 93       	push	r24
    19cc:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    19d0:	0f 90       	pop	r0
    19d2:	0f 90       	pop	r0
    19d4:	0f 90       	pop	r0
    19d6:	0f 90       	pop	r0
    19d8:	0f 90       	pop	r0
    19da:	0f 90       	pop	r0
	LCD_XYPrintf(9, 0, "EXIT");
    19dc:	87 e7       	ldi	r24, 0x77	; 119
    19de:	91 e0       	ldi	r25, 0x01	; 1
    19e0:	89 2f       	mov	r24, r25
    19e2:	8f 93       	push	r24
    19e4:	87 e7       	ldi	r24, 0x77	; 119
    19e6:	91 e0       	ldi	r25, 0x01	; 1
    19e8:	8f 93       	push	r24
    19ea:	1f 92       	push	r1
    19ec:	1f 92       	push	r1
    19ee:	1f 92       	push	r1
    19f0:	89 e0       	ldi	r24, 0x09	; 9
    19f2:	8f 93       	push	r24
    19f4:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    19f8:	0f 90       	pop	r0
    19fa:	0f 90       	pop	r0
    19fc:	0f 90       	pop	r0
    19fe:	0f 90       	pop	r0
    1a00:	0f 90       	pop	r0
    1a02:	0f 90       	pop	r0
	LCD_XYPrintf(3, 1, "%<%>");
    1a04:	8c e7       	ldi	r24, 0x7C	; 124
    1a06:	91 e0       	ldi	r25, 0x01	; 1
    1a08:	89 2f       	mov	r24, r25
    1a0a:	8f 93       	push	r24
    1a0c:	8c e7       	ldi	r24, 0x7C	; 124
    1a0e:	91 e0       	ldi	r25, 0x01	; 1
    1a10:	8f 93       	push	r24
    1a12:	1f 92       	push	r1
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	8f 93       	push	r24
    1a18:	1f 92       	push	r1
    1a1a:	83 e0       	ldi	r24, 0x03	; 3
    1a1c:	8f 93       	push	r24
    1a1e:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1a22:	0f 90       	pop	r0
    1a24:	0f 90       	pop	r0
    1a26:	0f 90       	pop	r0
    1a28:	0f 90       	pop	r0
    1a2a:	0f 90       	pop	r0
    1a2c:	0f 90       	pop	r0
	LCD_XYPrintf(11, 1, "%<%>");
    1a2e:	8c e7       	ldi	r24, 0x7C	; 124
    1a30:	91 e0       	ldi	r25, 0x01	; 1
    1a32:	89 2f       	mov	r24, r25
    1a34:	8f 93       	push	r24
    1a36:	8c e7       	ldi	r24, 0x7C	; 124
    1a38:	91 e0       	ldi	r25, 0x01	; 1
    1a3a:	8f 93       	push	r24
    1a3c:	1f 92       	push	r1
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
    1a40:	8f 93       	push	r24
    1a42:	1f 92       	push	r1
    1a44:	8b e0       	ldi	r24, 0x0B	; 11
    1a46:	8f 93       	push	r24
    1a48:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1a4c:	0f 90       	pop	r0
    1a4e:	0f 90       	pop	r0
    1a50:	0f 90       	pop	r0
    1a52:	0f 90       	pop	r0
    1a54:	0f 90       	pop	r0
    1a56:	0f 90       	pop	r0
	LCD_XYPrintf(2, 0, "|");
    1a58:	81 e8       	ldi	r24, 0x81	; 129
    1a5a:	91 e0       	ldi	r25, 0x01	; 1
    1a5c:	89 2f       	mov	r24, r25
    1a5e:	8f 93       	push	r24
    1a60:	81 e8       	ldi	r24, 0x81	; 129
    1a62:	91 e0       	ldi	r25, 0x01	; 1
    1a64:	8f 93       	push	r24
    1a66:	1f 92       	push	r1
    1a68:	1f 92       	push	r1
    1a6a:	1f 92       	push	r1
    1a6c:	82 e0       	ldi	r24, 0x02	; 2
    1a6e:	8f 93       	push	r24
    1a70:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1a74:	0f 90       	pop	r0
    1a76:	0f 90       	pop	r0
    1a78:	0f 90       	pop	r0
    1a7a:	0f 90       	pop	r0
    1a7c:	0f 90       	pop	r0
    1a7e:	0f 90       	pop	r0
	LCD_XYPrintf(2, 1, "|");
    1a80:	81 e8       	ldi	r24, 0x81	; 129
    1a82:	91 e0       	ldi	r25, 0x01	; 1
    1a84:	89 2f       	mov	r24, r25
    1a86:	8f 93       	push	r24
    1a88:	81 e8       	ldi	r24, 0x81	; 129
    1a8a:	91 e0       	ldi	r25, 0x01	; 1
    1a8c:	8f 93       	push	r24
    1a8e:	1f 92       	push	r1
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	8f 93       	push	r24
    1a94:	1f 92       	push	r1
    1a96:	82 e0       	ldi	r24, 0x02	; 2
    1a98:	8f 93       	push	r24
    1a9a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1a9e:	0f 90       	pop	r0
    1aa0:	0f 90       	pop	r0
    1aa2:	0f 90       	pop	r0
    1aa4:	0f 90       	pop	r0
    1aa6:	0f 90       	pop	r0
    1aa8:	0f 90       	pop	r0
	LCD_XYPrintf(13, 0, "|");
    1aaa:	81 e8       	ldi	r24, 0x81	; 129
    1aac:	91 e0       	ldi	r25, 0x01	; 1
    1aae:	89 2f       	mov	r24, r25
    1ab0:	8f 93       	push	r24
    1ab2:	81 e8       	ldi	r24, 0x81	; 129
    1ab4:	91 e0       	ldi	r25, 0x01	; 1
    1ab6:	8f 93       	push	r24
    1ab8:	1f 92       	push	r1
    1aba:	1f 92       	push	r1
    1abc:	1f 92       	push	r1
    1abe:	8d e0       	ldi	r24, 0x0D	; 13
    1ac0:	8f 93       	push	r24
    1ac2:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1ac6:	0f 90       	pop	r0
    1ac8:	0f 90       	pop	r0
    1aca:	0f 90       	pop	r0
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	0f 90       	pop	r0
	LCD_XYPrintf(13, 1, "|");
    1ad2:	81 e8       	ldi	r24, 0x81	; 129
    1ad4:	91 e0       	ldi	r25, 0x01	; 1
    1ad6:	89 2f       	mov	r24, r25
    1ad8:	8f 93       	push	r24
    1ada:	81 e8       	ldi	r24, 0x81	; 129
    1adc:	91 e0       	ldi	r25, 0x01	; 1
    1ade:	8f 93       	push	r24
    1ae0:	1f 92       	push	r1
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	8f 93       	push	r24
    1ae6:	1f 92       	push	r1
    1ae8:	8d e0       	ldi	r24, 0x0D	; 13
    1aea:	8f 93       	push	r24
    1aec:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1af0:	0f 90       	pop	r0
    1af2:	0f 90       	pop	r0
    1af4:	0f 90       	pop	r0
    1af6:	0f 90       	pop	r0
    1af8:	0f 90       	pop	r0
    1afa:	0f 90       	pop	r0
	DELAY_ms(2000);
    1afc:	80 ed       	ldi	r24, 0xD0	; 208
    1afe:	97 e0       	ldi	r25, 0x07	; 7
    1b00:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	LCD_Clear();
    1b04:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>

	//entering to settings menu loop
	while (1) {

		// showing 1 page of settings "standby"
		if (settingsPage == 1) {
    1b08:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b0a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b0c:	81 30       	cpi	r24, 0x01	; 1
    1b0e:	91 05       	cpc	r25, r1
    1b10:	61 f4       	brne	.+24     	; 0x1b2a <SettingsMenu_ShowMenu+0x274>
			SettingsMenu_PrintLabel("Standby"); //print page on screen
    1b12:	83 e8       	ldi	r24, 0x83	; 131
    1b14:	91 e0       	ldi	r25, 0x01	; 1
    1b16:	0e 94 af 14 	call	0x295e	; 0x295e <SettingsMenu_PrintLabel>
			SettingsMenu_pressedButton(&tmpValues, &settingsPage); //function to chage pages or change status of selected option
    1b1a:	ce 01       	movw	r24, r28
    1b1c:	0d 96       	adiw	r24, 0x0d	; 13
    1b1e:	bc 01       	movw	r22, r24
    1b20:	ce 01       	movw	r24, r28
    1b22:	01 96       	adiw	r24, 0x01	; 1
    1b24:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <SettingsMenu_pressedButton>
    1b28:	37 c1       	rjmp	.+622    	; 0x1d98 <SettingsMenu_ShowMenu+0x4e2>
		}
		//showing 2 page of settings "brightness settings"
		else if (settingsPage == 2) {
    1b2a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b2c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b2e:	82 30       	cpi	r24, 0x02	; 2
    1b30:	91 05       	cpc	r25, r1
    1b32:	71 f4       	brne	.+28     	; 0x1b50 <SettingsMenu_ShowMenu+0x29a>
			SettingsMenu_PrintValue(tmpValues.pwmBrightness, "Brightness"); //print page on screen
    1b34:	8e 81       	ldd	r24, Y+6	; 0x06
    1b36:	9f 81       	ldd	r25, Y+7	; 0x07
    1b38:	6b e8       	ldi	r22, 0x8B	; 139
    1b3a:	71 e0       	ldi	r23, 0x01	; 1
    1b3c:	0e 94 56 14 	call	0x28ac	; 0x28ac <SettingsMenu_PrintValue>
			SettingsMenu_pressedButton(&tmpValues, &settingsPage); //function to chage pages or change status of selected option
    1b40:	ce 01       	movw	r24, r28
    1b42:	0d 96       	adiw	r24, 0x0d	; 13
    1b44:	bc 01       	movw	r22, r24
    1b46:	ce 01       	movw	r24, r28
    1b48:	01 96       	adiw	r24, 0x01	; 1
    1b4a:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <SettingsMenu_pressedButton>
    1b4e:	24 c1       	rjmp	.+584    	; 0x1d98 <SettingsMenu_ShowMenu+0x4e2>
		}
		//showing 3 page of settings "turning on or off led notification"
		else if (settingsPage == 3) {
    1b50:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b52:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b54:	83 30       	cpi	r24, 0x03	; 3
    1b56:	91 05       	cpc	r25, r1
    1b58:	69 f4       	brne	.+26     	; 0x1b74 <SettingsMenu_ShowMenu+0x2be>
			SettingsMenu_PrintBoolean(tmpValues.ledStatus, "Led info"); //print page on screen
    1b5a:	88 85       	ldd	r24, Y+8	; 0x08
    1b5c:	66 e9       	ldi	r22, 0x96	; 150
    1b5e:	71 e0       	ldi	r23, 0x01	; 1
    1b60:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
			SettingsMenu_pressedButton(&tmpValues, &settingsPage); //function to chage pages or change status of selected option
    1b64:	ce 01       	movw	r24, r28
    1b66:	0d 96       	adiw	r24, 0x0d	; 13
    1b68:	bc 01       	movw	r22, r24
    1b6a:	ce 01       	movw	r24, r28
    1b6c:	01 96       	adiw	r24, 0x01	; 1
    1b6e:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <SettingsMenu_pressedButton>
    1b72:	12 c1       	rjmp	.+548    	; 0x1d98 <SettingsMenu_ShowMenu+0x4e2>
		}
		//showing 4 page of settings "changing time of delay beetwen changing pages"
		else if (settingsPage == 4) {
    1b74:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b76:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b78:	84 30       	cpi	r24, 0x04	; 4
    1b7a:	91 05       	cpc	r25, r1
    1b7c:	71 f4       	brne	.+28     	; 0x1b9a <SettingsMenu_ShowMenu+0x2e4>
			SettingsMenu_PrintValue(tmpValues.timeDelay, "Delay time"); //print page on screen
    1b7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b80:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b82:	6f e9       	ldi	r22, 0x9F	; 159
    1b84:	71 e0       	ldi	r23, 0x01	; 1
    1b86:	0e 94 56 14 	call	0x28ac	; 0x28ac <SettingsMenu_PrintValue>
			SettingsMenu_pressedButton(&tmpValues, &settingsPage); //function to chage pages or change status of selected option
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	0d 96       	adiw	r24, 0x0d	; 13
    1b8e:	bc 01       	movw	r22, r24
    1b90:	ce 01       	movw	r24, r28
    1b92:	01 96       	adiw	r24, 0x01	; 1
    1b94:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <SettingsMenu_pressedButton>
    1b98:	ff c0       	rjmp	.+510    	; 0x1d98 <SettingsMenu_ShowMenu+0x4e2>
		}
		//showing 5 page of settings "turning on debug info mode"
		else if (settingsPage == 5) {
    1b9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b9e:	85 30       	cpi	r24, 0x05	; 5
    1ba0:	91 05       	cpc	r25, r1
    1ba2:	69 f4       	brne	.+26     	; 0x1bbe <SettingsMenu_ShowMenu+0x308>
			SettingsMenu_PrintBoolean(tmpValues.debugMode, "Debug mode"); //print page on screen
    1ba4:	89 85       	ldd	r24, Y+9	; 0x09
    1ba6:	6a ea       	ldi	r22, 0xAA	; 170
    1ba8:	71 e0       	ldi	r23, 0x01	; 1
    1baa:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
			SettingsMenu_pressedButton(&tmpValues, &settingsPage); //function to chage pages or change status of selected option
    1bae:	ce 01       	movw	r24, r28
    1bb0:	0d 96       	adiw	r24, 0x0d	; 13
    1bb2:	bc 01       	movw	r22, r24
    1bb4:	ce 01       	movw	r24, r28
    1bb6:	01 96       	adiw	r24, 0x01	; 1
    1bb8:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <SettingsMenu_pressedButton>
    1bbc:	ed c0       	rjmp	.+474    	; 0x1d98 <SettingsMenu_ShowMenu+0x4e2>
		}
		//showing 5 page of settings "turning on debug info mode"
		else if (settingsPage == 6) {
    1bbe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bc0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1bc2:	86 30       	cpi	r24, 0x06	; 6
    1bc4:	91 05       	cpc	r25, r1
    1bc6:	69 f4       	brne	.+26     	; 0x1be2 <SettingsMenu_ShowMenu+0x32c>
			SettingsMenu_PrintBoolean(tmpValues.showChangingPage,
    1bc8:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bca:	65 eb       	ldi	r22, 0xB5	; 181
    1bcc:	71 e0       	ldi	r23, 0x01	; 1
    1bce:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
					"Page number"); //print page on screen
			SettingsMenu_pressedButton(&tmpValues, &settingsPage); //function to chage pages or change status of selected option
    1bd2:	ce 01       	movw	r24, r28
    1bd4:	0d 96       	adiw	r24, 0x0d	; 13
    1bd6:	bc 01       	movw	r22, r24
    1bd8:	ce 01       	movw	r24, r28
    1bda:	01 96       	adiw	r24, 0x01	; 1
    1bdc:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <SettingsMenu_pressedButton>
    1be0:	db c0       	rjmp	.+438    	; 0x1d98 <SettingsMenu_ShowMenu+0x4e2>
		}
		// save settings and exit of settings loop
		else if (settingsPage > 100) {
    1be2:	8d 85       	ldd	r24, Y+13	; 0x0d
    1be4:	9e 85       	ldd	r25, Y+14	; 0x0e
    1be6:	85 36       	cpi	r24, 0x65	; 101
    1be8:	91 05       	cpc	r25, r1
    1bea:	0c f4       	brge	.+2      	; 0x1bee <SettingsMenu_ShowMenu+0x338>
    1bec:	ac c0       	rjmp	.+344    	; 0x1d46 <SettingsMenu_ShowMenu+0x490>
			LCD_Clear();
    1bee:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
			LCD_XYPrintf(0, 0, "Saving...");
    1bf2:	81 ec       	ldi	r24, 0xC1	; 193
    1bf4:	91 e0       	ldi	r25, 0x01	; 1
    1bf6:	89 2f       	mov	r24, r25
    1bf8:	8f 93       	push	r24
    1bfa:	81 ec       	ldi	r24, 0xC1	; 193
    1bfc:	91 e0       	ldi	r25, 0x01	; 1
    1bfe:	8f 93       	push	r24
    1c00:	1f 92       	push	r1
    1c02:	1f 92       	push	r1
    1c04:	1f 92       	push	r1
    1c06:	1f 92       	push	r1
    1c08:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1c0c:	0f 90       	pop	r0
    1c0e:	0f 90       	pop	r0
    1c10:	0f 90       	pop	r0
    1c12:	0f 90       	pop	r0
    1c14:	0f 90       	pop	r0
    1c16:	0f 90       	pop	r0
			settinsgMenu_values->pwmBrightness = tmpValues.pwmBrightness;
    1c18:	2e 81       	ldd	r18, Y+6	; 0x06
    1c1a:	3f 81       	ldd	r19, Y+7	; 0x07
    1c1c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c1e:	98 89       	ldd	r25, Y+16	; 0x10
    1c20:	fc 01       	movw	r30, r24
    1c22:	36 83       	std	Z+6, r19	; 0x06
    1c24:	25 83       	std	Z+5, r18	; 0x05
			settinsgMenu_values->timeDelay = tmpValues.timeDelay;
    1c26:	2a 85       	ldd	r18, Y+10	; 0x0a
    1c28:	3b 85       	ldd	r19, Y+11	; 0x0b
    1c2a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c2c:	98 89       	ldd	r25, Y+16	; 0x10
    1c2e:	fc 01       	movw	r30, r24
    1c30:	32 87       	std	Z+10, r19	; 0x0a
    1c32:	21 87       	std	Z+9, r18	; 0x09
			settinsgMenu_values->ledStatus = tmpValues.ledStatus;
    1c34:	28 85       	ldd	r18, Y+8	; 0x08
    1c36:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c38:	98 89       	ldd	r25, Y+16	; 0x10
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	27 83       	std	Z+7, r18	; 0x07
			settinsgMenu_values->debugMode = tmpValues.debugMode;
    1c3e:	29 85       	ldd	r18, Y+9	; 0x09
    1c40:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c42:	98 89       	ldd	r25, Y+16	; 0x10
    1c44:	fc 01       	movw	r30, r24
    1c46:	20 87       	std	Z+8, r18	; 0x08
			settinsgMenu_values->showChangingPage = tmpValues.showChangingPage;
    1c48:	2c 85       	ldd	r18, Y+12	; 0x0c
    1c4a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c4c:	98 89       	ldd	r25, Y+16	; 0x10
    1c4e:	fc 01       	movw	r30, r24
    1c50:	23 87       	std	Z+11, r18	; 0x0b
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressBrightness,
					settinsgMenu_values->pwmBrightness);
    1c52:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c54:	98 89       	ldd	r25, Y+16	; 0x10
    1c56:	fc 01       	movw	r30, r24
    1c58:	85 81       	ldd	r24, Z+5	; 0x05
    1c5a:	96 81       	ldd	r25, Z+6	; 0x06
			settinsgMenu_values->pwmBrightness = tmpValues.pwmBrightness;
			settinsgMenu_values->timeDelay = tmpValues.timeDelay;
			settinsgMenu_values->ledStatus = tmpValues.ledStatus;
			settinsgMenu_values->debugMode = tmpValues.debugMode;
			settinsgMenu_values->showChangingPage = tmpValues.showChangingPage;
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressBrightness,
    1c5c:	28 2f       	mov	r18, r24
    1c5e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c60:	98 89       	ldd	r25, Y+16	; 0x10
    1c62:	fc 01       	movw	r30, r24
    1c64:	80 81       	ld	r24, Z
    1c66:	88 2f       	mov	r24, r24
    1c68:	90 e0       	ldi	r25, 0x00	; 0
    1c6a:	62 2f       	mov	r22, r18
    1c6c:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
					settinsgMenu_values->pwmBrightness);
			DELAY_ms(200);
    1c70:	88 ec       	ldi	r24, 0xC8	; 200
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressLedStatus,
					settinsgMenu_values->ledStatus);
    1c78:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c7a:	98 89       	ldd	r25, Y+16	; 0x10
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	87 81       	ldd	r24, Z+7	; 0x07
			settinsgMenu_values->debugMode = tmpValues.debugMode;
			settinsgMenu_values->showChangingPage = tmpValues.showChangingPage;
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressBrightness,
					settinsgMenu_values->pwmBrightness);
			DELAY_ms(200);
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressLedStatus,
    1c80:	28 2f       	mov	r18, r24
    1c82:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c84:	98 89       	ldd	r25, Y+16	; 0x10
    1c86:	fc 01       	movw	r30, r24
    1c88:	81 81       	ldd	r24, Z+1	; 0x01
    1c8a:	88 2f       	mov	r24, r24
    1c8c:	90 e0       	ldi	r25, 0x00	; 0
    1c8e:	62 2f       	mov	r22, r18
    1c90:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
					settinsgMenu_values->ledStatus);
			DELAY_ms(200);
    1c94:	88 ec       	ldi	r24, 0xC8	; 200
    1c96:	90 e0       	ldi	r25, 0x00	; 0
    1c98:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressTimeDelay,
					settinsgMenu_values->timeDelay);
    1c9c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c9e:	98 89       	ldd	r25, Y+16	; 0x10
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	81 85       	ldd	r24, Z+9	; 0x09
    1ca4:	92 85       	ldd	r25, Z+10	; 0x0a
					settinsgMenu_values->pwmBrightness);
			DELAY_ms(200);
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressLedStatus,
					settinsgMenu_values->ledStatus);
			DELAY_ms(200);
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressTimeDelay,
    1ca6:	28 2f       	mov	r18, r24
    1ca8:	8f 85       	ldd	r24, Y+15	; 0x0f
    1caa:	98 89       	ldd	r25, Y+16	; 0x10
    1cac:	fc 01       	movw	r30, r24
    1cae:	82 81       	ldd	r24, Z+2	; 0x02
    1cb0:	88 2f       	mov	r24, r24
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	62 2f       	mov	r22, r18
    1cb6:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
					settinsgMenu_values->timeDelay);
			DELAY_ms(200);
    1cba:	88 ec       	ldi	r24, 0xC8	; 200
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressDebugMode,
					settinsgMenu_values->debugMode);
    1cc2:	8f 85       	ldd	r24, Y+15	; 0x0f
    1cc4:	98 89       	ldd	r25, Y+16	; 0x10
    1cc6:	fc 01       	movw	r30, r24
    1cc8:	80 85       	ldd	r24, Z+8	; 0x08
					settinsgMenu_values->ledStatus);
			DELAY_ms(200);
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressTimeDelay,
					settinsgMenu_values->timeDelay);
			DELAY_ms(200);
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressDebugMode,
    1cca:	28 2f       	mov	r18, r24
    1ccc:	8f 85       	ldd	r24, Y+15	; 0x0f
    1cce:	98 89       	ldd	r25, Y+16	; 0x10
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	83 81       	ldd	r24, Z+3	; 0x03
    1cd4:	88 2f       	mov	r24, r24
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	62 2f       	mov	r22, r18
    1cda:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
					settinsgMenu_values->debugMode);
			DELAY_ms(200);
    1cde:	88 ec       	ldi	r24, 0xC8	; 200
    1ce0:	90 e0       	ldi	r25, 0x00	; 0
    1ce2:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressShowChangingPage,
					settinsgMenu_values->showChangingPage);
    1ce6:	8f 85       	ldd	r24, Y+15	; 0x0f
    1ce8:	98 89       	ldd	r25, Y+16	; 0x10
    1cea:	fc 01       	movw	r30, r24
    1cec:	83 85       	ldd	r24, Z+11	; 0x0b
					settinsgMenu_values->timeDelay);
			DELAY_ms(200);
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressDebugMode,
					settinsgMenu_values->debugMode);
			DELAY_ms(200);
			EEPROM_WriteByte(settinsgMenu_values->eepromAddressShowChangingPage,
    1cee:	28 2f       	mov	r18, r24
    1cf0:	8f 85       	ldd	r24, Y+15	; 0x0f
    1cf2:	98 89       	ldd	r25, Y+16	; 0x10
    1cf4:	fc 01       	movw	r30, r24
    1cf6:	84 81       	ldd	r24, Z+4	; 0x04
    1cf8:	88 2f       	mov	r24, r24
    1cfa:	90 e0       	ldi	r25, 0x00	; 0
    1cfc:	62 2f       	mov	r22, r18
    1cfe:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
					settinsgMenu_values->showChangingPage);
			DELAY_ms(200);
    1d02:	88 ec       	ldi	r24, 0xC8	; 200
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			LCD_Clear();
    1d0a:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
			LCD_SetCursor(0, 0);
    1d0e:	60 e0       	ldi	r22, 0x00	; 0
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
			LCD_XYPrintf(0, 0, "Saved");
    1d16:	8b ec       	ldi	r24, 0xCB	; 203
    1d18:	91 e0       	ldi	r25, 0x01	; 1
    1d1a:	89 2f       	mov	r24, r25
    1d1c:	8f 93       	push	r24
    1d1e:	8b ec       	ldi	r24, 0xCB	; 203
    1d20:	91 e0       	ldi	r25, 0x01	; 1
    1d22:	8f 93       	push	r24
    1d24:	1f 92       	push	r1
    1d26:	1f 92       	push	r1
    1d28:	1f 92       	push	r1
    1d2a:	1f 92       	push	r1
    1d2c:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1d30:	0f 90       	pop	r0
    1d32:	0f 90       	pop	r0
    1d34:	0f 90       	pop	r0
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	0f 90       	pop	r0
			DELAY_ms(1000);
    1d3c:	88 ee       	ldi	r24, 0xE8	; 232
    1d3e:	93 e0       	ldi	r25, 0x03	; 3
    1d40:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			return;
    1d44:	2a c0       	rjmp	.+84     	; 0x1d9a <SettingsMenu_ShowMenu+0x4e4>
		}
		//discard settings and exit of settings loop
		else if (settingsPage < 0) {
    1d46:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d48:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d4a:	99 23       	and	r25, r25
    1d4c:	2c f5       	brge	.+74     	; 0x1d98 <SettingsMenu_ShowMenu+0x4e2>
			LCDEXPLOITING_SetLctBrightness(settinsgMenu_values->pwmBrightness);
    1d4e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d50:	98 89       	ldd	r25, Y+16	; 0x10
    1d52:	fc 01       	movw	r30, r24
    1d54:	85 81       	ldd	r24, Z+5	; 0x05
    1d56:	96 81       	ldd	r25, Z+6	; 0x06
    1d58:	0e 94 da 02 	call	0x5b4	; 0x5b4 <LCDEXPLOITING_SetLctBrightness>
			LCD_Clear();
    1d5c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
			LCD_SetCursor(0, 0);
    1d60:	60 e0       	ldi	r22, 0x00	; 0
    1d62:	80 e0       	ldi	r24, 0x00	; 0
    1d64:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
			LCD_XYPrintf(0, 0, "Canceled");
    1d68:	81 ed       	ldi	r24, 0xD1	; 209
    1d6a:	91 e0       	ldi	r25, 0x01	; 1
    1d6c:	89 2f       	mov	r24, r25
    1d6e:	8f 93       	push	r24
    1d70:	81 ed       	ldi	r24, 0xD1	; 209
    1d72:	91 e0       	ldi	r25, 0x01	; 1
    1d74:	8f 93       	push	r24
    1d76:	1f 92       	push	r1
    1d78:	1f 92       	push	r1
    1d7a:	1f 92       	push	r1
    1d7c:	1f 92       	push	r1
    1d7e:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    1d82:	0f 90       	pop	r0
    1d84:	0f 90       	pop	r0
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	0f 90       	pop	r0
			DELAY_ms(1000);
    1d8e:	88 ee       	ldi	r24, 0xE8	; 232
    1d90:	93 e0       	ldi	r25, 0x03	; 3
    1d92:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			return;
    1d96:	01 c0       	rjmp	.+2      	; 0x1d9a <SettingsMenu_ShowMenu+0x4e4>
		}

	}
    1d98:	b7 ce       	rjmp	.-658    	; 0x1b08 <SettingsMenu_ShowMenu+0x252>
}
    1d9a:	60 96       	adiw	r28, 0x10	; 16
    1d9c:	0f b6       	in	r0, 0x3f	; 63
    1d9e:	f8 94       	cli
    1da0:	de bf       	out	0x3e, r29	; 62
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	cd bf       	out	0x3d, r28	; 61
    1da6:	df 91       	pop	r29
    1da8:	cf 91       	pop	r28
    1daa:	08 95       	ret

00001dac <SettingsMenu_pressedButton>:

void SettingsMenu_pressedButton(struct SettingsMenu_values *tmpValues,
		int *currentPage) {
    1dac:	cf 93       	push	r28
    1dae:	df 93       	push	r29
    1db0:	00 d0       	rcall	.+0      	; 0x1db2 <SettingsMenu_pressedButton+0x6>
    1db2:	00 d0       	rcall	.+0      	; 0x1db4 <SettingsMenu_pressedButton+0x8>
    1db4:	00 d0       	rcall	.+0      	; 0x1db6 <SettingsMenu_pressedButton+0xa>
    1db6:	cd b7       	in	r28, 0x3d	; 61
    1db8:	de b7       	in	r29, 0x3e	; 62
    1dba:	9c 83       	std	Y+4, r25	; 0x04
    1dbc:	8b 83       	std	Y+3, r24	; 0x03
    1dbe:	7e 83       	std	Y+6, r23	; 0x06
    1dc0:	6d 83       	std	Y+5, r22	; 0x05
	int refreshClock = 0;
    1dc2:	1a 82       	std	Y+2, r1	; 0x02
    1dc4:	19 82       	std	Y+1, r1	; 0x01
	while (1) { //loop of operation
		//execute standby
		if (*currentPage == 1) {
    1dc6:	8d 81       	ldd	r24, Y+5	; 0x05
    1dc8:	9e 81       	ldd	r25, Y+6	; 0x06
    1dca:	fc 01       	movw	r30, r24
    1dcc:	80 81       	ld	r24, Z
    1dce:	91 81       	ldd	r25, Z+1	; 0x01
    1dd0:	81 30       	cpi	r24, 0x01	; 1
    1dd2:	91 05       	cpc	r25, r1
    1dd4:	09 f0       	breq	.+2      	; 0x1dd8 <SettingsMenu_pressedButton+0x2c>
    1dd6:	e3 c0       	rjmp	.+454    	; 0x1f9e <SettingsMenu_pressedButton+0x1f2>
			if (BTN_LEFT) { //if pressed < then change page to last
    1dd8:	86 e3       	ldi	r24, 0x36	; 54
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	fc 01       	movw	r30, r24
    1dde:	80 81       	ld	r24, Z
    1de0:	88 2f       	mov	r24, r24
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	82 70       	andi	r24, 0x02	; 2
    1de6:	99 27       	eor	r25, r25
    1de8:	00 97       	sbiw	r24, 0x00	; 0
    1dea:	99 f4       	brne	.+38     	; 0x1e12 <SettingsMenu_pressedButton+0x66>
				*currentPage = 6;
    1dec:	8d 81       	ldd	r24, Y+5	; 0x05
    1dee:	9e 81       	ldd	r25, Y+6	; 0x06
    1df0:	26 e0       	ldi	r18, 0x06	; 6
    1df2:	30 e0       	ldi	r19, 0x00	; 0
    1df4:	fc 01       	movw	r30, r24
    1df6:	31 83       	std	Z+1, r19	; 0x01
    1df8:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    1dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    1dfe:	fc 01       	movw	r30, r24
    1e00:	81 85       	ldd	r24, Z+9	; 0x09
    1e02:	92 85       	ldd	r25, Z+10	; 0x0a
    1e04:	88 0f       	add	r24, r24
    1e06:	99 1f       	adc	r25, r25
    1e08:	88 0f       	add	r24, r24
    1e0a:	99 1f       	adc	r25, r25
    1e0c:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    1e10:	d4 c4       	rjmp	.+2472   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_RIGHT) { //if pressed > then change to next page
    1e12:	86 e3       	ldi	r24, 0x36	; 54
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	fc 01       	movw	r30, r24
    1e18:	80 81       	ld	r24, Z
    1e1a:	88 2f       	mov	r24, r24
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	81 70       	andi	r24, 0x01	; 1
    1e20:	99 27       	eor	r25, r25
    1e22:	00 97       	sbiw	r24, 0x00	; 0
    1e24:	99 f4       	brne	.+38     	; 0x1e4c <SettingsMenu_pressedButton+0xa0>
				*currentPage = 2;
    1e26:	8d 81       	ldd	r24, Y+5	; 0x05
    1e28:	9e 81       	ldd	r25, Y+6	; 0x06
    1e2a:	22 e0       	ldi	r18, 0x02	; 2
    1e2c:	30 e0       	ldi	r19, 0x00	; 0
    1e2e:	fc 01       	movw	r30, r24
    1e30:	31 83       	std	Z+1, r19	; 0x01
    1e32:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    1e34:	8b 81       	ldd	r24, Y+3	; 0x03
    1e36:	9c 81       	ldd	r25, Y+4	; 0x04
    1e38:	fc 01       	movw	r30, r24
    1e3a:	81 85       	ldd	r24, Z+9	; 0x09
    1e3c:	92 85       	ldd	r25, Z+10	; 0x0a
    1e3e:	88 0f       	add	r24, r24
    1e40:	99 1f       	adc	r25, r25
    1e42:	88 0f       	add	r24, r24
    1e44:	99 1f       	adc	r25, r25
    1e46:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    1e4a:	b7 c4       	rjmp	.+2414   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_1) { //if pressed save button then change value of current page more than 100 and exit (go to save statement)
    1e4c:	86 e3       	ldi	r24, 0x36	; 54
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	fc 01       	movw	r30, r24
    1e52:	80 81       	ld	r24, Z
    1e54:	88 2f       	mov	r24, r24
    1e56:	90 e0       	ldi	r25, 0x00	; 0
    1e58:	84 70       	andi	r24, 0x04	; 4
    1e5a:	99 27       	eor	r25, r25
    1e5c:	00 97       	sbiw	r24, 0x00	; 0
    1e5e:	99 f4       	brne	.+38     	; 0x1e86 <SettingsMenu_pressedButton+0xda>
				*currentPage = 150;
    1e60:	8d 81       	ldd	r24, Y+5	; 0x05
    1e62:	9e 81       	ldd	r25, Y+6	; 0x06
    1e64:	26 e9       	ldi	r18, 0x96	; 150
    1e66:	30 e0       	ldi	r19, 0x00	; 0
    1e68:	fc 01       	movw	r30, r24
    1e6a:	31 83       	std	Z+1, r19	; 0x01
    1e6c:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    1e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e70:	9c 81       	ldd	r25, Y+4	; 0x04
    1e72:	fc 01       	movw	r30, r24
    1e74:	81 85       	ldd	r24, Z+9	; 0x09
    1e76:	92 85       	ldd	r25, Z+10	; 0x0a
    1e78:	88 0f       	add	r24, r24
    1e7a:	99 1f       	adc	r25, r25
    1e7c:	88 0f       	add	r24, r24
    1e7e:	99 1f       	adc	r25, r25
    1e80:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    1e84:	9a c4       	rjmp	.+2356   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_2) { //if pressed discard button then change value of current page under 0 and exit (go to discard statement)
    1e86:	86 e3       	ldi	r24, 0x36	; 54
    1e88:	90 e0       	ldi	r25, 0x00	; 0
    1e8a:	fc 01       	movw	r30, r24
    1e8c:	80 81       	ld	r24, Z
    1e8e:	88 2f       	mov	r24, r24
    1e90:	90 e0       	ldi	r25, 0x00	; 0
    1e92:	88 70       	andi	r24, 0x08	; 8
    1e94:	99 27       	eor	r25, r25
    1e96:	00 97       	sbiw	r24, 0x00	; 0
    1e98:	99 f4       	brne	.+38     	; 0x1ec0 <SettingsMenu_pressedButton+0x114>
				*currentPage = -10;
    1e9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1e9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1e9e:	26 ef       	ldi	r18, 0xF6	; 246
    1ea0:	3f ef       	ldi	r19, 0xFF	; 255
    1ea2:	fc 01       	movw	r30, r24
    1ea4:	31 83       	std	Z+1, r19	; 0x01
    1ea6:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    1ea8:	8b 81       	ldd	r24, Y+3	; 0x03
    1eaa:	9c 81       	ldd	r25, Y+4	; 0x04
    1eac:	fc 01       	movw	r30, r24
    1eae:	81 85       	ldd	r24, Z+9	; 0x09
    1eb0:	92 85       	ldd	r25, Z+10	; 0x0a
    1eb2:	88 0f       	add	r24, r24
    1eb4:	99 1f       	adc	r25, r25
    1eb6:	88 0f       	add	r24, r24
    1eb8:	99 1f       	adc	r25, r25
    1eba:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    1ebe:	7d c4       	rjmp	.+2298   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_3 || BTN_4) {  //standby
    1ec0:	86 e3       	ldi	r24, 0x36	; 54
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	fc 01       	movw	r30, r24
    1ec6:	80 81       	ld	r24, Z
    1ec8:	88 2f       	mov	r24, r24
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	80 71       	andi	r24, 0x10	; 16
    1ece:	99 27       	eor	r25, r25
    1ed0:	00 97       	sbiw	r24, 0x00	; 0
    1ed2:	59 f0       	breq	.+22     	; 0x1eea <SettingsMenu_pressedButton+0x13e>
    1ed4:	86 e3       	ldi	r24, 0x36	; 54
    1ed6:	90 e0       	ldi	r25, 0x00	; 0
    1ed8:	fc 01       	movw	r30, r24
    1eda:	80 81       	ld	r24, Z
    1edc:	88 2f       	mov	r24, r24
    1ede:	90 e0       	ldi	r25, 0x00	; 0
    1ee0:	80 72       	andi	r24, 0x20	; 32
    1ee2:	99 27       	eor	r25, r25
    1ee4:	00 97       	sbiw	r24, 0x00	; 0
    1ee6:	09 f0       	breq	.+2      	; 0x1eea <SettingsMenu_pressedButton+0x13e>
    1ee8:	5a c0       	rjmp	.+180    	; 0x1f9e <SettingsMenu_pressedButton+0x1f2>
				LedControl_OFF(0); //turn off notification led
    1eea:	80 e0       	ldi	r24, 0x00	; 0
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
				LCD_Clear(); //clear screen
    1ef2:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
				LCDEXPLOITING_SetLctBrightness(0); //turn off lcd light
    1ef6:	80 e0       	ldi	r24, 0x00	; 0
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	0e 94 da 02 	call	0x5b4	; 0x5b4 <LCDEXPLOITING_SetLctBrightness>
				DELAY_ms(1000);
    1efe:	88 ee       	ldi	r24, 0xE8	; 232
    1f00:	93 e0       	ldi	r25, 0x03	; 3
    1f02:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				while (1)
					if (BTN_1 || BTN_2 || BTN_3 || BTN_4 || BTN_LEFT
    1f06:	86 e3       	ldi	r24, 0x36	; 54
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	fc 01       	movw	r30, r24
    1f0c:	80 81       	ld	r24, Z
    1f0e:	88 2f       	mov	r24, r24
    1f10:	90 e0       	ldi	r25, 0x00	; 0
    1f12:	84 70       	andi	r24, 0x04	; 4
    1f14:	99 27       	eor	r25, r25
    1f16:	00 97       	sbiw	r24, 0x00	; 0
    1f18:	99 f1       	breq	.+102    	; 0x1f80 <SettingsMenu_pressedButton+0x1d4>
    1f1a:	86 e3       	ldi	r24, 0x36	; 54
    1f1c:	90 e0       	ldi	r25, 0x00	; 0
    1f1e:	fc 01       	movw	r30, r24
    1f20:	80 81       	ld	r24, Z
    1f22:	88 2f       	mov	r24, r24
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	88 70       	andi	r24, 0x08	; 8
    1f28:	99 27       	eor	r25, r25
    1f2a:	00 97       	sbiw	r24, 0x00	; 0
    1f2c:	49 f1       	breq	.+82     	; 0x1f80 <SettingsMenu_pressedButton+0x1d4>
    1f2e:	86 e3       	ldi	r24, 0x36	; 54
    1f30:	90 e0       	ldi	r25, 0x00	; 0
    1f32:	fc 01       	movw	r30, r24
    1f34:	80 81       	ld	r24, Z
    1f36:	88 2f       	mov	r24, r24
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	80 71       	andi	r24, 0x10	; 16
    1f3c:	99 27       	eor	r25, r25
    1f3e:	00 97       	sbiw	r24, 0x00	; 0
    1f40:	f9 f0       	breq	.+62     	; 0x1f80 <SettingsMenu_pressedButton+0x1d4>
    1f42:	86 e3       	ldi	r24, 0x36	; 54
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	fc 01       	movw	r30, r24
    1f48:	80 81       	ld	r24, Z
    1f4a:	88 2f       	mov	r24, r24
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
    1f4e:	80 72       	andi	r24, 0x20	; 32
    1f50:	99 27       	eor	r25, r25
    1f52:	00 97       	sbiw	r24, 0x00	; 0
    1f54:	a9 f0       	breq	.+42     	; 0x1f80 <SettingsMenu_pressedButton+0x1d4>
    1f56:	86 e3       	ldi	r24, 0x36	; 54
    1f58:	90 e0       	ldi	r25, 0x00	; 0
    1f5a:	fc 01       	movw	r30, r24
    1f5c:	80 81       	ld	r24, Z
    1f5e:	88 2f       	mov	r24, r24
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	82 70       	andi	r24, 0x02	; 2
    1f64:	99 27       	eor	r25, r25
    1f66:	00 97       	sbiw	r24, 0x00	; 0
    1f68:	59 f0       	breq	.+22     	; 0x1f80 <SettingsMenu_pressedButton+0x1d4>
							|| BTN_RIGHT)
    1f6a:	86 e3       	ldi	r24, 0x36	; 54
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	fc 01       	movw	r30, r24
    1f70:	80 81       	ld	r24, Z
    1f72:	88 2f       	mov	r24, r24
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	81 70       	andi	r24, 0x01	; 1
    1f78:	99 27       	eor	r25, r25
    1f7a:	00 97       	sbiw	r24, 0x00	; 0
    1f7c:	09 f0       	breq	.+2      	; 0x1f80 <SettingsMenu_pressedButton+0x1d4>
						break; //if press any button then exit of standby
				DELAY_ms(500);
    1f7e:	c3 cf       	rjmp	.-122    	; 0x1f06 <SettingsMenu_pressedButton+0x15a>
    1f80:	84 ef       	ldi	r24, 0xF4	; 244
    1f82:	91 e0       	ldi	r25, 0x01	; 1
    1f84:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				LCDEXPLOITING_SetLctBrightness(tmpValues->pwmBrightness); //set lcd light to previous value
    1f88:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8c:	fc 01       	movw	r30, r24
    1f8e:	85 81       	ldd	r24, Z+5	; 0x05
    1f90:	96 81       	ldd	r25, Z+6	; 0x06
    1f92:	0e 94 da 02 	call	0x5b4	; 0x5b4 <LCDEXPLOITING_SetLctBrightness>
				SettingsMenu_PrintLabel("Standby"); //draw on lcd gui
    1f96:	83 e8       	ldi	r24, 0x83	; 131
    1f98:	91 e0       	ldi	r25, 0x01	; 1
    1f9a:	0e 94 af 14 	call	0x295e	; 0x295e <SettingsMenu_PrintLabel>
			}
		}
		//execute brightness
		if (*currentPage == 2) {
    1f9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1fa0:	9e 81       	ldd	r25, Y+6	; 0x06
    1fa2:	fc 01       	movw	r30, r24
    1fa4:	80 81       	ld	r24, Z
    1fa6:	91 81       	ldd	r25, Z+1	; 0x01
    1fa8:	82 30       	cpi	r24, 0x02	; 2
    1faa:	91 05       	cpc	r25, r1
    1fac:	09 f0       	breq	.+2      	; 0x1fb0 <SettingsMenu_pressedButton+0x204>
    1fae:	f5 c0       	rjmp	.+490    	; 0x219a <SettingsMenu_pressedButton+0x3ee>
			if (BTN_LEFT) {  //if pressed < then change to last page
    1fb0:	86 e3       	ldi	r24, 0x36	; 54
    1fb2:	90 e0       	ldi	r25, 0x00	; 0
    1fb4:	fc 01       	movw	r30, r24
    1fb6:	80 81       	ld	r24, Z
    1fb8:	88 2f       	mov	r24, r24
    1fba:	90 e0       	ldi	r25, 0x00	; 0
    1fbc:	82 70       	andi	r24, 0x02	; 2
    1fbe:	99 27       	eor	r25, r25
    1fc0:	00 97       	sbiw	r24, 0x00	; 0
    1fc2:	99 f4       	brne	.+38     	; 0x1fea <SettingsMenu_pressedButton+0x23e>
				*currentPage = 1;
    1fc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc6:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc8:	21 e0       	ldi	r18, 0x01	; 1
    1fca:	30 e0       	ldi	r19, 0x00	; 0
    1fcc:	fc 01       	movw	r30, r24
    1fce:	31 83       	std	Z+1, r19	; 0x01
    1fd0:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    1fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fd6:	fc 01       	movw	r30, r24
    1fd8:	81 85       	ldd	r24, Z+9	; 0x09
    1fda:	92 85       	ldd	r25, Z+10	; 0x0a
    1fdc:	88 0f       	add	r24, r24
    1fde:	99 1f       	adc	r25, r25
    1fe0:	88 0f       	add	r24, r24
    1fe2:	99 1f       	adc	r25, r25
    1fe4:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    1fe8:	e8 c3       	rjmp	.+2000   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_RIGHT) { //if pressed > then change to next page
    1fea:	86 e3       	ldi	r24, 0x36	; 54
    1fec:	90 e0       	ldi	r25, 0x00	; 0
    1fee:	fc 01       	movw	r30, r24
    1ff0:	80 81       	ld	r24, Z
    1ff2:	88 2f       	mov	r24, r24
    1ff4:	90 e0       	ldi	r25, 0x00	; 0
    1ff6:	81 70       	andi	r24, 0x01	; 1
    1ff8:	99 27       	eor	r25, r25
    1ffa:	00 97       	sbiw	r24, 0x00	; 0
    1ffc:	99 f4       	brne	.+38     	; 0x2024 <SettingsMenu_pressedButton+0x278>
				*currentPage = 3;
    1ffe:	8d 81       	ldd	r24, Y+5	; 0x05
    2000:	9e 81       	ldd	r25, Y+6	; 0x06
    2002:	23 e0       	ldi	r18, 0x03	; 3
    2004:	30 e0       	ldi	r19, 0x00	; 0
    2006:	fc 01       	movw	r30, r24
    2008:	31 83       	std	Z+1, r19	; 0x01
    200a:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    200c:	8b 81       	ldd	r24, Y+3	; 0x03
    200e:	9c 81       	ldd	r25, Y+4	; 0x04
    2010:	fc 01       	movw	r30, r24
    2012:	81 85       	ldd	r24, Z+9	; 0x09
    2014:	92 85       	ldd	r25, Z+10	; 0x0a
    2016:	88 0f       	add	r24, r24
    2018:	99 1f       	adc	r25, r25
    201a:	88 0f       	add	r24, r24
    201c:	99 1f       	adc	r25, r25
    201e:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2022:	cb c3       	rjmp	.+1942   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_1) { //if pressed save button then change value of current page more than 100 and exit (go to save statement)
    2024:	86 e3       	ldi	r24, 0x36	; 54
    2026:	90 e0       	ldi	r25, 0x00	; 0
    2028:	fc 01       	movw	r30, r24
    202a:	80 81       	ld	r24, Z
    202c:	88 2f       	mov	r24, r24
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	84 70       	andi	r24, 0x04	; 4
    2032:	99 27       	eor	r25, r25
    2034:	00 97       	sbiw	r24, 0x00	; 0
    2036:	99 f4       	brne	.+38     	; 0x205e <SettingsMenu_pressedButton+0x2b2>
				*currentPage = 150;
    2038:	8d 81       	ldd	r24, Y+5	; 0x05
    203a:	9e 81       	ldd	r25, Y+6	; 0x06
    203c:	26 e9       	ldi	r18, 0x96	; 150
    203e:	30 e0       	ldi	r19, 0x00	; 0
    2040:	fc 01       	movw	r30, r24
    2042:	31 83       	std	Z+1, r19	; 0x01
    2044:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    2046:	8b 81       	ldd	r24, Y+3	; 0x03
    2048:	9c 81       	ldd	r25, Y+4	; 0x04
    204a:	fc 01       	movw	r30, r24
    204c:	81 85       	ldd	r24, Z+9	; 0x09
    204e:	92 85       	ldd	r25, Z+10	; 0x0a
    2050:	88 0f       	add	r24, r24
    2052:	99 1f       	adc	r25, r25
    2054:	88 0f       	add	r24, r24
    2056:	99 1f       	adc	r25, r25
    2058:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    205c:	ae c3       	rjmp	.+1884   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_2) { //if pressed discard button then change value of current page under 0 and exit (go to discard statement)
    205e:	86 e3       	ldi	r24, 0x36	; 54
    2060:	90 e0       	ldi	r25, 0x00	; 0
    2062:	fc 01       	movw	r30, r24
    2064:	80 81       	ld	r24, Z
    2066:	88 2f       	mov	r24, r24
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	88 70       	andi	r24, 0x08	; 8
    206c:	99 27       	eor	r25, r25
    206e:	00 97       	sbiw	r24, 0x00	; 0
    2070:	99 f4       	brne	.+38     	; 0x2098 <SettingsMenu_pressedButton+0x2ec>
				*currentPage = -10;
    2072:	8d 81       	ldd	r24, Y+5	; 0x05
    2074:	9e 81       	ldd	r25, Y+6	; 0x06
    2076:	26 ef       	ldi	r18, 0xF6	; 246
    2078:	3f ef       	ldi	r19, 0xFF	; 255
    207a:	fc 01       	movw	r30, r24
    207c:	31 83       	std	Z+1, r19	; 0x01
    207e:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    2080:	8b 81       	ldd	r24, Y+3	; 0x03
    2082:	9c 81       	ldd	r25, Y+4	; 0x04
    2084:	fc 01       	movw	r30, r24
    2086:	81 85       	ldd	r24, Z+9	; 0x09
    2088:	92 85       	ldd	r25, Z+10	; 0x0a
    208a:	88 0f       	add	r24, r24
    208c:	99 1f       	adc	r25, r25
    208e:	88 0f       	add	r24, r24
    2090:	99 1f       	adc	r25, r25
    2092:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2096:	91 c3       	rjmp	.+1826   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_3 && tmpValues->pwmBrightness > 0) { //brightness-
    2098:	86 e3       	ldi	r24, 0x36	; 54
    209a:	90 e0       	ldi	r25, 0x00	; 0
    209c:	fc 01       	movw	r30, r24
    209e:	80 81       	ld	r24, Z
    20a0:	88 2f       	mov	r24, r24
    20a2:	90 e0       	ldi	r25, 0x00	; 0
    20a4:	80 71       	andi	r24, 0x10	; 16
    20a6:	99 27       	eor	r25, r25
    20a8:	00 97       	sbiw	r24, 0x00	; 0
    20aa:	a9 f5       	brne	.+106    	; 0x2116 <SettingsMenu_pressedButton+0x36a>
    20ac:	8b 81       	ldd	r24, Y+3	; 0x03
    20ae:	9c 81       	ldd	r25, Y+4	; 0x04
    20b0:	fc 01       	movw	r30, r24
    20b2:	85 81       	ldd	r24, Z+5	; 0x05
    20b4:	96 81       	ldd	r25, Z+6	; 0x06
    20b6:	18 16       	cp	r1, r24
    20b8:	19 06       	cpc	r1, r25
    20ba:	6c f5       	brge	.+90     	; 0x2116 <SettingsMenu_pressedButton+0x36a>
				tmpValues->pwmBrightness -= 10;
    20bc:	8b 81       	ldd	r24, Y+3	; 0x03
    20be:	9c 81       	ldd	r25, Y+4	; 0x04
    20c0:	fc 01       	movw	r30, r24
    20c2:	85 81       	ldd	r24, Z+5	; 0x05
    20c4:	96 81       	ldd	r25, Z+6	; 0x06
    20c6:	9c 01       	movw	r18, r24
    20c8:	2a 50       	subi	r18, 0x0A	; 10
    20ca:	31 09       	sbc	r19, r1
    20cc:	8b 81       	ldd	r24, Y+3	; 0x03
    20ce:	9c 81       	ldd	r25, Y+4	; 0x04
    20d0:	fc 01       	movw	r30, r24
    20d2:	36 83       	std	Z+6, r19	; 0x06
    20d4:	25 83       	std	Z+5, r18	; 0x05
				if (tmpValues->pwmBrightness < 0)
    20d6:	8b 81       	ldd	r24, Y+3	; 0x03
    20d8:	9c 81       	ldd	r25, Y+4	; 0x04
    20da:	fc 01       	movw	r30, r24
    20dc:	85 81       	ldd	r24, Z+5	; 0x05
    20de:	96 81       	ldd	r25, Z+6	; 0x06
    20e0:	99 23       	and	r25, r25
    20e2:	2c f4       	brge	.+10     	; 0x20ee <SettingsMenu_pressedButton+0x342>
					tmpValues->pwmBrightness = 0;
    20e4:	8b 81       	ldd	r24, Y+3	; 0x03
    20e6:	9c 81       	ldd	r25, Y+4	; 0x04
    20e8:	fc 01       	movw	r30, r24
    20ea:	16 82       	std	Z+6, r1	; 0x06
    20ec:	15 82       	std	Z+5, r1	; 0x05
				LCDEXPLOITING_SetLctBrightness(tmpValues->pwmBrightness);
    20ee:	8b 81       	ldd	r24, Y+3	; 0x03
    20f0:	9c 81       	ldd	r25, Y+4	; 0x04
    20f2:	fc 01       	movw	r30, r24
    20f4:	85 81       	ldd	r24, Z+5	; 0x05
    20f6:	96 81       	ldd	r25, Z+6	; 0x06
    20f8:	0e 94 da 02 	call	0x5b4	; 0x5b4 <LCDEXPLOITING_SetLctBrightness>
				SettingsMenu_PrintValue(tmpValues->pwmBrightness, "Brightness");
    20fc:	8b 81       	ldd	r24, Y+3	; 0x03
    20fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2100:	fc 01       	movw	r30, r24
    2102:	85 81       	ldd	r24, Z+5	; 0x05
    2104:	96 81       	ldd	r25, Z+6	; 0x06
    2106:	6b e8       	ldi	r22, 0x8B	; 139
    2108:	71 e0       	ldi	r23, 0x01	; 1
    210a:	0e 94 56 14 	call	0x28ac	; 0x28ac <SettingsMenu_PrintValue>
				DELAY_ms(200);
    210e:	88 ec       	ldi	r24, 0xC8	; 200
    2110:	90 e0       	ldi	r25, 0x00	; 0
    2112:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
			if (BTN_4 && tmpValues->pwmBrightness < 100) { //brightness+
    2116:	86 e3       	ldi	r24, 0x36	; 54
    2118:	90 e0       	ldi	r25, 0x00	; 0
    211a:	fc 01       	movw	r30, r24
    211c:	80 81       	ld	r24, Z
    211e:	88 2f       	mov	r24, r24
    2120:	90 e0       	ldi	r25, 0x00	; 0
    2122:	80 72       	andi	r24, 0x20	; 32
    2124:	99 27       	eor	r25, r25
    2126:	00 97       	sbiw	r24, 0x00	; 0
    2128:	c1 f5       	brne	.+112    	; 0x219a <SettingsMenu_pressedButton+0x3ee>
    212a:	8b 81       	ldd	r24, Y+3	; 0x03
    212c:	9c 81       	ldd	r25, Y+4	; 0x04
    212e:	fc 01       	movw	r30, r24
    2130:	85 81       	ldd	r24, Z+5	; 0x05
    2132:	96 81       	ldd	r25, Z+6	; 0x06
    2134:	84 36       	cpi	r24, 0x64	; 100
    2136:	91 05       	cpc	r25, r1
    2138:	84 f5       	brge	.+96     	; 0x219a <SettingsMenu_pressedButton+0x3ee>
				tmpValues->pwmBrightness += 10;
    213a:	8b 81       	ldd	r24, Y+3	; 0x03
    213c:	9c 81       	ldd	r25, Y+4	; 0x04
    213e:	fc 01       	movw	r30, r24
    2140:	85 81       	ldd	r24, Z+5	; 0x05
    2142:	96 81       	ldd	r25, Z+6	; 0x06
    2144:	9c 01       	movw	r18, r24
    2146:	26 5f       	subi	r18, 0xF6	; 246
    2148:	3f 4f       	sbci	r19, 0xFF	; 255
    214a:	8b 81       	ldd	r24, Y+3	; 0x03
    214c:	9c 81       	ldd	r25, Y+4	; 0x04
    214e:	fc 01       	movw	r30, r24
    2150:	36 83       	std	Z+6, r19	; 0x06
    2152:	25 83       	std	Z+5, r18	; 0x05
				if (tmpValues->pwmBrightness > 100)
    2154:	8b 81       	ldd	r24, Y+3	; 0x03
    2156:	9c 81       	ldd	r25, Y+4	; 0x04
    2158:	fc 01       	movw	r30, r24
    215a:	85 81       	ldd	r24, Z+5	; 0x05
    215c:	96 81       	ldd	r25, Z+6	; 0x06
    215e:	85 36       	cpi	r24, 0x65	; 101
    2160:	91 05       	cpc	r25, r1
    2162:	3c f0       	brlt	.+14     	; 0x2172 <SettingsMenu_pressedButton+0x3c6>
					tmpValues->pwmBrightness = 100;
    2164:	8b 81       	ldd	r24, Y+3	; 0x03
    2166:	9c 81       	ldd	r25, Y+4	; 0x04
    2168:	24 e6       	ldi	r18, 0x64	; 100
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	fc 01       	movw	r30, r24
    216e:	36 83       	std	Z+6, r19	; 0x06
    2170:	25 83       	std	Z+5, r18	; 0x05
				LCDEXPLOITING_SetLctBrightness(tmpValues->pwmBrightness);
    2172:	8b 81       	ldd	r24, Y+3	; 0x03
    2174:	9c 81       	ldd	r25, Y+4	; 0x04
    2176:	fc 01       	movw	r30, r24
    2178:	85 81       	ldd	r24, Z+5	; 0x05
    217a:	96 81       	ldd	r25, Z+6	; 0x06
    217c:	0e 94 da 02 	call	0x5b4	; 0x5b4 <LCDEXPLOITING_SetLctBrightness>
				SettingsMenu_PrintValue(tmpValues->pwmBrightness, "Brightness");
    2180:	8b 81       	ldd	r24, Y+3	; 0x03
    2182:	9c 81       	ldd	r25, Y+4	; 0x04
    2184:	fc 01       	movw	r30, r24
    2186:	85 81       	ldd	r24, Z+5	; 0x05
    2188:	96 81       	ldd	r25, Z+6	; 0x06
    218a:	6b e8       	ldi	r22, 0x8B	; 139
    218c:	71 e0       	ldi	r23, 0x01	; 1
    218e:	0e 94 56 14 	call	0x28ac	; 0x28ac <SettingsMenu_PrintValue>
				DELAY_ms(200);
    2192:	88 ec       	ldi	r24, 0xC8	; 200
    2194:	90 e0       	ldi	r25, 0x00	; 0
    2196:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
		}
		//execute led status
		if (*currentPage == 3) {
    219a:	8d 81       	ldd	r24, Y+5	; 0x05
    219c:	9e 81       	ldd	r25, Y+6	; 0x06
    219e:	fc 01       	movw	r30, r24
    21a0:	80 81       	ld	r24, Z
    21a2:	91 81       	ldd	r25, Z+1	; 0x01
    21a4:	83 30       	cpi	r24, 0x03	; 3
    21a6:	91 05       	cpc	r25, r1
    21a8:	09 f0       	breq	.+2      	; 0x21ac <SettingsMenu_pressedButton+0x400>
    21aa:	a9 c0       	rjmp	.+338    	; 0x22fe <SettingsMenu_pressedButton+0x552>
			if (BTN_LEFT) { //if pressed < then change to last page
    21ac:	86 e3       	ldi	r24, 0x36	; 54
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	fc 01       	movw	r30, r24
    21b2:	80 81       	ld	r24, Z
    21b4:	88 2f       	mov	r24, r24
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	82 70       	andi	r24, 0x02	; 2
    21ba:	99 27       	eor	r25, r25
    21bc:	00 97       	sbiw	r24, 0x00	; 0
    21be:	99 f4       	brne	.+38     	; 0x21e6 <SettingsMenu_pressedButton+0x43a>
				*currentPage = 2;
    21c0:	8d 81       	ldd	r24, Y+5	; 0x05
    21c2:	9e 81       	ldd	r25, Y+6	; 0x06
    21c4:	22 e0       	ldi	r18, 0x02	; 2
    21c6:	30 e0       	ldi	r19, 0x00	; 0
    21c8:	fc 01       	movw	r30, r24
    21ca:	31 83       	std	Z+1, r19	; 0x01
    21cc:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    21ce:	8b 81       	ldd	r24, Y+3	; 0x03
    21d0:	9c 81       	ldd	r25, Y+4	; 0x04
    21d2:	fc 01       	movw	r30, r24
    21d4:	81 85       	ldd	r24, Z+9	; 0x09
    21d6:	92 85       	ldd	r25, Z+10	; 0x0a
    21d8:	88 0f       	add	r24, r24
    21da:	99 1f       	adc	r25, r25
    21dc:	88 0f       	add	r24, r24
    21de:	99 1f       	adc	r25, r25
    21e0:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    21e4:	ea c2       	rjmp	.+1492   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_RIGHT) { //if pressed > then change to next page
    21e6:	86 e3       	ldi	r24, 0x36	; 54
    21e8:	90 e0       	ldi	r25, 0x00	; 0
    21ea:	fc 01       	movw	r30, r24
    21ec:	80 81       	ld	r24, Z
    21ee:	88 2f       	mov	r24, r24
    21f0:	90 e0       	ldi	r25, 0x00	; 0
    21f2:	81 70       	andi	r24, 0x01	; 1
    21f4:	99 27       	eor	r25, r25
    21f6:	00 97       	sbiw	r24, 0x00	; 0
    21f8:	99 f4       	brne	.+38     	; 0x2220 <SettingsMenu_pressedButton+0x474>
				*currentPage = 4;
    21fa:	8d 81       	ldd	r24, Y+5	; 0x05
    21fc:	9e 81       	ldd	r25, Y+6	; 0x06
    21fe:	24 e0       	ldi	r18, 0x04	; 4
    2200:	30 e0       	ldi	r19, 0x00	; 0
    2202:	fc 01       	movw	r30, r24
    2204:	31 83       	std	Z+1, r19	; 0x01
    2206:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    2208:	8b 81       	ldd	r24, Y+3	; 0x03
    220a:	9c 81       	ldd	r25, Y+4	; 0x04
    220c:	fc 01       	movw	r30, r24
    220e:	81 85       	ldd	r24, Z+9	; 0x09
    2210:	92 85       	ldd	r25, Z+10	; 0x0a
    2212:	88 0f       	add	r24, r24
    2214:	99 1f       	adc	r25, r25
    2216:	88 0f       	add	r24, r24
    2218:	99 1f       	adc	r25, r25
    221a:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    221e:	cd c2       	rjmp	.+1434   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_1) { //if pressed save button then change value of current page more than 100 and exit (go to save statement)
    2220:	86 e3       	ldi	r24, 0x36	; 54
    2222:	90 e0       	ldi	r25, 0x00	; 0
    2224:	fc 01       	movw	r30, r24
    2226:	80 81       	ld	r24, Z
    2228:	88 2f       	mov	r24, r24
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	84 70       	andi	r24, 0x04	; 4
    222e:	99 27       	eor	r25, r25
    2230:	00 97       	sbiw	r24, 0x00	; 0
    2232:	99 f4       	brne	.+38     	; 0x225a <SettingsMenu_pressedButton+0x4ae>
				*currentPage = 150;
    2234:	8d 81       	ldd	r24, Y+5	; 0x05
    2236:	9e 81       	ldd	r25, Y+6	; 0x06
    2238:	26 e9       	ldi	r18, 0x96	; 150
    223a:	30 e0       	ldi	r19, 0x00	; 0
    223c:	fc 01       	movw	r30, r24
    223e:	31 83       	std	Z+1, r19	; 0x01
    2240:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    2242:	8b 81       	ldd	r24, Y+3	; 0x03
    2244:	9c 81       	ldd	r25, Y+4	; 0x04
    2246:	fc 01       	movw	r30, r24
    2248:	81 85       	ldd	r24, Z+9	; 0x09
    224a:	92 85       	ldd	r25, Z+10	; 0x0a
    224c:	88 0f       	add	r24, r24
    224e:	99 1f       	adc	r25, r25
    2250:	88 0f       	add	r24, r24
    2252:	99 1f       	adc	r25, r25
    2254:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2258:	b0 c2       	rjmp	.+1376   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_2) { //if pressed discard button then change value of current page under 0 and exit (go to discard statement)
    225a:	86 e3       	ldi	r24, 0x36	; 54
    225c:	90 e0       	ldi	r25, 0x00	; 0
    225e:	fc 01       	movw	r30, r24
    2260:	80 81       	ld	r24, Z
    2262:	88 2f       	mov	r24, r24
    2264:	90 e0       	ldi	r25, 0x00	; 0
    2266:	88 70       	andi	r24, 0x08	; 8
    2268:	99 27       	eor	r25, r25
    226a:	00 97       	sbiw	r24, 0x00	; 0
    226c:	99 f4       	brne	.+38     	; 0x2294 <SettingsMenu_pressedButton+0x4e8>
				*currentPage = -10;
    226e:	8d 81       	ldd	r24, Y+5	; 0x05
    2270:	9e 81       	ldd	r25, Y+6	; 0x06
    2272:	26 ef       	ldi	r18, 0xF6	; 246
    2274:	3f ef       	ldi	r19, 0xFF	; 255
    2276:	fc 01       	movw	r30, r24
    2278:	31 83       	std	Z+1, r19	; 0x01
    227a:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    227c:	8b 81       	ldd	r24, Y+3	; 0x03
    227e:	9c 81       	ldd	r25, Y+4	; 0x04
    2280:	fc 01       	movw	r30, r24
    2282:	81 85       	ldd	r24, Z+9	; 0x09
    2284:	92 85       	ldd	r25, Z+10	; 0x0a
    2286:	88 0f       	add	r24, r24
    2288:	99 1f       	adc	r25, r25
    228a:	88 0f       	add	r24, r24
    228c:	99 1f       	adc	r25, r25
    228e:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2292:	93 c2       	rjmp	.+1318   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_3) { //led off
    2294:	86 e3       	ldi	r24, 0x36	; 54
    2296:	90 e0       	ldi	r25, 0x00	; 0
    2298:	fc 01       	movw	r30, r24
    229a:	80 81       	ld	r24, Z
    229c:	88 2f       	mov	r24, r24
    229e:	90 e0       	ldi	r25, 0x00	; 0
    22a0:	80 71       	andi	r24, 0x10	; 16
    22a2:	99 27       	eor	r25, r25
    22a4:	00 97       	sbiw	r24, 0x00	; 0
    22a6:	81 f4       	brne	.+32     	; 0x22c8 <SettingsMenu_pressedButton+0x51c>
				tmpValues->ledStatus = false;
    22a8:	8b 81       	ldd	r24, Y+3	; 0x03
    22aa:	9c 81       	ldd	r25, Y+4	; 0x04
    22ac:	fc 01       	movw	r30, r24
    22ae:	17 82       	std	Z+7, r1	; 0x07
				SettingsMenu_PrintBoolean(tmpValues->ledStatus, "Led info");
    22b0:	8b 81       	ldd	r24, Y+3	; 0x03
    22b2:	9c 81       	ldd	r25, Y+4	; 0x04
    22b4:	fc 01       	movw	r30, r24
    22b6:	87 81       	ldd	r24, Z+7	; 0x07
    22b8:	66 e9       	ldi	r22, 0x96	; 150
    22ba:	71 e0       	ldi	r23, 0x01	; 1
    22bc:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
				DELAY_ms(200);
    22c0:	88 ec       	ldi	r24, 0xC8	; 200
    22c2:	90 e0       	ldi	r25, 0x00	; 0
    22c4:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
			if (BTN_4) { //led on
    22c8:	86 e3       	ldi	r24, 0x36	; 54
    22ca:	90 e0       	ldi	r25, 0x00	; 0
    22cc:	fc 01       	movw	r30, r24
    22ce:	80 81       	ld	r24, Z
    22d0:	88 2f       	mov	r24, r24
    22d2:	90 e0       	ldi	r25, 0x00	; 0
    22d4:	80 72       	andi	r24, 0x20	; 32
    22d6:	99 27       	eor	r25, r25
    22d8:	00 97       	sbiw	r24, 0x00	; 0
    22da:	89 f4       	brne	.+34     	; 0x22fe <SettingsMenu_pressedButton+0x552>
				tmpValues->ledStatus = true;
    22dc:	8b 81       	ldd	r24, Y+3	; 0x03
    22de:	9c 81       	ldd	r25, Y+4	; 0x04
    22e0:	21 e0       	ldi	r18, 0x01	; 1
    22e2:	fc 01       	movw	r30, r24
    22e4:	27 83       	std	Z+7, r18	; 0x07
				SettingsMenu_PrintBoolean(tmpValues->ledStatus, "Led info");
    22e6:	8b 81       	ldd	r24, Y+3	; 0x03
    22e8:	9c 81       	ldd	r25, Y+4	; 0x04
    22ea:	fc 01       	movw	r30, r24
    22ec:	87 81       	ldd	r24, Z+7	; 0x07
    22ee:	66 e9       	ldi	r22, 0x96	; 150
    22f0:	71 e0       	ldi	r23, 0x01	; 1
    22f2:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
				DELAY_ms(200);
    22f6:	88 ec       	ldi	r24, 0xC8	; 200
    22f8:	90 e0       	ldi	r25, 0x00	; 0
    22fa:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
		}
		//execute time delay
		if (*currentPage == 4) {
    22fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2300:	9e 81       	ldd	r25, Y+6	; 0x06
    2302:	fc 01       	movw	r30, r24
    2304:	80 81       	ld	r24, Z
    2306:	91 81       	ldd	r25, Z+1	; 0x01
    2308:	84 30       	cpi	r24, 0x04	; 4
    230a:	91 05       	cpc	r25, r1
    230c:	09 f0       	breq	.+2      	; 0x2310 <SettingsMenu_pressedButton+0x564>
    230e:	ea c0       	rjmp	.+468    	; 0x24e4 <SettingsMenu_pressedButton+0x738>
			if (BTN_LEFT) { //if pressed < then change to last page
    2310:	86 e3       	ldi	r24, 0x36	; 54
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	fc 01       	movw	r30, r24
    2316:	80 81       	ld	r24, Z
    2318:	88 2f       	mov	r24, r24
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	82 70       	andi	r24, 0x02	; 2
    231e:	99 27       	eor	r25, r25
    2320:	00 97       	sbiw	r24, 0x00	; 0
    2322:	99 f4       	brne	.+38     	; 0x234a <SettingsMenu_pressedButton+0x59e>
				*currentPage = 3;
    2324:	8d 81       	ldd	r24, Y+5	; 0x05
    2326:	9e 81       	ldd	r25, Y+6	; 0x06
    2328:	23 e0       	ldi	r18, 0x03	; 3
    232a:	30 e0       	ldi	r19, 0x00	; 0
    232c:	fc 01       	movw	r30, r24
    232e:	31 83       	std	Z+1, r19	; 0x01
    2330:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    2332:	8b 81       	ldd	r24, Y+3	; 0x03
    2334:	9c 81       	ldd	r25, Y+4	; 0x04
    2336:	fc 01       	movw	r30, r24
    2338:	81 85       	ldd	r24, Z+9	; 0x09
    233a:	92 85       	ldd	r25, Z+10	; 0x0a
    233c:	88 0f       	add	r24, r24
    233e:	99 1f       	adc	r25, r25
    2340:	88 0f       	add	r24, r24
    2342:	99 1f       	adc	r25, r25
    2344:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2348:	38 c2       	rjmp	.+1136   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_RIGHT) { //if pressed > then change to next page
    234a:	86 e3       	ldi	r24, 0x36	; 54
    234c:	90 e0       	ldi	r25, 0x00	; 0
    234e:	fc 01       	movw	r30, r24
    2350:	80 81       	ld	r24, Z
    2352:	88 2f       	mov	r24, r24
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	81 70       	andi	r24, 0x01	; 1
    2358:	99 27       	eor	r25, r25
    235a:	00 97       	sbiw	r24, 0x00	; 0
    235c:	99 f4       	brne	.+38     	; 0x2384 <SettingsMenu_pressedButton+0x5d8>
				*currentPage = 5;
    235e:	8d 81       	ldd	r24, Y+5	; 0x05
    2360:	9e 81       	ldd	r25, Y+6	; 0x06
    2362:	25 e0       	ldi	r18, 0x05	; 5
    2364:	30 e0       	ldi	r19, 0x00	; 0
    2366:	fc 01       	movw	r30, r24
    2368:	31 83       	std	Z+1, r19	; 0x01
    236a:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    236c:	8b 81       	ldd	r24, Y+3	; 0x03
    236e:	9c 81       	ldd	r25, Y+4	; 0x04
    2370:	fc 01       	movw	r30, r24
    2372:	81 85       	ldd	r24, Z+9	; 0x09
    2374:	92 85       	ldd	r25, Z+10	; 0x0a
    2376:	88 0f       	add	r24, r24
    2378:	99 1f       	adc	r25, r25
    237a:	88 0f       	add	r24, r24
    237c:	99 1f       	adc	r25, r25
    237e:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2382:	1b c2       	rjmp	.+1078   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_1) { //if pressed save button then change value of current page more than 100 and exit (go to save statement)
    2384:	86 e3       	ldi	r24, 0x36	; 54
    2386:	90 e0       	ldi	r25, 0x00	; 0
    2388:	fc 01       	movw	r30, r24
    238a:	80 81       	ld	r24, Z
    238c:	88 2f       	mov	r24, r24
    238e:	90 e0       	ldi	r25, 0x00	; 0
    2390:	84 70       	andi	r24, 0x04	; 4
    2392:	99 27       	eor	r25, r25
    2394:	00 97       	sbiw	r24, 0x00	; 0
    2396:	99 f4       	brne	.+38     	; 0x23be <SettingsMenu_pressedButton+0x612>
				*currentPage = 150;
    2398:	8d 81       	ldd	r24, Y+5	; 0x05
    239a:	9e 81       	ldd	r25, Y+6	; 0x06
    239c:	26 e9       	ldi	r18, 0x96	; 150
    239e:	30 e0       	ldi	r19, 0x00	; 0
    23a0:	fc 01       	movw	r30, r24
    23a2:	31 83       	std	Z+1, r19	; 0x01
    23a4:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    23a6:	8b 81       	ldd	r24, Y+3	; 0x03
    23a8:	9c 81       	ldd	r25, Y+4	; 0x04
    23aa:	fc 01       	movw	r30, r24
    23ac:	81 85       	ldd	r24, Z+9	; 0x09
    23ae:	92 85       	ldd	r25, Z+10	; 0x0a
    23b0:	88 0f       	add	r24, r24
    23b2:	99 1f       	adc	r25, r25
    23b4:	88 0f       	add	r24, r24
    23b6:	99 1f       	adc	r25, r25
    23b8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    23bc:	fe c1       	rjmp	.+1020   	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_2) { //if pressed discard button then change value of current page under 0 and exit (go to discard statement)
    23be:	86 e3       	ldi	r24, 0x36	; 54
    23c0:	90 e0       	ldi	r25, 0x00	; 0
    23c2:	fc 01       	movw	r30, r24
    23c4:	80 81       	ld	r24, Z
    23c6:	88 2f       	mov	r24, r24
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	88 70       	andi	r24, 0x08	; 8
    23cc:	99 27       	eor	r25, r25
    23ce:	00 97       	sbiw	r24, 0x00	; 0
    23d0:	99 f4       	brne	.+38     	; 0x23f8 <SettingsMenu_pressedButton+0x64c>
				*currentPage = -10;
    23d2:	8d 81       	ldd	r24, Y+5	; 0x05
    23d4:	9e 81       	ldd	r25, Y+6	; 0x06
    23d6:	26 ef       	ldi	r18, 0xF6	; 246
    23d8:	3f ef       	ldi	r19, 0xFF	; 255
    23da:	fc 01       	movw	r30, r24
    23dc:	31 83       	std	Z+1, r19	; 0x01
    23de:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    23e0:	8b 81       	ldd	r24, Y+3	; 0x03
    23e2:	9c 81       	ldd	r25, Y+4	; 0x04
    23e4:	fc 01       	movw	r30, r24
    23e6:	81 85       	ldd	r24, Z+9	; 0x09
    23e8:	92 85       	ldd	r25, Z+10	; 0x0a
    23ea:	88 0f       	add	r24, r24
    23ec:	99 1f       	adc	r25, r25
    23ee:	88 0f       	add	r24, r24
    23f0:	99 1f       	adc	r25, r25
    23f2:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    23f6:	e1 c1       	rjmp	.+962    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_3 && tmpValues->timeDelay > 50) { //delay-
    23f8:	86 e3       	ldi	r24, 0x36	; 54
    23fa:	90 e0       	ldi	r25, 0x00	; 0
    23fc:	fc 01       	movw	r30, r24
    23fe:	80 81       	ld	r24, Z
    2400:	88 2f       	mov	r24, r24
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	80 71       	andi	r24, 0x10	; 16
    2406:	99 27       	eor	r25, r25
    2408:	00 97       	sbiw	r24, 0x00	; 0
    240a:	89 f5       	brne	.+98     	; 0x246e <SettingsMenu_pressedButton+0x6c2>
    240c:	8b 81       	ldd	r24, Y+3	; 0x03
    240e:	9c 81       	ldd	r25, Y+4	; 0x04
    2410:	fc 01       	movw	r30, r24
    2412:	81 85       	ldd	r24, Z+9	; 0x09
    2414:	92 85       	ldd	r25, Z+10	; 0x0a
    2416:	83 33       	cpi	r24, 0x33	; 51
    2418:	91 05       	cpc	r25, r1
    241a:	4c f1       	brlt	.+82     	; 0x246e <SettingsMenu_pressedButton+0x6c2>
				tmpValues->timeDelay -= 25;
    241c:	8b 81       	ldd	r24, Y+3	; 0x03
    241e:	9c 81       	ldd	r25, Y+4	; 0x04
    2420:	fc 01       	movw	r30, r24
    2422:	81 85       	ldd	r24, Z+9	; 0x09
    2424:	92 85       	ldd	r25, Z+10	; 0x0a
    2426:	9c 01       	movw	r18, r24
    2428:	29 51       	subi	r18, 0x19	; 25
    242a:	31 09       	sbc	r19, r1
    242c:	8b 81       	ldd	r24, Y+3	; 0x03
    242e:	9c 81       	ldd	r25, Y+4	; 0x04
    2430:	fc 01       	movw	r30, r24
    2432:	32 87       	std	Z+10, r19	; 0x0a
    2434:	21 87       	std	Z+9, r18	; 0x09
				if(tmpValues->timeDelay < 50)tmpValues->timeDelay = 50;
    2436:	8b 81       	ldd	r24, Y+3	; 0x03
    2438:	9c 81       	ldd	r25, Y+4	; 0x04
    243a:	fc 01       	movw	r30, r24
    243c:	81 85       	ldd	r24, Z+9	; 0x09
    243e:	92 85       	ldd	r25, Z+10	; 0x0a
    2440:	82 33       	cpi	r24, 0x32	; 50
    2442:	91 05       	cpc	r25, r1
    2444:	3c f4       	brge	.+14     	; 0x2454 <SettingsMenu_pressedButton+0x6a8>
    2446:	8b 81       	ldd	r24, Y+3	; 0x03
    2448:	9c 81       	ldd	r25, Y+4	; 0x04
    244a:	22 e3       	ldi	r18, 0x32	; 50
    244c:	30 e0       	ldi	r19, 0x00	; 0
    244e:	fc 01       	movw	r30, r24
    2450:	32 87       	std	Z+10, r19	; 0x0a
    2452:	21 87       	std	Z+9, r18	; 0x09
				SettingsMenu_PrintValue(tmpValues->timeDelay, "Delay time");
    2454:	8b 81       	ldd	r24, Y+3	; 0x03
    2456:	9c 81       	ldd	r25, Y+4	; 0x04
    2458:	fc 01       	movw	r30, r24
    245a:	81 85       	ldd	r24, Z+9	; 0x09
    245c:	92 85       	ldd	r25, Z+10	; 0x0a
    245e:	6f e9       	ldi	r22, 0x9F	; 159
    2460:	71 e0       	ldi	r23, 0x01	; 1
    2462:	0e 94 56 14 	call	0x28ac	; 0x28ac <SettingsMenu_PrintValue>
				DELAY_ms(200);
    2466:	88 ec       	ldi	r24, 0xC8	; 200
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
			if (BTN_4 && tmpValues->timeDelay < 250) { //delay+
    246e:	86 e3       	ldi	r24, 0x36	; 54
    2470:	90 e0       	ldi	r25, 0x00	; 0
    2472:	fc 01       	movw	r30, r24
    2474:	80 81       	ld	r24, Z
    2476:	88 2f       	mov	r24, r24
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	80 72       	andi	r24, 0x20	; 32
    247c:	99 27       	eor	r25, r25
    247e:	00 97       	sbiw	r24, 0x00	; 0
    2480:	89 f5       	brne	.+98     	; 0x24e4 <SettingsMenu_pressedButton+0x738>
    2482:	8b 81       	ldd	r24, Y+3	; 0x03
    2484:	9c 81       	ldd	r25, Y+4	; 0x04
    2486:	fc 01       	movw	r30, r24
    2488:	81 85       	ldd	r24, Z+9	; 0x09
    248a:	92 85       	ldd	r25, Z+10	; 0x0a
    248c:	8a 3f       	cpi	r24, 0xFA	; 250
    248e:	91 05       	cpc	r25, r1
    2490:	4c f5       	brge	.+82     	; 0x24e4 <SettingsMenu_pressedButton+0x738>
				tmpValues->timeDelay += 25;
    2492:	8b 81       	ldd	r24, Y+3	; 0x03
    2494:	9c 81       	ldd	r25, Y+4	; 0x04
    2496:	fc 01       	movw	r30, r24
    2498:	81 85       	ldd	r24, Z+9	; 0x09
    249a:	92 85       	ldd	r25, Z+10	; 0x0a
    249c:	9c 01       	movw	r18, r24
    249e:	27 5e       	subi	r18, 0xE7	; 231
    24a0:	3f 4f       	sbci	r19, 0xFF	; 255
    24a2:	8b 81       	ldd	r24, Y+3	; 0x03
    24a4:	9c 81       	ldd	r25, Y+4	; 0x04
    24a6:	fc 01       	movw	r30, r24
    24a8:	32 87       	std	Z+10, r19	; 0x0a
    24aa:	21 87       	std	Z+9, r18	; 0x09
				if(tmpValues->timeDelay > 250) tmpValues->timeDelay = 250;
    24ac:	8b 81       	ldd	r24, Y+3	; 0x03
    24ae:	9c 81       	ldd	r25, Y+4	; 0x04
    24b0:	fc 01       	movw	r30, r24
    24b2:	81 85       	ldd	r24, Z+9	; 0x09
    24b4:	92 85       	ldd	r25, Z+10	; 0x0a
    24b6:	8b 3f       	cpi	r24, 0xFB	; 251
    24b8:	91 05       	cpc	r25, r1
    24ba:	3c f0       	brlt	.+14     	; 0x24ca <SettingsMenu_pressedButton+0x71e>
    24bc:	8b 81       	ldd	r24, Y+3	; 0x03
    24be:	9c 81       	ldd	r25, Y+4	; 0x04
    24c0:	2a ef       	ldi	r18, 0xFA	; 250
    24c2:	30 e0       	ldi	r19, 0x00	; 0
    24c4:	fc 01       	movw	r30, r24
    24c6:	32 87       	std	Z+10, r19	; 0x0a
    24c8:	21 87       	std	Z+9, r18	; 0x09
				SettingsMenu_PrintValue(tmpValues->timeDelay, "Delay time");
    24ca:	8b 81       	ldd	r24, Y+3	; 0x03
    24cc:	9c 81       	ldd	r25, Y+4	; 0x04
    24ce:	fc 01       	movw	r30, r24
    24d0:	81 85       	ldd	r24, Z+9	; 0x09
    24d2:	92 85       	ldd	r25, Z+10	; 0x0a
    24d4:	6f e9       	ldi	r22, 0x9F	; 159
    24d6:	71 e0       	ldi	r23, 0x01	; 1
    24d8:	0e 94 56 14 	call	0x28ac	; 0x28ac <SettingsMenu_PrintValue>
				DELAY_ms(200);
    24dc:	88 ec       	ldi	r24, 0xC8	; 200
    24de:	90 e0       	ldi	r25, 0x00	; 0
    24e0:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
		}
		//execute debug mode
		if (*currentPage == 5) {
    24e4:	8d 81       	ldd	r24, Y+5	; 0x05
    24e6:	9e 81       	ldd	r25, Y+6	; 0x06
    24e8:	fc 01       	movw	r30, r24
    24ea:	80 81       	ld	r24, Z
    24ec:	91 81       	ldd	r25, Z+1	; 0x01
    24ee:	85 30       	cpi	r24, 0x05	; 5
    24f0:	91 05       	cpc	r25, r1
    24f2:	09 f0       	breq	.+2      	; 0x24f6 <SettingsMenu_pressedButton+0x74a>
    24f4:	a9 c0       	rjmp	.+338    	; 0x2648 <SettingsMenu_pressedButton+0x89c>
			if (BTN_LEFT) { //if pressed < then change to last page
    24f6:	86 e3       	ldi	r24, 0x36	; 54
    24f8:	90 e0       	ldi	r25, 0x00	; 0
    24fa:	fc 01       	movw	r30, r24
    24fc:	80 81       	ld	r24, Z
    24fe:	88 2f       	mov	r24, r24
    2500:	90 e0       	ldi	r25, 0x00	; 0
    2502:	82 70       	andi	r24, 0x02	; 2
    2504:	99 27       	eor	r25, r25
    2506:	00 97       	sbiw	r24, 0x00	; 0
    2508:	99 f4       	brne	.+38     	; 0x2530 <SettingsMenu_pressedButton+0x784>
				*currentPage = 4;
    250a:	8d 81       	ldd	r24, Y+5	; 0x05
    250c:	9e 81       	ldd	r25, Y+6	; 0x06
    250e:	24 e0       	ldi	r18, 0x04	; 4
    2510:	30 e0       	ldi	r19, 0x00	; 0
    2512:	fc 01       	movw	r30, r24
    2514:	31 83       	std	Z+1, r19	; 0x01
    2516:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    2518:	8b 81       	ldd	r24, Y+3	; 0x03
    251a:	9c 81       	ldd	r25, Y+4	; 0x04
    251c:	fc 01       	movw	r30, r24
    251e:	81 85       	ldd	r24, Z+9	; 0x09
    2520:	92 85       	ldd	r25, Z+10	; 0x0a
    2522:	88 0f       	add	r24, r24
    2524:	99 1f       	adc	r25, r25
    2526:	88 0f       	add	r24, r24
    2528:	99 1f       	adc	r25, r25
    252a:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    252e:	45 c1       	rjmp	.+650    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_RIGHT) { //if pressed > then change to first page
    2530:	86 e3       	ldi	r24, 0x36	; 54
    2532:	90 e0       	ldi	r25, 0x00	; 0
    2534:	fc 01       	movw	r30, r24
    2536:	80 81       	ld	r24, Z
    2538:	88 2f       	mov	r24, r24
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	81 70       	andi	r24, 0x01	; 1
    253e:	99 27       	eor	r25, r25
    2540:	00 97       	sbiw	r24, 0x00	; 0
    2542:	99 f4       	brne	.+38     	; 0x256a <SettingsMenu_pressedButton+0x7be>
				*currentPage = 6;
    2544:	8d 81       	ldd	r24, Y+5	; 0x05
    2546:	9e 81       	ldd	r25, Y+6	; 0x06
    2548:	26 e0       	ldi	r18, 0x06	; 6
    254a:	30 e0       	ldi	r19, 0x00	; 0
    254c:	fc 01       	movw	r30, r24
    254e:	31 83       	std	Z+1, r19	; 0x01
    2550:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    2552:	8b 81       	ldd	r24, Y+3	; 0x03
    2554:	9c 81       	ldd	r25, Y+4	; 0x04
    2556:	fc 01       	movw	r30, r24
    2558:	81 85       	ldd	r24, Z+9	; 0x09
    255a:	92 85       	ldd	r25, Z+10	; 0x0a
    255c:	88 0f       	add	r24, r24
    255e:	99 1f       	adc	r25, r25
    2560:	88 0f       	add	r24, r24
    2562:	99 1f       	adc	r25, r25
    2564:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2568:	28 c1       	rjmp	.+592    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_1) { //if pressed save button then change value of current page more than 100 and exit (go to save statement)
    256a:	86 e3       	ldi	r24, 0x36	; 54
    256c:	90 e0       	ldi	r25, 0x00	; 0
    256e:	fc 01       	movw	r30, r24
    2570:	80 81       	ld	r24, Z
    2572:	88 2f       	mov	r24, r24
    2574:	90 e0       	ldi	r25, 0x00	; 0
    2576:	84 70       	andi	r24, 0x04	; 4
    2578:	99 27       	eor	r25, r25
    257a:	00 97       	sbiw	r24, 0x00	; 0
    257c:	99 f4       	brne	.+38     	; 0x25a4 <SettingsMenu_pressedButton+0x7f8>
				*currentPage = 150;
    257e:	8d 81       	ldd	r24, Y+5	; 0x05
    2580:	9e 81       	ldd	r25, Y+6	; 0x06
    2582:	26 e9       	ldi	r18, 0x96	; 150
    2584:	30 e0       	ldi	r19, 0x00	; 0
    2586:	fc 01       	movw	r30, r24
    2588:	31 83       	std	Z+1, r19	; 0x01
    258a:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    258c:	8b 81       	ldd	r24, Y+3	; 0x03
    258e:	9c 81       	ldd	r25, Y+4	; 0x04
    2590:	fc 01       	movw	r30, r24
    2592:	81 85       	ldd	r24, Z+9	; 0x09
    2594:	92 85       	ldd	r25, Z+10	; 0x0a
    2596:	88 0f       	add	r24, r24
    2598:	99 1f       	adc	r25, r25
    259a:	88 0f       	add	r24, r24
    259c:	99 1f       	adc	r25, r25
    259e:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    25a2:	0b c1       	rjmp	.+534    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_2) { //if pressed discard button then change value of current page under 0 and exit (go to discard statement)
    25a4:	86 e3       	ldi	r24, 0x36	; 54
    25a6:	90 e0       	ldi	r25, 0x00	; 0
    25a8:	fc 01       	movw	r30, r24
    25aa:	80 81       	ld	r24, Z
    25ac:	88 2f       	mov	r24, r24
    25ae:	90 e0       	ldi	r25, 0x00	; 0
    25b0:	88 70       	andi	r24, 0x08	; 8
    25b2:	99 27       	eor	r25, r25
    25b4:	00 97       	sbiw	r24, 0x00	; 0
    25b6:	99 f4       	brne	.+38     	; 0x25de <SettingsMenu_pressedButton+0x832>
				*currentPage = -10;
    25b8:	8d 81       	ldd	r24, Y+5	; 0x05
    25ba:	9e 81       	ldd	r25, Y+6	; 0x06
    25bc:	26 ef       	ldi	r18, 0xF6	; 246
    25be:	3f ef       	ldi	r19, 0xFF	; 255
    25c0:	fc 01       	movw	r30, r24
    25c2:	31 83       	std	Z+1, r19	; 0x01
    25c4:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    25c6:	8b 81       	ldd	r24, Y+3	; 0x03
    25c8:	9c 81       	ldd	r25, Y+4	; 0x04
    25ca:	fc 01       	movw	r30, r24
    25cc:	81 85       	ldd	r24, Z+9	; 0x09
    25ce:	92 85       	ldd	r25, Z+10	; 0x0a
    25d0:	88 0f       	add	r24, r24
    25d2:	99 1f       	adc	r25, r25
    25d4:	88 0f       	add	r24, r24
    25d6:	99 1f       	adc	r25, r25
    25d8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    25dc:	ee c0       	rjmp	.+476    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_3) { //debug mode off
    25de:	86 e3       	ldi	r24, 0x36	; 54
    25e0:	90 e0       	ldi	r25, 0x00	; 0
    25e2:	fc 01       	movw	r30, r24
    25e4:	80 81       	ld	r24, Z
    25e6:	88 2f       	mov	r24, r24
    25e8:	90 e0       	ldi	r25, 0x00	; 0
    25ea:	80 71       	andi	r24, 0x10	; 16
    25ec:	99 27       	eor	r25, r25
    25ee:	00 97       	sbiw	r24, 0x00	; 0
    25f0:	81 f4       	brne	.+32     	; 0x2612 <SettingsMenu_pressedButton+0x866>
				tmpValues->debugMode = false;
    25f2:	8b 81       	ldd	r24, Y+3	; 0x03
    25f4:	9c 81       	ldd	r25, Y+4	; 0x04
    25f6:	fc 01       	movw	r30, r24
    25f8:	10 86       	std	Z+8, r1	; 0x08
				SettingsMenu_PrintBoolean(tmpValues->debugMode, "Debug mode");
    25fa:	8b 81       	ldd	r24, Y+3	; 0x03
    25fc:	9c 81       	ldd	r25, Y+4	; 0x04
    25fe:	fc 01       	movw	r30, r24
    2600:	80 85       	ldd	r24, Z+8	; 0x08
    2602:	6a ea       	ldi	r22, 0xAA	; 170
    2604:	71 e0       	ldi	r23, 0x01	; 1
    2606:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
				DELAY_ms(200);
    260a:	88 ec       	ldi	r24, 0xC8	; 200
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
			if (BTN_4) { //debug mode on
    2612:	86 e3       	ldi	r24, 0x36	; 54
    2614:	90 e0       	ldi	r25, 0x00	; 0
    2616:	fc 01       	movw	r30, r24
    2618:	80 81       	ld	r24, Z
    261a:	88 2f       	mov	r24, r24
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	80 72       	andi	r24, 0x20	; 32
    2620:	99 27       	eor	r25, r25
    2622:	00 97       	sbiw	r24, 0x00	; 0
    2624:	89 f4       	brne	.+34     	; 0x2648 <SettingsMenu_pressedButton+0x89c>
				tmpValues->debugMode = true;
    2626:	8b 81       	ldd	r24, Y+3	; 0x03
    2628:	9c 81       	ldd	r25, Y+4	; 0x04
    262a:	21 e0       	ldi	r18, 0x01	; 1
    262c:	fc 01       	movw	r30, r24
    262e:	20 87       	std	Z+8, r18	; 0x08
				SettingsMenu_PrintBoolean(tmpValues->debugMode, "Debug mode");
    2630:	8b 81       	ldd	r24, Y+3	; 0x03
    2632:	9c 81       	ldd	r25, Y+4	; 0x04
    2634:	fc 01       	movw	r30, r24
    2636:	80 85       	ldd	r24, Z+8	; 0x08
    2638:	6a ea       	ldi	r22, 0xAA	; 170
    263a:	71 e0       	ldi	r23, 0x01	; 1
    263c:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
				DELAY_ms(200);
    2640:	88 ec       	ldi	r24, 0xC8	; 200
    2642:	90 e0       	ldi	r25, 0x00	; 0
    2644:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
		}
		//show number of page when changing
		if (*currentPage == 6) {
    2648:	8d 81       	ldd	r24, Y+5	; 0x05
    264a:	9e 81       	ldd	r25, Y+6	; 0x06
    264c:	fc 01       	movw	r30, r24
    264e:	80 81       	ld	r24, Z
    2650:	91 81       	ldd	r25, Z+1	; 0x01
    2652:	86 30       	cpi	r24, 0x06	; 6
    2654:	91 05       	cpc	r25, r1
    2656:	09 f0       	breq	.+2      	; 0x265a <SettingsMenu_pressedButton+0x8ae>
    2658:	a9 c0       	rjmp	.+338    	; 0x27ac <SettingsMenu_pressedButton+0xa00>
			if (BTN_LEFT) { //if pressed < then change to last page
    265a:	86 e3       	ldi	r24, 0x36	; 54
    265c:	90 e0       	ldi	r25, 0x00	; 0
    265e:	fc 01       	movw	r30, r24
    2660:	80 81       	ld	r24, Z
    2662:	88 2f       	mov	r24, r24
    2664:	90 e0       	ldi	r25, 0x00	; 0
    2666:	82 70       	andi	r24, 0x02	; 2
    2668:	99 27       	eor	r25, r25
    266a:	00 97       	sbiw	r24, 0x00	; 0
    266c:	99 f4       	brne	.+38     	; 0x2694 <SettingsMenu_pressedButton+0x8e8>
				*currentPage = 5;
    266e:	8d 81       	ldd	r24, Y+5	; 0x05
    2670:	9e 81       	ldd	r25, Y+6	; 0x06
    2672:	25 e0       	ldi	r18, 0x05	; 5
    2674:	30 e0       	ldi	r19, 0x00	; 0
    2676:	fc 01       	movw	r30, r24
    2678:	31 83       	std	Z+1, r19	; 0x01
    267a:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    267c:	8b 81       	ldd	r24, Y+3	; 0x03
    267e:	9c 81       	ldd	r25, Y+4	; 0x04
    2680:	fc 01       	movw	r30, r24
    2682:	81 85       	ldd	r24, Z+9	; 0x09
    2684:	92 85       	ldd	r25, Z+10	; 0x0a
    2686:	88 0f       	add	r24, r24
    2688:	99 1f       	adc	r25, r25
    268a:	88 0f       	add	r24, r24
    268c:	99 1f       	adc	r25, r25
    268e:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2692:	93 c0       	rjmp	.+294    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_RIGHT) { //if pressed > then change to first page
    2694:	86 e3       	ldi	r24, 0x36	; 54
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	fc 01       	movw	r30, r24
    269a:	80 81       	ld	r24, Z
    269c:	88 2f       	mov	r24, r24
    269e:	90 e0       	ldi	r25, 0x00	; 0
    26a0:	81 70       	andi	r24, 0x01	; 1
    26a2:	99 27       	eor	r25, r25
    26a4:	00 97       	sbiw	r24, 0x00	; 0
    26a6:	99 f4       	brne	.+38     	; 0x26ce <SettingsMenu_pressedButton+0x922>
				*currentPage = 1;
    26a8:	8d 81       	ldd	r24, Y+5	; 0x05
    26aa:	9e 81       	ldd	r25, Y+6	; 0x06
    26ac:	21 e0       	ldi	r18, 0x01	; 1
    26ae:	30 e0       	ldi	r19, 0x00	; 0
    26b0:	fc 01       	movw	r30, r24
    26b2:	31 83       	std	Z+1, r19	; 0x01
    26b4:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    26b6:	8b 81       	ldd	r24, Y+3	; 0x03
    26b8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ba:	fc 01       	movw	r30, r24
    26bc:	81 85       	ldd	r24, Z+9	; 0x09
    26be:	92 85       	ldd	r25, Z+10	; 0x0a
    26c0:	88 0f       	add	r24, r24
    26c2:	99 1f       	adc	r25, r25
    26c4:	88 0f       	add	r24, r24
    26c6:	99 1f       	adc	r25, r25
    26c8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    26cc:	76 c0       	rjmp	.+236    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_1) { //if pressed save button then change value of current page more than 100 and exit (go to save statement)
    26ce:	86 e3       	ldi	r24, 0x36	; 54
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	fc 01       	movw	r30, r24
    26d4:	80 81       	ld	r24, Z
    26d6:	88 2f       	mov	r24, r24
    26d8:	90 e0       	ldi	r25, 0x00	; 0
    26da:	84 70       	andi	r24, 0x04	; 4
    26dc:	99 27       	eor	r25, r25
    26de:	00 97       	sbiw	r24, 0x00	; 0
    26e0:	99 f4       	brne	.+38     	; 0x2708 <SettingsMenu_pressedButton+0x95c>
				*currentPage = 150;
    26e2:	8d 81       	ldd	r24, Y+5	; 0x05
    26e4:	9e 81       	ldd	r25, Y+6	; 0x06
    26e6:	26 e9       	ldi	r18, 0x96	; 150
    26e8:	30 e0       	ldi	r19, 0x00	; 0
    26ea:	fc 01       	movw	r30, r24
    26ec:	31 83       	std	Z+1, r19	; 0x01
    26ee:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    26f0:	8b 81       	ldd	r24, Y+3	; 0x03
    26f2:	9c 81       	ldd	r25, Y+4	; 0x04
    26f4:	fc 01       	movw	r30, r24
    26f6:	81 85       	ldd	r24, Z+9	; 0x09
    26f8:	92 85       	ldd	r25, Z+10	; 0x0a
    26fa:	88 0f       	add	r24, r24
    26fc:	99 1f       	adc	r25, r25
    26fe:	88 0f       	add	r24, r24
    2700:	99 1f       	adc	r25, r25
    2702:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2706:	59 c0       	rjmp	.+178    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_2) { //if pressed discard button then change value of current page under 0 and exit (go to discard statement)
    2708:	86 e3       	ldi	r24, 0x36	; 54
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	fc 01       	movw	r30, r24
    270e:	80 81       	ld	r24, Z
    2710:	88 2f       	mov	r24, r24
    2712:	90 e0       	ldi	r25, 0x00	; 0
    2714:	88 70       	andi	r24, 0x08	; 8
    2716:	99 27       	eor	r25, r25
    2718:	00 97       	sbiw	r24, 0x00	; 0
    271a:	99 f4       	brne	.+38     	; 0x2742 <SettingsMenu_pressedButton+0x996>
				*currentPage = -10;
    271c:	8d 81       	ldd	r24, Y+5	; 0x05
    271e:	9e 81       	ldd	r25, Y+6	; 0x06
    2720:	26 ef       	ldi	r18, 0xF6	; 246
    2722:	3f ef       	ldi	r19, 0xFF	; 255
    2724:	fc 01       	movw	r30, r24
    2726:	31 83       	std	Z+1, r19	; 0x01
    2728:	20 83       	st	Z, r18
				DELAY_ms(tmpValues->timeDelay * 4);
    272a:	8b 81       	ldd	r24, Y+3	; 0x03
    272c:	9c 81       	ldd	r25, Y+4	; 0x04
    272e:	fc 01       	movw	r30, r24
    2730:	81 85       	ldd	r24, Z+9	; 0x09
    2732:	92 85       	ldd	r25, Z+10	; 0x0a
    2734:	88 0f       	add	r24, r24
    2736:	99 1f       	adc	r25, r25
    2738:	88 0f       	add	r24, r24
    273a:	99 1f       	adc	r25, r25
    273c:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				return;
    2740:	3c c0       	rjmp	.+120    	; 0x27ba <SettingsMenu_pressedButton+0xa0e>
			}
			if (BTN_3) { //debug mode off
    2742:	86 e3       	ldi	r24, 0x36	; 54
    2744:	90 e0       	ldi	r25, 0x00	; 0
    2746:	fc 01       	movw	r30, r24
    2748:	80 81       	ld	r24, Z
    274a:	88 2f       	mov	r24, r24
    274c:	90 e0       	ldi	r25, 0x00	; 0
    274e:	80 71       	andi	r24, 0x10	; 16
    2750:	99 27       	eor	r25, r25
    2752:	00 97       	sbiw	r24, 0x00	; 0
    2754:	81 f4       	brne	.+32     	; 0x2776 <SettingsMenu_pressedButton+0x9ca>
				tmpValues->showChangingPage = false;
    2756:	8b 81       	ldd	r24, Y+3	; 0x03
    2758:	9c 81       	ldd	r25, Y+4	; 0x04
    275a:	fc 01       	movw	r30, r24
    275c:	13 86       	std	Z+11, r1	; 0x0b
				SettingsMenu_PrintBoolean(tmpValues->showChangingPage,
    275e:	8b 81       	ldd	r24, Y+3	; 0x03
    2760:	9c 81       	ldd	r25, Y+4	; 0x04
    2762:	fc 01       	movw	r30, r24
    2764:	83 85       	ldd	r24, Z+11	; 0x0b
    2766:	65 eb       	ldi	r22, 0xB5	; 181
    2768:	71 e0       	ldi	r23, 0x01	; 1
    276a:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
						"Page number"); //print page on screen
				DELAY_ms(200);
    276e:	88 ec       	ldi	r24, 0xC8	; 200
    2770:	90 e0       	ldi	r25, 0x00	; 0
    2772:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
			if (BTN_4) { //debug mode on
    2776:	86 e3       	ldi	r24, 0x36	; 54
    2778:	90 e0       	ldi	r25, 0x00	; 0
    277a:	fc 01       	movw	r30, r24
    277c:	80 81       	ld	r24, Z
    277e:	88 2f       	mov	r24, r24
    2780:	90 e0       	ldi	r25, 0x00	; 0
    2782:	80 72       	andi	r24, 0x20	; 32
    2784:	99 27       	eor	r25, r25
    2786:	00 97       	sbiw	r24, 0x00	; 0
    2788:	89 f4       	brne	.+34     	; 0x27ac <SettingsMenu_pressedButton+0xa00>
				tmpValues->showChangingPage = true;
    278a:	8b 81       	ldd	r24, Y+3	; 0x03
    278c:	9c 81       	ldd	r25, Y+4	; 0x04
    278e:	21 e0       	ldi	r18, 0x01	; 1
    2790:	fc 01       	movw	r30, r24
    2792:	23 87       	std	Z+11, r18	; 0x0b
				SettingsMenu_PrintBoolean(tmpValues->showChangingPage,
    2794:	8b 81       	ldd	r24, Y+3	; 0x03
    2796:	9c 81       	ldd	r25, Y+4	; 0x04
    2798:	fc 01       	movw	r30, r24
    279a:	83 85       	ldd	r24, Z+11	; 0x0b
    279c:	65 eb       	ldi	r22, 0xB5	; 181
    279e:	71 e0       	ldi	r23, 0x01	; 1
    27a0:	0e 94 e6 13 	call	0x27cc	; 0x27cc <SettingsMenu_PrintBoolean>
						"Page number"); //print page on screen
				DELAY_ms(200);
    27a4:	88 ec       	ldi	r24, 0xC8	; 200
    27a6:	90 e0       	ldi	r25, 0x00	; 0
    27a8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
		}
		LCD_RefreshScreen(&refreshClock, 500);
    27ac:	64 ef       	ldi	r22, 0xF4	; 244
    27ae:	71 e0       	ldi	r23, 0x01	; 1
    27b0:	ce 01       	movw	r24, r28
    27b2:	01 96       	adiw	r24, 0x01	; 1
    27b4:	0e 94 91 2c 	call	0x5922	; 0x5922 <LCD_RefreshScreen>
	}
    27b8:	06 cb       	rjmp	.-2548   	; 0x1dc6 <SettingsMenu_pressedButton+0x1a>
}
    27ba:	26 96       	adiw	r28, 0x06	; 6
    27bc:	0f b6       	in	r0, 0x3f	; 63
    27be:	f8 94       	cli
    27c0:	de bf       	out	0x3e, r29	; 62
    27c2:	0f be       	out	0x3f, r0	; 63
    27c4:	cd bf       	out	0x3d, r28	; 61
    27c6:	df 91       	pop	r29
    27c8:	cf 91       	pop	r28
    27ca:	08 95       	ret

000027cc <SettingsMenu_PrintBoolean>:

void SettingsMenu_PrintBoolean(bool status, char *label) {
    27cc:	cf 93       	push	r28
    27ce:	df 93       	push	r29
    27d0:	00 d0       	rcall	.+0      	; 0x27d2 <SettingsMenu_PrintBoolean+0x6>
    27d2:	1f 92       	push	r1
    27d4:	cd b7       	in	r28, 0x3d	; 61
    27d6:	de b7       	in	r29, 0x3e	; 62
    27d8:	89 83       	std	Y+1, r24	; 0x01
    27da:	7b 83       	std	Y+3, r23	; 0x03
    27dc:	6a 83       	std	Y+2, r22	; 0x02
	LCD_Clear();
    27de:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	if (status)
    27e2:	89 81       	ldd	r24, Y+1	; 0x01
    27e4:	88 23       	and	r24, r24
    27e6:	d1 f0       	breq	.+52     	; 0x281c <SettingsMenu_PrintBoolean+0x50>
		LCD_XYPrintf(0, 0, "%s: ON", label);
    27e8:	8b 81       	ldd	r24, Y+3	; 0x03
    27ea:	8f 93       	push	r24
    27ec:	8a 81       	ldd	r24, Y+2	; 0x02
    27ee:	8f 93       	push	r24
    27f0:	8a ed       	ldi	r24, 0xDA	; 218
    27f2:	91 e0       	ldi	r25, 0x01	; 1
    27f4:	89 2f       	mov	r24, r25
    27f6:	8f 93       	push	r24
    27f8:	8a ed       	ldi	r24, 0xDA	; 218
    27fa:	91 e0       	ldi	r25, 0x01	; 1
    27fc:	8f 93       	push	r24
    27fe:	1f 92       	push	r1
    2800:	1f 92       	push	r1
    2802:	1f 92       	push	r1
    2804:	1f 92       	push	r1
    2806:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    280a:	8d b7       	in	r24, 0x3d	; 61
    280c:	9e b7       	in	r25, 0x3e	; 62
    280e:	08 96       	adiw	r24, 0x08	; 8
    2810:	0f b6       	in	r0, 0x3f	; 63
    2812:	f8 94       	cli
    2814:	de bf       	out	0x3e, r29	; 62
    2816:	0f be       	out	0x3f, r0	; 63
    2818:	cd bf       	out	0x3d, r28	; 61
    281a:	19 c0       	rjmp	.+50     	; 0x284e <SettingsMenu_PrintBoolean+0x82>
	else
		LCD_XYPrintf(0, 0, "%s: OFF", label);
    281c:	8b 81       	ldd	r24, Y+3	; 0x03
    281e:	8f 93       	push	r24
    2820:	8a 81       	ldd	r24, Y+2	; 0x02
    2822:	8f 93       	push	r24
    2824:	81 ee       	ldi	r24, 0xE1	; 225
    2826:	91 e0       	ldi	r25, 0x01	; 1
    2828:	89 2f       	mov	r24, r25
    282a:	8f 93       	push	r24
    282c:	81 ee       	ldi	r24, 0xE1	; 225
    282e:	91 e0       	ldi	r25, 0x01	; 1
    2830:	8f 93       	push	r24
    2832:	1f 92       	push	r1
    2834:	1f 92       	push	r1
    2836:	1f 92       	push	r1
    2838:	1f 92       	push	r1
    283a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    283e:	8d b7       	in	r24, 0x3d	; 61
    2840:	9e b7       	in	r25, 0x3e	; 62
    2842:	08 96       	adiw	r24, 0x08	; 8
    2844:	0f b6       	in	r0, 0x3f	; 63
    2846:	f8 94       	cli
    2848:	de bf       	out	0x3e, r29	; 62
    284a:	0f be       	out	0x3f, r0	; 63
    284c:	cd bf       	out	0x3d, r28	; 61
	LCD_XYPrintf(0, 1, "OFF");
    284e:	89 ee       	ldi	r24, 0xE9	; 233
    2850:	91 e0       	ldi	r25, 0x01	; 1
    2852:	89 2f       	mov	r24, r25
    2854:	8f 93       	push	r24
    2856:	89 ee       	ldi	r24, 0xE9	; 233
    2858:	91 e0       	ldi	r25, 0x01	; 1
    285a:	8f 93       	push	r24
    285c:	1f 92       	push	r1
    285e:	81 e0       	ldi	r24, 0x01	; 1
    2860:	8f 93       	push	r24
    2862:	1f 92       	push	r1
    2864:	1f 92       	push	r1
    2866:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    286a:	0f 90       	pop	r0
    286c:	0f 90       	pop	r0
    286e:	0f 90       	pop	r0
    2870:	0f 90       	pop	r0
    2872:	0f 90       	pop	r0
    2874:	0f 90       	pop	r0
	LCD_XYPrintf(14, 1, "ON");
    2876:	8d ee       	ldi	r24, 0xED	; 237
    2878:	91 e0       	ldi	r25, 0x01	; 1
    287a:	89 2f       	mov	r24, r25
    287c:	8f 93       	push	r24
    287e:	8d ee       	ldi	r24, 0xED	; 237
    2880:	91 e0       	ldi	r25, 0x01	; 1
    2882:	8f 93       	push	r24
    2884:	1f 92       	push	r1
    2886:	81 e0       	ldi	r24, 0x01	; 1
    2888:	8f 93       	push	r24
    288a:	1f 92       	push	r1
    288c:	8e e0       	ldi	r24, 0x0E	; 14
    288e:	8f 93       	push	r24
    2890:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    2894:	0f 90       	pop	r0
    2896:	0f 90       	pop	r0
    2898:	0f 90       	pop	r0
    289a:	0f 90       	pop	r0
    289c:	0f 90       	pop	r0
    289e:	0f 90       	pop	r0
}
    28a0:	0f 90       	pop	r0
    28a2:	0f 90       	pop	r0
    28a4:	0f 90       	pop	r0
    28a6:	df 91       	pop	r29
    28a8:	cf 91       	pop	r28
    28aa:	08 95       	ret

000028ac <SettingsMenu_PrintValue>:

void SettingsMenu_PrintValue(int value, char *label) {
    28ac:	cf 93       	push	r28
    28ae:	df 93       	push	r29
    28b0:	00 d0       	rcall	.+0      	; 0x28b2 <SettingsMenu_PrintValue+0x6>
    28b2:	00 d0       	rcall	.+0      	; 0x28b4 <SettingsMenu_PrintValue+0x8>
    28b4:	cd b7       	in	r28, 0x3d	; 61
    28b6:	de b7       	in	r29, 0x3e	; 62
    28b8:	9a 83       	std	Y+2, r25	; 0x02
    28ba:	89 83       	std	Y+1, r24	; 0x01
    28bc:	7c 83       	std	Y+4, r23	; 0x04
    28be:	6b 83       	std	Y+3, r22	; 0x03
	LCD_Clear();
    28c0:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_XYPrintf(0, 0, "%s: %d", label, value);
    28c4:	8a 81       	ldd	r24, Y+2	; 0x02
    28c6:	8f 93       	push	r24
    28c8:	89 81       	ldd	r24, Y+1	; 0x01
    28ca:	8f 93       	push	r24
    28cc:	8c 81       	ldd	r24, Y+4	; 0x04
    28ce:	8f 93       	push	r24
    28d0:	8b 81       	ldd	r24, Y+3	; 0x03
    28d2:	8f 93       	push	r24
    28d4:	80 ef       	ldi	r24, 0xF0	; 240
    28d6:	91 e0       	ldi	r25, 0x01	; 1
    28d8:	89 2f       	mov	r24, r25
    28da:	8f 93       	push	r24
    28dc:	80 ef       	ldi	r24, 0xF0	; 240
    28de:	91 e0       	ldi	r25, 0x01	; 1
    28e0:	8f 93       	push	r24
    28e2:	1f 92       	push	r1
    28e4:	1f 92       	push	r1
    28e6:	1f 92       	push	r1
    28e8:	1f 92       	push	r1
    28ea:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    28ee:	8d b7       	in	r24, 0x3d	; 61
    28f0:	9e b7       	in	r25, 0x3e	; 62
    28f2:	0a 96       	adiw	r24, 0x0a	; 10
    28f4:	0f b6       	in	r0, 0x3f	; 63
    28f6:	f8 94       	cli
    28f8:	de bf       	out	0x3e, r29	; 62
    28fa:	0f be       	out	0x3f, r0	; 63
    28fc:	cd bf       	out	0x3d, r28	; 61
	LCD_XYPrintf(0, 1, "-");
    28fe:	87 ef       	ldi	r24, 0xF7	; 247
    2900:	91 e0       	ldi	r25, 0x01	; 1
    2902:	89 2f       	mov	r24, r25
    2904:	8f 93       	push	r24
    2906:	87 ef       	ldi	r24, 0xF7	; 247
    2908:	91 e0       	ldi	r25, 0x01	; 1
    290a:	8f 93       	push	r24
    290c:	1f 92       	push	r1
    290e:	81 e0       	ldi	r24, 0x01	; 1
    2910:	8f 93       	push	r24
    2912:	1f 92       	push	r1
    2914:	1f 92       	push	r1
    2916:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    291a:	0f 90       	pop	r0
    291c:	0f 90       	pop	r0
    291e:	0f 90       	pop	r0
    2920:	0f 90       	pop	r0
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
	LCD_XYPrintf(15, 1, "+");
    2926:	89 ef       	ldi	r24, 0xF9	; 249
    2928:	91 e0       	ldi	r25, 0x01	; 1
    292a:	89 2f       	mov	r24, r25
    292c:	8f 93       	push	r24
    292e:	89 ef       	ldi	r24, 0xF9	; 249
    2930:	91 e0       	ldi	r25, 0x01	; 1
    2932:	8f 93       	push	r24
    2934:	1f 92       	push	r1
    2936:	81 e0       	ldi	r24, 0x01	; 1
    2938:	8f 93       	push	r24
    293a:	1f 92       	push	r1
    293c:	8f e0       	ldi	r24, 0x0F	; 15
    293e:	8f 93       	push	r24
    2940:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    2944:	0f 90       	pop	r0
    2946:	0f 90       	pop	r0
    2948:	0f 90       	pop	r0
    294a:	0f 90       	pop	r0
    294c:	0f 90       	pop	r0
    294e:	0f 90       	pop	r0
}
    2950:	0f 90       	pop	r0
    2952:	0f 90       	pop	r0
    2954:	0f 90       	pop	r0
    2956:	0f 90       	pop	r0
    2958:	df 91       	pop	r29
    295a:	cf 91       	pop	r28
    295c:	08 95       	ret

0000295e <SettingsMenu_PrintLabel>:

void SettingsMenu_PrintLabel(char *label) {
    295e:	cf 93       	push	r28
    2960:	df 93       	push	r29
    2962:	00 d0       	rcall	.+0      	; 0x2964 <SettingsMenu_PrintLabel+0x6>
    2964:	cd b7       	in	r28, 0x3d	; 61
    2966:	de b7       	in	r29, 0x3e	; 62
    2968:	9a 83       	std	Y+2, r25	; 0x02
    296a:	89 83       	std	Y+1, r24	; 0x01
	LCD_Clear();
    296c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_XYPrintf(0, 0, "%s", label);
    2970:	8a 81       	ldd	r24, Y+2	; 0x02
    2972:	8f 93       	push	r24
    2974:	89 81       	ldd	r24, Y+1	; 0x01
    2976:	8f 93       	push	r24
    2978:	8b ef       	ldi	r24, 0xFB	; 251
    297a:	91 e0       	ldi	r25, 0x01	; 1
    297c:	89 2f       	mov	r24, r25
    297e:	8f 93       	push	r24
    2980:	8b ef       	ldi	r24, 0xFB	; 251
    2982:	91 e0       	ldi	r25, 0x01	; 1
    2984:	8f 93       	push	r24
    2986:	1f 92       	push	r1
    2988:	1f 92       	push	r1
    298a:	1f 92       	push	r1
    298c:	1f 92       	push	r1
    298e:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    2992:	8d b7       	in	r24, 0x3d	; 61
    2994:	9e b7       	in	r25, 0x3e	; 62
    2996:	08 96       	adiw	r24, 0x08	; 8
    2998:	0f b6       	in	r0, 0x3f	; 63
    299a:	f8 94       	cli
    299c:	de bf       	out	0x3e, r29	; 62
    299e:	0f be       	out	0x3f, r0	; 63
    29a0:	cd bf       	out	0x3d, r28	; 61
	LCD_XYPrintf(0, 1, "ok");
    29a2:	8e ef       	ldi	r24, 0xFE	; 254
    29a4:	91 e0       	ldi	r25, 0x01	; 1
    29a6:	89 2f       	mov	r24, r25
    29a8:	8f 93       	push	r24
    29aa:	8e ef       	ldi	r24, 0xFE	; 254
    29ac:	91 e0       	ldi	r25, 0x01	; 1
    29ae:	8f 93       	push	r24
    29b0:	1f 92       	push	r1
    29b2:	81 e0       	ldi	r24, 0x01	; 1
    29b4:	8f 93       	push	r24
    29b6:	1f 92       	push	r1
    29b8:	1f 92       	push	r1
    29ba:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    29be:	0f 90       	pop	r0
    29c0:	0f 90       	pop	r0
    29c2:	0f 90       	pop	r0
    29c4:	0f 90       	pop	r0
    29c6:	0f 90       	pop	r0
    29c8:	0f 90       	pop	r0
	LCD_XYPrintf(14, 1, "ok");
    29ca:	8e ef       	ldi	r24, 0xFE	; 254
    29cc:	91 e0       	ldi	r25, 0x01	; 1
    29ce:	89 2f       	mov	r24, r25
    29d0:	8f 93       	push	r24
    29d2:	8e ef       	ldi	r24, 0xFE	; 254
    29d4:	91 e0       	ldi	r25, 0x01	; 1
    29d6:	8f 93       	push	r24
    29d8:	1f 92       	push	r1
    29da:	81 e0       	ldi	r24, 0x01	; 1
    29dc:	8f 93       	push	r24
    29de:	1f 92       	push	r1
    29e0:	8e e0       	ldi	r24, 0x0E	; 14
    29e2:	8f 93       	push	r24
    29e4:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    29e8:	0f 90       	pop	r0
    29ea:	0f 90       	pop	r0
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
    29f0:	0f 90       	pop	r0
    29f2:	0f 90       	pop	r0
}
    29f4:	0f 90       	pop	r0
    29f6:	0f 90       	pop	r0
    29f8:	df 91       	pop	r29
    29fa:	cf 91       	pop	r28
    29fc:	08 95       	ret

000029fe <UARTCOMMUNICATION_send>:

/* CONNECT HEADER */
#include "../HEADERS/UART_COMMUNICATION.h"

/* BODY OF FUNCTIONS */
void UARTCOMMUNICATION_send(const char *str, int time) {
    29fe:	cf 93       	push	r28
    2a00:	df 93       	push	r29
    2a02:	00 d0       	rcall	.+0      	; 0x2a04 <UARTCOMMUNICATION_send+0x6>
    2a04:	00 d0       	rcall	.+0      	; 0x2a06 <UARTCOMMUNICATION_send+0x8>
    2a06:	cd b7       	in	r28, 0x3d	; 61
    2a08:	de b7       	in	r29, 0x3e	; 62
    2a0a:	9a 83       	std	Y+2, r25	; 0x02
    2a0c:	89 83       	std	Y+1, r24	; 0x01
    2a0e:	7c 83       	std	Y+4, r23	; 0x04
    2a10:	6b 83       	std	Y+3, r22	; 0x03
		UART_Printf(str);
    2a12:	8a 81       	ldd	r24, Y+2	; 0x02
    2a14:	8f 93       	push	r24
    2a16:	89 81       	ldd	r24, Y+1	; 0x01
    2a18:	8f 93       	push	r24
    2a1a:	0e 94 4c 30 	call	0x6098	; 0x6098 <UART_Printf>
    2a1e:	0f 90       	pop	r0
    2a20:	0f 90       	pop	r0
		DELAY_ms(time);
    2a22:	8b 81       	ldd	r24, Y+3	; 0x03
    2a24:	9c 81       	ldd	r25, Y+4	; 0x04
    2a26:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
}
    2a2a:	0f 90       	pop	r0
    2a2c:	0f 90       	pop	r0
    2a2e:	0f 90       	pop	r0
    2a30:	0f 90       	pop	r0
    2a32:	df 91       	pop	r29
    2a34:	cf 91       	pop	r28
    2a36:	08 95       	ret

00002a38 <main>:
		struct LCDEXPLOITING_AllPages *lcdPageLabbles);

void ShowPage(int time, int page, bool willShow);

/* MAIN PROGRAM */
int main() {
    2a38:	cf 93       	push	r28
    2a3a:	df 93       	push	r29
    2a3c:	cd b7       	in	r28, 0x3d	; 61
    2a3e:	de b7       	in	r29, 0x3e	; 62
    2a40:	ce 59       	subi	r28, 0x9E	; 158
    2a42:	d1 09       	sbc	r29, r1
    2a44:	0f b6       	in	r0, 0x3f	; 63
    2a46:	f8 94       	cli
    2a48:	de bf       	out	0x3e, r29	; 62
    2a4a:	0f be       	out	0x3f, r0	; 63
    2a4c:	cd bf       	out	0x3d, r28	; 61

	struct SettingsMenu_values settinsgMenu_values;

	struct LCDEXPLOITING_AllPages lcdPageLabbles;

	int page = 0;
    2a4e:	ce 01       	movw	r24, r28
    2a50:	83 56       	subi	r24, 0x63	; 99
    2a52:	9f 4f       	sbci	r25, 0xFF	; 255
    2a54:	fc 01       	movw	r30, r24
    2a56:	11 82       	std	Z+1, r1	; 0x01
    2a58:	10 82       	st	Z, r1

	Initialization(&settinsgMenu_values, &page, &lcdPageLabbles);
    2a5a:	9e 01       	movw	r18, r28
    2a5c:	23 5f       	subi	r18, 0xF3	; 243
    2a5e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a60:	ce 01       	movw	r24, r28
    2a62:	83 56       	subi	r24, 0x63	; 99
    2a64:	9f 4f       	sbci	r25, 0xFF	; 255
    2a66:	a9 01       	movw	r20, r18
    2a68:	bc 01       	movw	r22, r24
    2a6a:	ce 01       	movw	r24, r28
    2a6c:	01 96       	adiw	r24, 0x01	; 1
    2a6e:	0e 94 51 15 	call	0x2aa2	; 0x2aa2 <Initialization>
	MainLoop(&settinsgMenu_values, &page, &lcdPageLabbles);
    2a72:	9e 01       	movw	r18, r28
    2a74:	23 5f       	subi	r18, 0xF3	; 243
    2a76:	3f 4f       	sbci	r19, 0xFF	; 255
    2a78:	ce 01       	movw	r24, r28
    2a7a:	83 56       	subi	r24, 0x63	; 99
    2a7c:	9f 4f       	sbci	r25, 0xFF	; 255
    2a7e:	a9 01       	movw	r20, r18
    2a80:	bc 01       	movw	r22, r24
    2a82:	ce 01       	movw	r24, r28
    2a84:	01 96       	adiw	r24, 0x01	; 1
    2a86:	0e 94 ae 17 	call	0x2f5c	; 0x2f5c <MainLoop>

	return (0);
    2a8a:	80 e0       	ldi	r24, 0x00	; 0
    2a8c:	90 e0       	ldi	r25, 0x00	; 0
}
    2a8e:	c2 56       	subi	r28, 0x62	; 98
    2a90:	df 4f       	sbci	r29, 0xFF	; 255
    2a92:	0f b6       	in	r0, 0x3f	; 63
    2a94:	f8 94       	cli
    2a96:	de bf       	out	0x3e, r29	; 62
    2a98:	0f be       	out	0x3f, r0	; 63
    2a9a:	cd bf       	out	0x3d, r28	; 61
    2a9c:	df 91       	pop	r29
    2a9e:	cf 91       	pop	r28
    2aa0:	08 95       	ret

00002aa2 <Initialization>:

/* FUNCTIONS */
void Initialization(struct SettingsMenu_values *settinsgMenu_values, int *page,
		struct LCDEXPLOITING_AllPages *lcdPageLabbles) {
    2aa2:	8f 92       	push	r8
    2aa4:	af 92       	push	r10
    2aa6:	cf 92       	push	r12
    2aa8:	ef 92       	push	r14
    2aaa:	0f 93       	push	r16
    2aac:	cf 93       	push	r28
    2aae:	df 93       	push	r29
    2ab0:	cd b7       	in	r28, 0x3d	; 61
    2ab2:	de b7       	in	r29, 0x3e	; 62
    2ab4:	2a 97       	sbiw	r28, 0x0a	; 10
    2ab6:	0f b6       	in	r0, 0x3f	; 63
    2ab8:	f8 94       	cli
    2aba:	de bf       	out	0x3e, r29	; 62
    2abc:	0f be       	out	0x3f, r0	; 63
    2abe:	cd bf       	out	0x3d, r28	; 61
    2ac0:	9e 83       	std	Y+6, r25	; 0x06
    2ac2:	8d 83       	std	Y+5, r24	; 0x05
    2ac4:	78 87       	std	Y+8, r23	; 0x08
    2ac6:	6f 83       	std	Y+7, r22	; 0x07
    2ac8:	5a 87       	std	Y+10, r21	; 0x0a
    2aca:	49 87       	std	Y+9, r20	; 0x09

	UART_Init(9600);  // Initialize UARt at 9600 baud rate
    2acc:	60 e8       	ldi	r22, 0x80	; 128
    2ace:	75 e2       	ldi	r23, 0x25	; 37
    2ad0:	80 e0       	ldi	r24, 0x00	; 0
    2ad2:	90 e0       	ldi	r25, 0x00	; 0
    2ad4:	0e 94 b7 2d 	call	0x5b6e	; 0x5b6e <UART_Init>
	/*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
	LCD_SetUp(PA_0, PA_1, PA_2, P_NC, P_NC, P_NC, P_NC, PA_3, PA_4, PA_5, PA_6);
    2ad8:	86 e0       	ldi	r24, 0x06	; 6
    2ada:	8f 93       	push	r24
    2adc:	85 e0       	ldi	r24, 0x05	; 5
    2ade:	8f 93       	push	r24
    2ae0:	68 94       	set
    2ae2:	88 24       	eor	r8, r8
    2ae4:	82 f8       	bld	r8, 2
    2ae6:	0f 2e       	mov	r0, r31
    2ae8:	f3 e0       	ldi	r31, 0x03	; 3
    2aea:	af 2e       	mov	r10, r31
    2aec:	f0 2d       	mov	r31, r0
    2aee:	cc 24       	eor	r12, r12
    2af0:	ca 94       	dec	r12
    2af2:	ee 24       	eor	r14, r14
    2af4:	ea 94       	dec	r14
    2af6:	0f ef       	ldi	r16, 0xFF	; 255
    2af8:	2f ef       	ldi	r18, 0xFF	; 255
    2afa:	42 e0       	ldi	r20, 0x02	; 2
    2afc:	61 e0       	ldi	r22, 0x01	; 1
    2afe:	80 e0       	ldi	r24, 0x00	; 0
    2b00:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <LCD_SetUp>
    2b04:	0f 90       	pop	r0
    2b06:	0f 90       	pop	r0
	LCD_Init(2, 16);
    2b08:	60 e1       	ldi	r22, 0x10	; 16
    2b0a:	82 e0       	ldi	r24, 0x02	; 2
    2b0c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <LCD_Init>

	DDRB = 0x00;
    2b10:	87 e3       	ldi	r24, 0x37	; 55
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	dc 01       	movw	r26, r24
    2b16:	1c 92       	st	X, r1
	PORTB = 0xff;
    2b18:	88 e3       	ldi	r24, 0x38	; 56
    2b1a:	90 e0       	ldi	r25, 0x00	; 0
    2b1c:	2f ef       	ldi	r18, 0xFF	; 255
    2b1e:	fc 01       	movw	r30, r24
    2b20:	20 83       	st	Z, r18

	PWM_Init();
    2b22:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <PWM_Init>
	PWM_Start();
    2b26:	0e 94 26 0c 	call	0x184c	; 0x184c <PWM_Start>

	LedControl_OFF(0);
    2b2a:	80 e0       	ldi	r24, 0x00	; 0
    2b2c:	90 e0       	ldi	r25, 0x00	; 0
    2b2e:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>

	//reading data from eeprom
	bool firstStart;
	unsigned char eepromAddressFirstStart = 0x01;
    2b32:	81 e0       	ldi	r24, 0x01	; 1
    2b34:	8b 83       	std	Y+3, r24	; 0x03
	firstStart = EEPROM_ReadByte(eepromAddressFirstStart);
    2b36:	8b 81       	ldd	r24, Y+3	; 0x03
    2b38:	88 2f       	mov	r24, r24
    2b3a:	90 e0       	ldi	r25, 0x00	; 0
    2b3c:	0e 94 19 1c 	call	0x3832	; 0x3832 <EEPROM_ReadByte>
    2b40:	98 2f       	mov	r25, r24
    2b42:	81 e0       	ldi	r24, 0x01	; 1
    2b44:	99 23       	and	r25, r25
    2b46:	09 f4       	brne	.+2      	; 0x2b4a <Initialization+0xa8>
    2b48:	80 e0       	ldi	r24, 0x00	; 0
    2b4a:	8c 83       	std	Y+4, r24	; 0x04

	if (!firstStart) {
    2b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4e:	81 e0       	ldi	r24, 0x01	; 1
    2b50:	89 27       	eor	r24, r25
    2b52:	88 23       	and	r24, r24
    2b54:	09 f4       	brne	.+2      	; 0x2b58 <Initialization+0xb6>
    2b56:	8f c0       	rjmp	.+286    	; 0x2c76 <Initialization+0x1d4>
		settinsgMenu_values->eepromAddressBrightness = 0x02;
    2b58:	8d 81       	ldd	r24, Y+5	; 0x05
    2b5a:	9e 81       	ldd	r25, Y+6	; 0x06
    2b5c:	22 e0       	ldi	r18, 0x02	; 2
    2b5e:	dc 01       	movw	r26, r24
    2b60:	2c 93       	st	X, r18
		settinsgMenu_values->pwmBrightness = 50;
    2b62:	8d 81       	ldd	r24, Y+5	; 0x05
    2b64:	9e 81       	ldd	r25, Y+6	; 0x06
    2b66:	22 e3       	ldi	r18, 0x32	; 50
    2b68:	30 e0       	ldi	r19, 0x00	; 0
    2b6a:	fc 01       	movw	r30, r24
    2b6c:	36 83       	std	Z+6, r19	; 0x06
    2b6e:	25 83       	std	Z+5, r18	; 0x05
		settinsgMenu_values->pwmBrightness = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressBrightness);
    2b70:	8d 81       	ldd	r24, Y+5	; 0x05
    2b72:	9e 81       	ldd	r25, Y+6	; 0x06
    2b74:	dc 01       	movw	r26, r24
    2b76:	8c 91       	ld	r24, X
	firstStart = EEPROM_ReadByte(eepromAddressFirstStart);

	if (!firstStart) {
		settinsgMenu_values->eepromAddressBrightness = 0x02;
		settinsgMenu_values->pwmBrightness = 50;
		settinsgMenu_values->pwmBrightness = EEPROM_ReadByte(
    2b78:	88 2f       	mov	r24, r24
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	0e 94 19 1c 	call	0x3832	; 0x3832 <EEPROM_ReadByte>
    2b80:	28 2f       	mov	r18, r24
    2b82:	30 e0       	ldi	r19, 0x00	; 0
    2b84:	8d 81       	ldd	r24, Y+5	; 0x05
    2b86:	9e 81       	ldd	r25, Y+6	; 0x06
    2b88:	fc 01       	movw	r30, r24
    2b8a:	36 83       	std	Z+6, r19	; 0x06
    2b8c:	25 83       	std	Z+5, r18	; 0x05
				settinsgMenu_values->eepromAddressBrightness);
		PWM_SetDutyCycle(1, 100);
    2b8e:	64 e6       	ldi	r22, 0x64	; 100
    2b90:	81 e0       	ldi	r24, 0x01	; 1
    2b92:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <PWM_SetDutyCycle>

		settinsgMenu_values->eepromAddressLedStatus = 0x03;
    2b96:	8d 81       	ldd	r24, Y+5	; 0x05
    2b98:	9e 81       	ldd	r25, Y+6	; 0x06
    2b9a:	23 e0       	ldi	r18, 0x03	; 3
    2b9c:	dc 01       	movw	r26, r24
    2b9e:	11 96       	adiw	r26, 0x01	; 1
    2ba0:	2c 93       	st	X, r18
		settinsgMenu_values->ledStatus = true;
    2ba2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ba4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ba6:	21 e0       	ldi	r18, 0x01	; 1
    2ba8:	fc 01       	movw	r30, r24
    2baa:	27 83       	std	Z+7, r18	; 0x07
		settinsgMenu_values->ledStatus = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressLedStatus);
    2bac:	8d 81       	ldd	r24, Y+5	; 0x05
    2bae:	9e 81       	ldd	r25, Y+6	; 0x06
    2bb0:	dc 01       	movw	r26, r24
    2bb2:	11 96       	adiw	r26, 0x01	; 1
    2bb4:	8c 91       	ld	r24, X
				settinsgMenu_values->eepromAddressBrightness);
		PWM_SetDutyCycle(1, 100);

		settinsgMenu_values->eepromAddressLedStatus = 0x03;
		settinsgMenu_values->ledStatus = true;
		settinsgMenu_values->ledStatus = EEPROM_ReadByte(
    2bb6:	88 2f       	mov	r24, r24
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	0e 94 19 1c 	call	0x3832	; 0x3832 <EEPROM_ReadByte>
    2bbe:	21 e0       	ldi	r18, 0x01	; 1
    2bc0:	88 23       	and	r24, r24
    2bc2:	09 f4       	brne	.+2      	; 0x2bc6 <Initialization+0x124>
    2bc4:	20 e0       	ldi	r18, 0x00	; 0
    2bc6:	8d 81       	ldd	r24, Y+5	; 0x05
    2bc8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bca:	fc 01       	movw	r30, r24
    2bcc:	27 83       	std	Z+7, r18	; 0x07
				settinsgMenu_values->eepromAddressLedStatus);

		settinsgMenu_values->eepromAddressTimeDelay = 0x04;
    2bce:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd0:	9e 81       	ldd	r25, Y+6	; 0x06
    2bd2:	24 e0       	ldi	r18, 0x04	; 4
    2bd4:	dc 01       	movw	r26, r24
    2bd6:	12 96       	adiw	r26, 0x02	; 2
    2bd8:	2c 93       	st	X, r18
		settinsgMenu_values->timeDelay = 100;
    2bda:	8d 81       	ldd	r24, Y+5	; 0x05
    2bdc:	9e 81       	ldd	r25, Y+6	; 0x06
    2bde:	24 e6       	ldi	r18, 0x64	; 100
    2be0:	30 e0       	ldi	r19, 0x00	; 0
    2be2:	fc 01       	movw	r30, r24
    2be4:	32 87       	std	Z+10, r19	; 0x0a
    2be6:	21 87       	std	Z+9, r18	; 0x09
		settinsgMenu_values->timeDelay = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressTimeDelay);
    2be8:	8d 81       	ldd	r24, Y+5	; 0x05
    2bea:	9e 81       	ldd	r25, Y+6	; 0x06
    2bec:	dc 01       	movw	r26, r24
    2bee:	12 96       	adiw	r26, 0x02	; 2
    2bf0:	8c 91       	ld	r24, X
		settinsgMenu_values->ledStatus = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressLedStatus);

		settinsgMenu_values->eepromAddressTimeDelay = 0x04;
		settinsgMenu_values->timeDelay = 100;
		settinsgMenu_values->timeDelay = EEPROM_ReadByte(
    2bf2:	88 2f       	mov	r24, r24
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	0e 94 19 1c 	call	0x3832	; 0x3832 <EEPROM_ReadByte>
    2bfa:	28 2f       	mov	r18, r24
    2bfc:	30 e0       	ldi	r19, 0x00	; 0
    2bfe:	8d 81       	ldd	r24, Y+5	; 0x05
    2c00:	9e 81       	ldd	r25, Y+6	; 0x06
    2c02:	fc 01       	movw	r30, r24
    2c04:	32 87       	std	Z+10, r19	; 0x0a
    2c06:	21 87       	std	Z+9, r18	; 0x09
				settinsgMenu_values->eepromAddressTimeDelay);

		settinsgMenu_values->eepromAddressDebugMode = 0x05;
    2c08:	8d 81       	ldd	r24, Y+5	; 0x05
    2c0a:	9e 81       	ldd	r25, Y+6	; 0x06
    2c0c:	25 e0       	ldi	r18, 0x05	; 5
    2c0e:	dc 01       	movw	r26, r24
    2c10:	13 96       	adiw	r26, 0x03	; 3
    2c12:	2c 93       	st	X, r18
		settinsgMenu_values->debugMode = false;
    2c14:	8d 81       	ldd	r24, Y+5	; 0x05
    2c16:	9e 81       	ldd	r25, Y+6	; 0x06
    2c18:	fc 01       	movw	r30, r24
    2c1a:	10 86       	std	Z+8, r1	; 0x08
		settinsgMenu_values->debugMode = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressDebugMode);
    2c1c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c1e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c20:	dc 01       	movw	r26, r24
    2c22:	13 96       	adiw	r26, 0x03	; 3
    2c24:	8c 91       	ld	r24, X
		settinsgMenu_values->timeDelay = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressTimeDelay);

		settinsgMenu_values->eepromAddressDebugMode = 0x05;
		settinsgMenu_values->debugMode = false;
		settinsgMenu_values->debugMode = EEPROM_ReadByte(
    2c26:	88 2f       	mov	r24, r24
    2c28:	90 e0       	ldi	r25, 0x00	; 0
    2c2a:	0e 94 19 1c 	call	0x3832	; 0x3832 <EEPROM_ReadByte>
    2c2e:	21 e0       	ldi	r18, 0x01	; 1
    2c30:	88 23       	and	r24, r24
    2c32:	09 f4       	brne	.+2      	; 0x2c36 <Initialization+0x194>
    2c34:	20 e0       	ldi	r18, 0x00	; 0
    2c36:	8d 81       	ldd	r24, Y+5	; 0x05
    2c38:	9e 81       	ldd	r25, Y+6	; 0x06
    2c3a:	fc 01       	movw	r30, r24
    2c3c:	20 87       	std	Z+8, r18	; 0x08
				settinsgMenu_values->eepromAddressDebugMode);

		settinsgMenu_values->eepromAddressShowChangingPage = 0x06;
    2c3e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c40:	9e 81       	ldd	r25, Y+6	; 0x06
    2c42:	26 e0       	ldi	r18, 0x06	; 6
    2c44:	dc 01       	movw	r26, r24
    2c46:	14 96       	adiw	r26, 0x04	; 4
    2c48:	2c 93       	st	X, r18
		settinsgMenu_values->showChangingPage = false;
    2c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c4c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c4e:	fc 01       	movw	r30, r24
    2c50:	13 86       	std	Z+11, r1	; 0x0b
		settinsgMenu_values->showChangingPage = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressShowChangingPage);
    2c52:	8d 81       	ldd	r24, Y+5	; 0x05
    2c54:	9e 81       	ldd	r25, Y+6	; 0x06
    2c56:	dc 01       	movw	r26, r24
    2c58:	14 96       	adiw	r26, 0x04	; 4
    2c5a:	8c 91       	ld	r24, X
		settinsgMenu_values->debugMode = EEPROM_ReadByte(
				settinsgMenu_values->eepromAddressDebugMode);

		settinsgMenu_values->eepromAddressShowChangingPage = 0x06;
		settinsgMenu_values->showChangingPage = false;
		settinsgMenu_values->showChangingPage = EEPROM_ReadByte(
    2c5c:	88 2f       	mov	r24, r24
    2c5e:	90 e0       	ldi	r25, 0x00	; 0
    2c60:	0e 94 19 1c 	call	0x3832	; 0x3832 <EEPROM_ReadByte>
    2c64:	21 e0       	ldi	r18, 0x01	; 1
    2c66:	88 23       	and	r24, r24
    2c68:	09 f4       	brne	.+2      	; 0x2c6c <Initialization+0x1ca>
    2c6a:	20 e0       	ldi	r18, 0x00	; 0
    2c6c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c6e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c70:	fc 01       	movw	r30, r24
    2c72:	23 87       	std	Z+11, r18	; 0x0b
    2c74:	b3 c0       	rjmp	.+358    	; 0x2ddc <Initialization+0x33a>
				settinsgMenu_values->eepromAddressShowChangingPage);
	} else {
		LCD_Clear();
    2c76:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
		LCD_XYPrintf(0, 0, "* First start  *");
    2c7a:	81 e0       	ldi	r24, 0x01	; 1
    2c7c:	92 e0       	ldi	r25, 0x02	; 2
    2c7e:	89 2f       	mov	r24, r25
    2c80:	8f 93       	push	r24
    2c82:	81 e0       	ldi	r24, 0x01	; 1
    2c84:	92 e0       	ldi	r25, 0x02	; 2
    2c86:	8f 93       	push	r24
    2c88:	1f 92       	push	r1
    2c8a:	1f 92       	push	r1
    2c8c:	1f 92       	push	r1
    2c8e:	1f 92       	push	r1
    2c90:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    2c94:	0f 90       	pop	r0
    2c96:	0f 90       	pop	r0
    2c98:	0f 90       	pop	r0
    2c9a:	0f 90       	pop	r0
    2c9c:	0f 90       	pop	r0
    2c9e:	0f 90       	pop	r0
		LCD_XYPrintf(0, 1, "memory config...");
    2ca0:	82 e1       	ldi	r24, 0x12	; 18
    2ca2:	92 e0       	ldi	r25, 0x02	; 2
    2ca4:	89 2f       	mov	r24, r25
    2ca6:	8f 93       	push	r24
    2ca8:	82 e1       	ldi	r24, 0x12	; 18
    2caa:	92 e0       	ldi	r25, 0x02	; 2
    2cac:	8f 93       	push	r24
    2cae:	1f 92       	push	r1
    2cb0:	81 e0       	ldi	r24, 0x01	; 1
    2cb2:	8f 93       	push	r24
    2cb4:	1f 92       	push	r1
    2cb6:	1f 92       	push	r1
    2cb8:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    2cbc:	0f 90       	pop	r0
    2cbe:	0f 90       	pop	r0
    2cc0:	0f 90       	pop	r0
    2cc2:	0f 90       	pop	r0
    2cc4:	0f 90       	pop	r0
    2cc6:	0f 90       	pop	r0
		settinsgMenu_values->showChangingPage = false;
    2cc8:	8d 81       	ldd	r24, Y+5	; 0x05
    2cca:	9e 81       	ldd	r25, Y+6	; 0x06
    2ccc:	dc 01       	movw	r26, r24
    2cce:	1b 96       	adiw	r26, 0x0b	; 11
    2cd0:	1c 92       	st	X, r1
		settinsgMenu_values->pwmBrightness = 50;
    2cd2:	8d 81       	ldd	r24, Y+5	; 0x05
    2cd4:	9e 81       	ldd	r25, Y+6	; 0x06
    2cd6:	22 e3       	ldi	r18, 0x32	; 50
    2cd8:	30 e0       	ldi	r19, 0x00	; 0
    2cda:	fc 01       	movw	r30, r24
    2cdc:	36 83       	std	Z+6, r19	; 0x06
    2cde:	25 83       	std	Z+5, r18	; 0x05
		settinsgMenu_values->ledStatus = true;
    2ce0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ce2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ce4:	21 e0       	ldi	r18, 0x01	; 1
    2ce6:	dc 01       	movw	r26, r24
    2ce8:	17 96       	adiw	r26, 0x07	; 7
    2cea:	2c 93       	st	X, r18
		settinsgMenu_values->timeDelay = 100;
    2cec:	8d 81       	ldd	r24, Y+5	; 0x05
    2cee:	9e 81       	ldd	r25, Y+6	; 0x06
    2cf0:	24 e6       	ldi	r18, 0x64	; 100
    2cf2:	30 e0       	ldi	r19, 0x00	; 0
    2cf4:	fc 01       	movw	r30, r24
    2cf6:	32 87       	std	Z+10, r19	; 0x0a
    2cf8:	21 87       	std	Z+9, r18	; 0x09
		settinsgMenu_values->debugMode = false;
    2cfa:	8d 81       	ldd	r24, Y+5	; 0x05
    2cfc:	9e 81       	ldd	r25, Y+6	; 0x06
    2cfe:	dc 01       	movw	r26, r24
    2d00:	18 96       	adiw	r26, 0x08	; 8
    2d02:	1c 92       	st	X, r1
		firstStart = false;
    2d04:	1c 82       	std	Y+4, r1	; 0x04
		EEPROM_WriteByte(eepromAddressFirstStart, firstStart);
    2d06:	2c 81       	ldd	r18, Y+4	; 0x04
    2d08:	8b 81       	ldd	r24, Y+3	; 0x03
    2d0a:	88 2f       	mov	r24, r24
    2d0c:	90 e0       	ldi	r25, 0x00	; 0
    2d0e:	62 2f       	mov	r22, r18
    2d10:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressBrightness,
				settinsgMenu_values->pwmBrightness);
    2d14:	8d 81       	ldd	r24, Y+5	; 0x05
    2d16:	9e 81       	ldd	r25, Y+6	; 0x06
    2d18:	fc 01       	movw	r30, r24
    2d1a:	85 81       	ldd	r24, Z+5	; 0x05
    2d1c:	96 81       	ldd	r25, Z+6	; 0x06
		settinsgMenu_values->ledStatus = true;
		settinsgMenu_values->timeDelay = 100;
		settinsgMenu_values->debugMode = false;
		firstStart = false;
		EEPROM_WriteByte(eepromAddressFirstStart, firstStart);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressBrightness,
    2d1e:	28 2f       	mov	r18, r24
    2d20:	8d 81       	ldd	r24, Y+5	; 0x05
    2d22:	9e 81       	ldd	r25, Y+6	; 0x06
    2d24:	dc 01       	movw	r26, r24
    2d26:	8c 91       	ld	r24, X
    2d28:	88 2f       	mov	r24, r24
    2d2a:	90 e0       	ldi	r25, 0x00	; 0
    2d2c:	62 2f       	mov	r22, r18
    2d2e:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
				settinsgMenu_values->pwmBrightness);
		DELAY_ms(200);
    2d32:	88 ec       	ldi	r24, 0xC8	; 200
    2d34:	90 e0       	ldi	r25, 0x00	; 0
    2d36:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressLedStatus,
				settinsgMenu_values->ledStatus);
    2d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d3e:	fc 01       	movw	r30, r24
    2d40:	87 81       	ldd	r24, Z+7	; 0x07
		firstStart = false;
		EEPROM_WriteByte(eepromAddressFirstStart, firstStart);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressBrightness,
				settinsgMenu_values->pwmBrightness);
		DELAY_ms(200);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressLedStatus,
    2d42:	28 2f       	mov	r18, r24
    2d44:	8d 81       	ldd	r24, Y+5	; 0x05
    2d46:	9e 81       	ldd	r25, Y+6	; 0x06
    2d48:	dc 01       	movw	r26, r24
    2d4a:	11 96       	adiw	r26, 0x01	; 1
    2d4c:	8c 91       	ld	r24, X
    2d4e:	88 2f       	mov	r24, r24
    2d50:	90 e0       	ldi	r25, 0x00	; 0
    2d52:	62 2f       	mov	r22, r18
    2d54:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
				settinsgMenu_values->ledStatus);
		DELAY_ms(200);
    2d58:	88 ec       	ldi	r24, 0xC8	; 200
    2d5a:	90 e0       	ldi	r25, 0x00	; 0
    2d5c:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressTimeDelay,
				settinsgMenu_values->timeDelay);
    2d60:	8d 81       	ldd	r24, Y+5	; 0x05
    2d62:	9e 81       	ldd	r25, Y+6	; 0x06
    2d64:	fc 01       	movw	r30, r24
    2d66:	81 85       	ldd	r24, Z+9	; 0x09
    2d68:	92 85       	ldd	r25, Z+10	; 0x0a
				settinsgMenu_values->pwmBrightness);
		DELAY_ms(200);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressLedStatus,
				settinsgMenu_values->ledStatus);
		DELAY_ms(200);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressTimeDelay,
    2d6a:	28 2f       	mov	r18, r24
    2d6c:	8d 81       	ldd	r24, Y+5	; 0x05
    2d6e:	9e 81       	ldd	r25, Y+6	; 0x06
    2d70:	dc 01       	movw	r26, r24
    2d72:	12 96       	adiw	r26, 0x02	; 2
    2d74:	8c 91       	ld	r24, X
    2d76:	88 2f       	mov	r24, r24
    2d78:	90 e0       	ldi	r25, 0x00	; 0
    2d7a:	62 2f       	mov	r22, r18
    2d7c:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
				settinsgMenu_values->timeDelay);
		DELAY_ms(200);
    2d80:	88 ec       	ldi	r24, 0xC8	; 200
    2d82:	90 e0       	ldi	r25, 0x00	; 0
    2d84:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressDebugMode,
				settinsgMenu_values->debugMode);
    2d88:	8d 81       	ldd	r24, Y+5	; 0x05
    2d8a:	9e 81       	ldd	r25, Y+6	; 0x06
    2d8c:	fc 01       	movw	r30, r24
    2d8e:	80 85       	ldd	r24, Z+8	; 0x08
				settinsgMenu_values->ledStatus);
		DELAY_ms(200);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressTimeDelay,
				settinsgMenu_values->timeDelay);
		DELAY_ms(200);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressDebugMode,
    2d90:	28 2f       	mov	r18, r24
    2d92:	8d 81       	ldd	r24, Y+5	; 0x05
    2d94:	9e 81       	ldd	r25, Y+6	; 0x06
    2d96:	dc 01       	movw	r26, r24
    2d98:	13 96       	adiw	r26, 0x03	; 3
    2d9a:	8c 91       	ld	r24, X
    2d9c:	88 2f       	mov	r24, r24
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	62 2f       	mov	r22, r18
    2da2:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
				settinsgMenu_values->debugMode);
		DELAY_ms(200);
    2da6:	88 ec       	ldi	r24, 0xC8	; 200
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressShowChangingPage,
				settinsgMenu_values->showChangingPage);
    2dae:	8d 81       	ldd	r24, Y+5	; 0x05
    2db0:	9e 81       	ldd	r25, Y+6	; 0x06
    2db2:	fc 01       	movw	r30, r24
    2db4:	83 85       	ldd	r24, Z+11	; 0x0b
				settinsgMenu_values->timeDelay);
		DELAY_ms(200);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressDebugMode,
				settinsgMenu_values->debugMode);
		DELAY_ms(200);
		EEPROM_WriteByte(settinsgMenu_values->eepromAddressShowChangingPage,
    2db6:	28 2f       	mov	r18, r24
    2db8:	8d 81       	ldd	r24, Y+5	; 0x05
    2dba:	9e 81       	ldd	r25, Y+6	; 0x06
    2dbc:	dc 01       	movw	r26, r24
    2dbe:	14 96       	adiw	r26, 0x04	; 4
    2dc0:	8c 91       	ld	r24, X
    2dc2:	88 2f       	mov	r24, r24
    2dc4:	90 e0       	ldi	r25, 0x00	; 0
    2dc6:	62 2f       	mov	r22, r18
    2dc8:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
				settinsgMenu_values->showChangingPage);
		DELAY_ms(200);
    2dcc:	88 ec       	ldi	r24, 0xC8	; 200
    2dce:	90 e0       	ldi	r25, 0x00	; 0
    2dd0:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
		DELAY_ms(200);
    2dd4:	88 ec       	ldi	r24, 0xC8	; 200
    2dd6:	90 e0       	ldi	r25, 0x00	; 0
    2dd8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	}

	//starting program
	LCD_InitializeSymbols();
    2ddc:	0e 94 da 2c 	call	0x59b4	; 0x59b4 <LCD_InitializeSymbols>
	LCD_CmdWrite(0x0C); //turn cursor off
    2de0:	8c e0       	ldi	r24, 0x0C	; 12
    2de2:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
	if (settinsgMenu_values->ledStatus)
    2de6:	8d 81       	ldd	r24, Y+5	; 0x05
    2de8:	9e 81       	ldd	r25, Y+6	; 0x06
    2dea:	fc 01       	movw	r30, r24
    2dec:	87 81       	ldd	r24, Z+7	; 0x07
    2dee:	88 23       	and	r24, r24
    2df0:	29 f0       	breq	.+10     	; 0x2dfc <Initialization+0x35a>
		LedControl_ON(1000);
    2df2:	88 ee       	ldi	r24, 0xE8	; 232
    2df4:	93 e0       	ldi	r25, 0x03	; 3
    2df6:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
    2dfa:	04 c0       	rjmp	.+8      	; 0x2e04 <Initialization+0x362>
	else
		DELAY_ms(1000);
    2dfc:	88 ee       	ldi	r24, 0xE8	; 232
    2dfe:	93 e0       	ldi	r25, 0x03	; 3
    2e00:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	LCD_Clear();
    2e04:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
	LCD_XYPrintf(3, 0, "USB Media");
    2e08:	83 e2       	ldi	r24, 0x23	; 35
    2e0a:	92 e0       	ldi	r25, 0x02	; 2
    2e0c:	89 2f       	mov	r24, r25
    2e0e:	8f 93       	push	r24
    2e10:	83 e2       	ldi	r24, 0x23	; 35
    2e12:	92 e0       	ldi	r25, 0x02	; 2
    2e14:	8f 93       	push	r24
    2e16:	1f 92       	push	r1
    2e18:	1f 92       	push	r1
    2e1a:	1f 92       	push	r1
    2e1c:	83 e0       	ldi	r24, 0x03	; 3
    2e1e:	8f 93       	push	r24
    2e20:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    2e24:	0f 90       	pop	r0
    2e26:	0f 90       	pop	r0
    2e28:	0f 90       	pop	r0
    2e2a:	0f 90       	pop	r0
    2e2c:	0f 90       	pop	r0
    2e2e:	0f 90       	pop	r0
	LCD_XYPrintf(3, 1, "Controller");
    2e30:	8d e2       	ldi	r24, 0x2D	; 45
    2e32:	92 e0       	ldi	r25, 0x02	; 2
    2e34:	89 2f       	mov	r24, r25
    2e36:	8f 93       	push	r24
    2e38:	8d e2       	ldi	r24, 0x2D	; 45
    2e3a:	92 e0       	ldi	r25, 0x02	; 2
    2e3c:	8f 93       	push	r24
    2e3e:	1f 92       	push	r1
    2e40:	81 e0       	ldi	r24, 0x01	; 1
    2e42:	8f 93       	push	r24
    2e44:	1f 92       	push	r1
    2e46:	83 e0       	ldi	r24, 0x03	; 3
    2e48:	8f 93       	push	r24
    2e4a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    2e4e:	0f 90       	pop	r0
    2e50:	0f 90       	pop	r0
    2e52:	0f 90       	pop	r0
    2e54:	0f 90       	pop	r0
    2e56:	0f 90       	pop	r0
    2e58:	0f 90       	pop	r0
	for (int clk = 0; clk < settinsgMenu_values->pwmBrightness; clk++) {
    2e5a:	1a 82       	std	Y+2, r1	; 0x02
    2e5c:	19 82       	std	Y+1, r1	; 0x01
    2e5e:	0d c0       	rjmp	.+26     	; 0x2e7a <Initialization+0x3d8>
		LCDEXPLOITING_SetLctBrightness(clk);
    2e60:	89 81       	ldd	r24, Y+1	; 0x01
    2e62:	9a 81       	ldd	r25, Y+2	; 0x02
    2e64:	0e 94 da 02 	call	0x5b4	; 0x5b4 <LCDEXPLOITING_SetLctBrightness>
		DELAY_ms(20);
    2e68:	84 e1       	ldi	r24, 0x14	; 20
    2e6a:	90 e0       	ldi	r25, 0x00	; 0
    2e6c:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	else
		DELAY_ms(1000);
	LCD_Clear();
	LCD_XYPrintf(3, 0, "USB Media");
	LCD_XYPrintf(3, 1, "Controller");
	for (int clk = 0; clk < settinsgMenu_values->pwmBrightness; clk++) {
    2e70:	89 81       	ldd	r24, Y+1	; 0x01
    2e72:	9a 81       	ldd	r25, Y+2	; 0x02
    2e74:	01 96       	adiw	r24, 0x01	; 1
    2e76:	9a 83       	std	Y+2, r25	; 0x02
    2e78:	89 83       	std	Y+1, r24	; 0x01
    2e7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e7e:	dc 01       	movw	r26, r24
    2e80:	15 96       	adiw	r26, 0x05	; 5
    2e82:	2d 91       	ld	r18, X+
    2e84:	3c 91       	ld	r19, X
    2e86:	16 97       	sbiw	r26, 0x06	; 6
    2e88:	89 81       	ldd	r24, Y+1	; 0x01
    2e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e8c:	82 17       	cp	r24, r18
    2e8e:	93 07       	cpc	r25, r19
    2e90:	3c f3       	brlt	.-50     	; 0x2e60 <Initialization+0x3be>
		LCDEXPLOITING_SetLctBrightness(clk);
		DELAY_ms(20);
	}
	DELAY_ms(200);
    2e92:	88 ec       	ldi	r24, 0xC8	; 200
    2e94:	90 e0       	ldi	r25, 0x00	; 0
    2e96:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	LCD_Clear();
    2e9a:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>

	*page = 1;
    2e9e:	8f 81       	ldd	r24, Y+7	; 0x07
    2ea0:	98 85       	ldd	r25, Y+8	; 0x08
    2ea2:	21 e0       	ldi	r18, 0x01	; 1
    2ea4:	30 e0       	ldi	r19, 0x00	; 0
    2ea6:	fc 01       	movw	r30, r24
    2ea8:	31 83       	std	Z+1, r19	; 0x01
    2eaa:	20 83       	st	Z, r18

	if (settinsgMenu_values->ledStatus)
    2eac:	8d 81       	ldd	r24, Y+5	; 0x05
    2eae:	9e 81       	ldd	r25, Y+6	; 0x06
    2eb0:	dc 01       	movw	r26, r24
    2eb2:	17 96       	adiw	r26, 0x07	; 7
    2eb4:	8c 91       	ld	r24, X
    2eb6:	17 97       	sbiw	r26, 0x07	; 7
    2eb8:	88 23       	and	r24, r24
    2eba:	29 f0       	breq	.+10     	; 0x2ec6 <Initialization+0x424>
		LedControl_OFF(100);
    2ebc:	84 e6       	ldi	r24, 0x64	; 100
    2ebe:	90 e0       	ldi	r25, 0x00	; 0
    2ec0:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
    2ec4:	04 c0       	rjmp	.+8      	; 0x2ece <Initialization+0x42c>
	else
		DELAY_ms(100);
    2ec6:	84 e6       	ldi	r24, 0x64	; 100
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	if (settinsgMenu_values->ledStatus)
    2ece:	8d 81       	ldd	r24, Y+5	; 0x05
    2ed0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ed2:	fc 01       	movw	r30, r24
    2ed4:	87 81       	ldd	r24, Z+7	; 0x07
    2ed6:	88 23       	and	r24, r24
    2ed8:	29 f0       	breq	.+10     	; 0x2ee4 <Initialization+0x442>
		LedControl_ON(100);
    2eda:	84 e6       	ldi	r24, 0x64	; 100
    2edc:	90 e0       	ldi	r25, 0x00	; 0
    2ede:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
    2ee2:	04 c0       	rjmp	.+8      	; 0x2eec <Initialization+0x44a>
	else
		DELAY_ms(100);
    2ee4:	84 e6       	ldi	r24, 0x64	; 100
    2ee6:	90 e0       	ldi	r25, 0x00	; 0
    2ee8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	screen_show_initialize(settinsgMenu_values->ledStatus, lcdPageLabbles,
    2eec:	8d 81       	ldd	r24, Y+5	; 0x05
    2eee:	9e 81       	ldd	r25, Y+6	; 0x06
    2ef0:	dc 01       	movw	r26, r24
    2ef2:	17 96       	adiw	r26, 0x07	; 7
    2ef4:	ec 91       	ld	r30, X
    2ef6:	2d 81       	ldd	r18, Y+5	; 0x05
    2ef8:	3e 81       	ldd	r19, Y+6	; 0x06
    2efa:	89 85       	ldd	r24, Y+9	; 0x09
    2efc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2efe:	a9 01       	movw	r20, r18
    2f00:	bc 01       	movw	r22, r24
    2f02:	8e 2f       	mov	r24, r30
    2f04:	0e 94 02 03 	call	0x604	; 0x604 <screen_show_initialize>
			settinsgMenu_values);
	LCDEXPLOITING_showPage(*page, lcdPageLabbles);
    2f08:	8f 81       	ldd	r24, Y+7	; 0x07
    2f0a:	98 85       	ldd	r25, Y+8	; 0x08
    2f0c:	fc 01       	movw	r30, r24
    2f0e:	80 81       	ld	r24, Z
    2f10:	91 81       	ldd	r25, Z+1	; 0x01
    2f12:	29 85       	ldd	r18, Y+9	; 0x09
    2f14:	3a 85       	ldd	r19, Y+10	; 0x0a
    2f16:	b9 01       	movw	r22, r18
    2f18:	0e 94 67 08 	call	0x10ce	; 0x10ce <LCDEXPLOITING_showPage>
	PORTB |= (1 << 0);
    2f1c:	88 e3       	ldi	r24, 0x38	; 56
    2f1e:	90 e0       	ldi	r25, 0x00	; 0
    2f20:	28 e3       	ldi	r18, 0x38	; 56
    2f22:	30 e0       	ldi	r19, 0x00	; 0
    2f24:	d9 01       	movw	r26, r18
    2f26:	2c 91       	ld	r18, X
    2f28:	21 60       	ori	r18, 0x01	; 1
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	20 83       	st	Z, r18

	LCDEXPLOITING_SetLctBrightness(settinsgMenu_values->pwmBrightness);
    2f2e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f30:	9e 81       	ldd	r25, Y+6	; 0x06
    2f32:	dc 01       	movw	r26, r24
    2f34:	15 96       	adiw	r26, 0x05	; 5
    2f36:	8d 91       	ld	r24, X+
    2f38:	9c 91       	ld	r25, X
    2f3a:	16 97       	sbiw	r26, 0x06	; 6
    2f3c:	0e 94 da 02 	call	0x5b4	; 0x5b4 <LCDEXPLOITING_SetLctBrightness>
}
    2f40:	2a 96       	adiw	r28, 0x0a	; 10
    2f42:	0f b6       	in	r0, 0x3f	; 63
    2f44:	f8 94       	cli
    2f46:	de bf       	out	0x3e, r29	; 62
    2f48:	0f be       	out	0x3f, r0	; 63
    2f4a:	cd bf       	out	0x3d, r28	; 61
    2f4c:	df 91       	pop	r29
    2f4e:	cf 91       	pop	r28
    2f50:	0f 91       	pop	r16
    2f52:	ef 90       	pop	r14
    2f54:	cf 90       	pop	r12
    2f56:	af 90       	pop	r10
    2f58:	8f 90       	pop	r8
    2f5a:	08 95       	ret

00002f5c <MainLoop>:

void MainLoop(struct SettingsMenu_values *settinsgMenu_values, int *page,
		struct LCDEXPLOITING_AllPages *lcdPageLabbles) {
    2f5c:	cf 93       	push	r28
    2f5e:	df 93       	push	r29
    2f60:	cd b7       	in	r28, 0x3d	; 61
    2f62:	de b7       	in	r29, 0x3e	; 62
    2f64:	2c 97       	sbiw	r28, 0x0c	; 12
    2f66:	0f b6       	in	r0, 0x3f	; 63
    2f68:	f8 94       	cli
    2f6a:	de bf       	out	0x3e, r29	; 62
    2f6c:	0f be       	out	0x3f, r0	; 63
    2f6e:	cd bf       	out	0x3d, r28	; 61
    2f70:	98 87       	std	Y+8, r25	; 0x08
    2f72:	8f 83       	std	Y+7, r24	; 0x07
    2f74:	7a 87       	std	Y+10, r23	; 0x0a
    2f76:	69 87       	std	Y+9, r22	; 0x09
    2f78:	5c 87       	std	Y+12, r21	; 0x0c
    2f7a:	4b 87       	std	Y+11, r20	; 0x0b

	int time = 200;
    2f7c:	88 ec       	ldi	r24, 0xC8	; 200
    2f7e:	90 e0       	ldi	r25, 0x00	; 0
    2f80:	9a 83       	std	Y+2, r25	; 0x02
    2f82:	89 83       	std	Y+1, r24	; 0x01
	int clkPressedButton = 0;
    2f84:	1c 82       	std	Y+4, r1	; 0x04
    2f86:	1b 82       	std	Y+3, r1	; 0x03

	int refreshClock= 0;
    2f88:	1e 82       	std	Y+6, r1	; 0x06
    2f8a:	1d 82       	std	Y+5, r1	; 0x05
	while (1) {
		if (BTN_LEFT || BTN_RIGHT) {
    2f8c:	86 e3       	ldi	r24, 0x36	; 54
    2f8e:	90 e0       	ldi	r25, 0x00	; 0
    2f90:	fc 01       	movw	r30, r24
    2f92:	80 81       	ld	r24, Z
    2f94:	88 2f       	mov	r24, r24
    2f96:	90 e0       	ldi	r25, 0x00	; 0
    2f98:	82 70       	andi	r24, 0x02	; 2
    2f9a:	99 27       	eor	r25, r25
    2f9c:	00 97       	sbiw	r24, 0x00	; 0
    2f9e:	59 f0       	breq	.+22     	; 0x2fb6 <MainLoop+0x5a>
    2fa0:	86 e3       	ldi	r24, 0x36	; 54
    2fa2:	90 e0       	ldi	r25, 0x00	; 0
    2fa4:	fc 01       	movw	r30, r24
    2fa6:	80 81       	ld	r24, Z
    2fa8:	88 2f       	mov	r24, r24
    2faa:	90 e0       	ldi	r25, 0x00	; 0
    2fac:	81 70       	andi	r24, 0x01	; 1
    2fae:	99 27       	eor	r25, r25
    2fb0:	00 97       	sbiw	r24, 0x00	; 0
    2fb2:	09 f0       	breq	.+2      	; 0x2fb6 <MainLoop+0x5a>
    2fb4:	c7 c0       	rjmp	.+398    	; 0x3144 <MainLoop+0x1e8>
			if (BTN_RIGHT && ((*page) < 4)) {
    2fb6:	86 e3       	ldi	r24, 0x36	; 54
    2fb8:	90 e0       	ldi	r25, 0x00	; 0
    2fba:	fc 01       	movw	r30, r24
    2fbc:	80 81       	ld	r24, Z
    2fbe:	88 2f       	mov	r24, r24
    2fc0:	90 e0       	ldi	r25, 0x00	; 0
    2fc2:	81 70       	andi	r24, 0x01	; 1
    2fc4:	99 27       	eor	r25, r25
    2fc6:	00 97       	sbiw	r24, 0x00	; 0
    2fc8:	09 f0       	breq	.+2      	; 0x2fcc <MainLoop+0x70>
    2fca:	59 c0       	rjmp	.+178    	; 0x307e <MainLoop+0x122>
    2fcc:	89 85       	ldd	r24, Y+9	; 0x09
    2fce:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	80 81       	ld	r24, Z
    2fd4:	91 81       	ldd	r25, Z+1	; 0x01
    2fd6:	84 30       	cpi	r24, 0x04	; 4
    2fd8:	91 05       	cpc	r25, r1
    2fda:	0c f0       	brlt	.+2      	; 0x2fde <MainLoop+0x82>
    2fdc:	50 c0       	rjmp	.+160    	; 0x307e <MainLoop+0x122>
				if (settinsgMenu_values->ledStatus)
    2fde:	8f 81       	ldd	r24, Y+7	; 0x07
    2fe0:	98 85       	ldd	r25, Y+8	; 0x08
    2fe2:	fc 01       	movw	r30, r24
    2fe4:	87 81       	ldd	r24, Z+7	; 0x07
    2fe6:	88 23       	and	r24, r24
    2fe8:	29 f0       	breq	.+10     	; 0x2ff4 <MainLoop+0x98>
					LedControl_ON(100);
    2fea:	84 e6       	ldi	r24, 0x64	; 100
    2fec:	90 e0       	ldi	r25, 0x00	; 0
    2fee:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
    2ff2:	04 c0       	rjmp	.+8      	; 0x2ffc <MainLoop+0xa0>
				else
					DELAY_ms(100);
    2ff4:	84 e6       	ldi	r24, 0x64	; 100
    2ff6:	90 e0       	ldi	r25, 0x00	; 0
    2ff8:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				(*page)++;
    2ffc:	89 85       	ldd	r24, Y+9	; 0x09
    2ffe:	9a 85       	ldd	r25, Y+10	; 0x0a
    3000:	fc 01       	movw	r30, r24
    3002:	80 81       	ld	r24, Z
    3004:	91 81       	ldd	r25, Z+1	; 0x01
    3006:	9c 01       	movw	r18, r24
    3008:	2f 5f       	subi	r18, 0xFF	; 255
    300a:	3f 4f       	sbci	r19, 0xFF	; 255
    300c:	89 85       	ldd	r24, Y+9	; 0x09
    300e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3010:	fc 01       	movw	r30, r24
    3012:	31 83       	std	Z+1, r19	; 0x01
    3014:	20 83       	st	Z, r18
				ShowPage(500, *page, settinsgMenu_values->showChangingPage);
    3016:	8f 81       	ldd	r24, Y+7	; 0x07
    3018:	98 85       	ldd	r25, Y+8	; 0x08
    301a:	fc 01       	movw	r30, r24
    301c:	23 85       	ldd	r18, Z+11	; 0x0b
    301e:	89 85       	ldd	r24, Y+9	; 0x09
    3020:	9a 85       	ldd	r25, Y+10	; 0x0a
    3022:	fc 01       	movw	r30, r24
    3024:	80 81       	ld	r24, Z
    3026:	91 81       	ldd	r25, Z+1	; 0x01
    3028:	42 2f       	mov	r20, r18
    302a:	bc 01       	movw	r22, r24
    302c:	84 ef       	ldi	r24, 0xF4	; 244
    302e:	91 e0       	ldi	r25, 0x01	; 1
    3030:	0e 94 84 19 	call	0x3308	; 0x3308 <ShowPage>
				LCDEXPLOITING_showPage(*page, lcdPageLabbles);
    3034:	89 85       	ldd	r24, Y+9	; 0x09
    3036:	9a 85       	ldd	r25, Y+10	; 0x0a
    3038:	fc 01       	movw	r30, r24
    303a:	80 81       	ld	r24, Z
    303c:	91 81       	ldd	r25, Z+1	; 0x01
    303e:	2b 85       	ldd	r18, Y+11	; 0x0b
    3040:	3c 85       	ldd	r19, Y+12	; 0x0c
    3042:	b9 01       	movw	r22, r18
    3044:	0e 94 67 08 	call	0x10ce	; 0x10ce <LCDEXPLOITING_showPage>
				if (settinsgMenu_values->ledStatus)
    3048:	8f 81       	ldd	r24, Y+7	; 0x07
    304a:	98 85       	ldd	r25, Y+8	; 0x08
    304c:	fc 01       	movw	r30, r24
    304e:	87 81       	ldd	r24, Z+7	; 0x07
    3050:	88 23       	and	r24, r24
    3052:	29 f0       	breq	.+10     	; 0x305e <MainLoop+0x102>
					LedControl_OFF(100);
    3054:	84 e6       	ldi	r24, 0x64	; 100
    3056:	90 e0       	ldi	r25, 0x00	; 0
    3058:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
    305c:	04 c0       	rjmp	.+8      	; 0x3066 <MainLoop+0x10a>
				else
					DELAY_ms(100);
    305e:	84 e6       	ldi	r24, 0x64	; 100
    3060:	90 e0       	ldi	r25, 0x00	; 0
    3062:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				DELAY_ms(settinsgMenu_values->timeDelay * 4);
    3066:	8f 81       	ldd	r24, Y+7	; 0x07
    3068:	98 85       	ldd	r25, Y+8	; 0x08
    306a:	fc 01       	movw	r30, r24
    306c:	81 85       	ldd	r24, Z+9	; 0x09
    306e:	92 85       	ldd	r25, Z+10	; 0x0a
    3070:	88 0f       	add	r24, r24
    3072:	99 1f       	adc	r25, r25
    3074:	88 0f       	add	r24, r24
    3076:	99 1f       	adc	r25, r25
    3078:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
    307c:	63 c0       	rjmp	.+198    	; 0x3144 <MainLoop+0x1e8>
			} else if (BTN_LEFT && ((*page) > 1)) {
    307e:	86 e3       	ldi	r24, 0x36	; 54
    3080:	90 e0       	ldi	r25, 0x00	; 0
    3082:	fc 01       	movw	r30, r24
    3084:	80 81       	ld	r24, Z
    3086:	88 2f       	mov	r24, r24
    3088:	90 e0       	ldi	r25, 0x00	; 0
    308a:	82 70       	andi	r24, 0x02	; 2
    308c:	99 27       	eor	r25, r25
    308e:	00 97       	sbiw	r24, 0x00	; 0
    3090:	09 f0       	breq	.+2      	; 0x3094 <MainLoop+0x138>
    3092:	58 c0       	rjmp	.+176    	; 0x3144 <MainLoop+0x1e8>
    3094:	89 85       	ldd	r24, Y+9	; 0x09
    3096:	9a 85       	ldd	r25, Y+10	; 0x0a
    3098:	fc 01       	movw	r30, r24
    309a:	80 81       	ld	r24, Z
    309c:	91 81       	ldd	r25, Z+1	; 0x01
    309e:	82 30       	cpi	r24, 0x02	; 2
    30a0:	91 05       	cpc	r25, r1
    30a2:	0c f4       	brge	.+2      	; 0x30a6 <MainLoop+0x14a>
    30a4:	4f c0       	rjmp	.+158    	; 0x3144 <MainLoop+0x1e8>
				if (settinsgMenu_values->ledStatus)
    30a6:	8f 81       	ldd	r24, Y+7	; 0x07
    30a8:	98 85       	ldd	r25, Y+8	; 0x08
    30aa:	fc 01       	movw	r30, r24
    30ac:	87 81       	ldd	r24, Z+7	; 0x07
    30ae:	88 23       	and	r24, r24
    30b0:	29 f0       	breq	.+10     	; 0x30bc <MainLoop+0x160>
					LedControl_ON(100);
    30b2:	84 e6       	ldi	r24, 0x64	; 100
    30b4:	90 e0       	ldi	r25, 0x00	; 0
    30b6:	0e 94 3c 0b 	call	0x1678	; 0x1678 <LedControl_ON>
    30ba:	04 c0       	rjmp	.+8      	; 0x30c4 <MainLoop+0x168>
				else
					DELAY_ms(100);
    30bc:	84 e6       	ldi	r24, 0x64	; 100
    30be:	90 e0       	ldi	r25, 0x00	; 0
    30c0:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				(*page)--;
    30c4:	89 85       	ldd	r24, Y+9	; 0x09
    30c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    30c8:	fc 01       	movw	r30, r24
    30ca:	80 81       	ld	r24, Z
    30cc:	91 81       	ldd	r25, Z+1	; 0x01
    30ce:	9c 01       	movw	r18, r24
    30d0:	21 50       	subi	r18, 0x01	; 1
    30d2:	31 09       	sbc	r19, r1
    30d4:	89 85       	ldd	r24, Y+9	; 0x09
    30d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    30d8:	fc 01       	movw	r30, r24
    30da:	31 83       	std	Z+1, r19	; 0x01
    30dc:	20 83       	st	Z, r18
				ShowPage(500, *page, settinsgMenu_values->showChangingPage);
    30de:	8f 81       	ldd	r24, Y+7	; 0x07
    30e0:	98 85       	ldd	r25, Y+8	; 0x08
    30e2:	fc 01       	movw	r30, r24
    30e4:	23 85       	ldd	r18, Z+11	; 0x0b
    30e6:	89 85       	ldd	r24, Y+9	; 0x09
    30e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    30ea:	fc 01       	movw	r30, r24
    30ec:	80 81       	ld	r24, Z
    30ee:	91 81       	ldd	r25, Z+1	; 0x01
    30f0:	42 2f       	mov	r20, r18
    30f2:	bc 01       	movw	r22, r24
    30f4:	84 ef       	ldi	r24, 0xF4	; 244
    30f6:	91 e0       	ldi	r25, 0x01	; 1
    30f8:	0e 94 84 19 	call	0x3308	; 0x3308 <ShowPage>
				LCDEXPLOITING_showPage(*page, lcdPageLabbles);
    30fc:	89 85       	ldd	r24, Y+9	; 0x09
    30fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    3100:	fc 01       	movw	r30, r24
    3102:	80 81       	ld	r24, Z
    3104:	91 81       	ldd	r25, Z+1	; 0x01
    3106:	2b 85       	ldd	r18, Y+11	; 0x0b
    3108:	3c 85       	ldd	r19, Y+12	; 0x0c
    310a:	b9 01       	movw	r22, r18
    310c:	0e 94 67 08 	call	0x10ce	; 0x10ce <LCDEXPLOITING_showPage>
				if (settinsgMenu_values->ledStatus)
    3110:	8f 81       	ldd	r24, Y+7	; 0x07
    3112:	98 85       	ldd	r25, Y+8	; 0x08
    3114:	fc 01       	movw	r30, r24
    3116:	87 81       	ldd	r24, Z+7	; 0x07
    3118:	88 23       	and	r24, r24
    311a:	29 f0       	breq	.+10     	; 0x3126 <MainLoop+0x1ca>
					LedControl_OFF(100);
    311c:	84 e6       	ldi	r24, 0x64	; 100
    311e:	90 e0       	ldi	r25, 0x00	; 0
    3120:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <LedControl_OFF>
    3124:	04 c0       	rjmp	.+8      	; 0x312e <MainLoop+0x1d2>
				else
					DELAY_ms(100);
    3126:	84 e6       	ldi	r24, 0x64	; 100
    3128:	90 e0       	ldi	r25, 0x00	; 0
    312a:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
				DELAY_ms(settinsgMenu_values->timeDelay * 4);
    312e:	8f 81       	ldd	r24, Y+7	; 0x07
    3130:	98 85       	ldd	r25, Y+8	; 0x08
    3132:	fc 01       	movw	r30, r24
    3134:	81 85       	ldd	r24, Z+9	; 0x09
    3136:	92 85       	ldd	r25, Z+10	; 0x0a
    3138:	88 0f       	add	r24, r24
    313a:	99 1f       	adc	r25, r25
    313c:	88 0f       	add	r24, r24
    313e:	99 1f       	adc	r25, r25
    3140:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
			}
		}
		if (BTN_RL) {
    3144:	86 e3       	ldi	r24, 0x36	; 54
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	fc 01       	movw	r30, r24
    314a:	80 81       	ld	r24, Z
    314c:	88 2f       	mov	r24, r24
    314e:	90 e0       	ldi	r25, 0x00	; 0
    3150:	83 70       	andi	r24, 0x03	; 3
    3152:	99 27       	eor	r25, r25
    3154:	00 97       	sbiw	r24, 0x00	; 0
    3156:	a9 f4       	brne	.+42     	; 0x3182 <MainLoop+0x226>
			SettingsMenu_ShowMenu(settinsgMenu_values);
    3158:	8f 81       	ldd	r24, Y+7	; 0x07
    315a:	98 85       	ldd	r25, Y+8	; 0x08
    315c:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <SettingsMenu_ShowMenu>
			*page = 1;
    3160:	89 85       	ldd	r24, Y+9	; 0x09
    3162:	9a 85       	ldd	r25, Y+10	; 0x0a
    3164:	21 e0       	ldi	r18, 0x01	; 1
    3166:	30 e0       	ldi	r19, 0x00	; 0
    3168:	fc 01       	movw	r30, r24
    316a:	31 83       	std	Z+1, r19	; 0x01
    316c:	20 83       	st	Z, r18
			LCDEXPLOITING_showPage(*page, lcdPageLabbles);
    316e:	89 85       	ldd	r24, Y+9	; 0x09
    3170:	9a 85       	ldd	r25, Y+10	; 0x0a
    3172:	fc 01       	movw	r30, r24
    3174:	80 81       	ld	r24, Z
    3176:	91 81       	ldd	r25, Z+1	; 0x01
    3178:	2b 85       	ldd	r18, Y+11	; 0x0b
    317a:	3c 85       	ldd	r19, Y+12	; 0x0c
    317c:	b9 01       	movw	r22, r18
    317e:	0e 94 67 08 	call	0x10ce	; 0x10ce <LCDEXPLOITING_showPage>
		}

		if (BTN_1 || BTN_2 || BTN_3 || BTN_4) {
    3182:	86 e3       	ldi	r24, 0x36	; 54
    3184:	90 e0       	ldi	r25, 0x00	; 0
    3186:	fc 01       	movw	r30, r24
    3188:	80 81       	ld	r24, Z
    318a:	88 2f       	mov	r24, r24
    318c:	90 e0       	ldi	r25, 0x00	; 0
    318e:	84 70       	andi	r24, 0x04	; 4
    3190:	99 27       	eor	r25, r25
    3192:	00 97       	sbiw	r24, 0x00	; 0
    3194:	f9 f0       	breq	.+62     	; 0x31d4 <MainLoop+0x278>
    3196:	86 e3       	ldi	r24, 0x36	; 54
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	fc 01       	movw	r30, r24
    319c:	80 81       	ld	r24, Z
    319e:	88 2f       	mov	r24, r24
    31a0:	90 e0       	ldi	r25, 0x00	; 0
    31a2:	88 70       	andi	r24, 0x08	; 8
    31a4:	99 27       	eor	r25, r25
    31a6:	00 97       	sbiw	r24, 0x00	; 0
    31a8:	a9 f0       	breq	.+42     	; 0x31d4 <MainLoop+0x278>
    31aa:	86 e3       	ldi	r24, 0x36	; 54
    31ac:	90 e0       	ldi	r25, 0x00	; 0
    31ae:	fc 01       	movw	r30, r24
    31b0:	80 81       	ld	r24, Z
    31b2:	88 2f       	mov	r24, r24
    31b4:	90 e0       	ldi	r25, 0x00	; 0
    31b6:	80 71       	andi	r24, 0x10	; 16
    31b8:	99 27       	eor	r25, r25
    31ba:	00 97       	sbiw	r24, 0x00	; 0
    31bc:	59 f0       	breq	.+22     	; 0x31d4 <MainLoop+0x278>
    31be:	86 e3       	ldi	r24, 0x36	; 54
    31c0:	90 e0       	ldi	r25, 0x00	; 0
    31c2:	fc 01       	movw	r30, r24
    31c4:	80 81       	ld	r24, Z
    31c6:	88 2f       	mov	r24, r24
    31c8:	90 e0       	ldi	r25, 0x00	; 0
    31ca:	80 72       	andi	r24, 0x20	; 32
    31cc:	99 27       	eor	r25, r25
    31ce:	00 97       	sbiw	r24, 0x00	; 0
    31d0:	09 f0       	breq	.+2      	; 0x31d4 <MainLoop+0x278>
    31d2:	8d c0       	rjmp	.+282    	; 0x32ee <MainLoop+0x392>
			if (BTN_1) {
    31d4:	86 e3       	ldi	r24, 0x36	; 54
    31d6:	90 e0       	ldi	r25, 0x00	; 0
    31d8:	fc 01       	movw	r30, r24
    31da:	80 81       	ld	r24, Z
    31dc:	88 2f       	mov	r24, r24
    31de:	90 e0       	ldi	r25, 0x00	; 0
    31e0:	84 70       	andi	r24, 0x04	; 4
    31e2:	99 27       	eor	r25, r25
    31e4:	00 97       	sbiw	r24, 0x00	; 0
    31e6:	89 f4       	brne	.+34     	; 0x320a <MainLoop+0x2ae>
				DEVCOMMAND_ExecuteCommand(1, *page,
    31e8:	8f 81       	ldd	r24, Y+7	; 0x07
    31ea:	98 85       	ldd	r25, Y+8	; 0x08
    31ec:	fc 01       	movw	r30, r24
    31ee:	47 81       	ldd	r20, Z+7	; 0x07
    31f0:	89 85       	ldd	r24, Y+9	; 0x09
    31f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    31f4:	fc 01       	movw	r30, r24
    31f6:	80 81       	ld	r24, Z
    31f8:	91 81       	ldd	r25, Z+1	; 0x01
    31fa:	29 81       	ldd	r18, Y+1	; 0x01
    31fc:	3a 81       	ldd	r19, Y+2	; 0x02
    31fe:	bc 01       	movw	r22, r24
    3200:	81 e0       	ldi	r24, 0x01	; 1
    3202:	90 e0       	ldi	r25, 0x00	; 0
    3204:	0e 94 a8 01 	call	0x350	; 0x350 <DEVCOMMAND_ExecuteCommand>
    3208:	50 c0       	rjmp	.+160    	; 0x32aa <MainLoop+0x34e>
						settinsgMenu_values->ledStatus, time);
			} else if (BTN_2) {
    320a:	86 e3       	ldi	r24, 0x36	; 54
    320c:	90 e0       	ldi	r25, 0x00	; 0
    320e:	fc 01       	movw	r30, r24
    3210:	80 81       	ld	r24, Z
    3212:	88 2f       	mov	r24, r24
    3214:	90 e0       	ldi	r25, 0x00	; 0
    3216:	88 70       	andi	r24, 0x08	; 8
    3218:	99 27       	eor	r25, r25
    321a:	00 97       	sbiw	r24, 0x00	; 0
    321c:	89 f4       	brne	.+34     	; 0x3240 <MainLoop+0x2e4>
				DEVCOMMAND_ExecuteCommand(2, *page,
    321e:	8f 81       	ldd	r24, Y+7	; 0x07
    3220:	98 85       	ldd	r25, Y+8	; 0x08
    3222:	fc 01       	movw	r30, r24
    3224:	47 81       	ldd	r20, Z+7	; 0x07
    3226:	89 85       	ldd	r24, Y+9	; 0x09
    3228:	9a 85       	ldd	r25, Y+10	; 0x0a
    322a:	fc 01       	movw	r30, r24
    322c:	80 81       	ld	r24, Z
    322e:	91 81       	ldd	r25, Z+1	; 0x01
    3230:	29 81       	ldd	r18, Y+1	; 0x01
    3232:	3a 81       	ldd	r19, Y+2	; 0x02
    3234:	bc 01       	movw	r22, r24
    3236:	82 e0       	ldi	r24, 0x02	; 2
    3238:	90 e0       	ldi	r25, 0x00	; 0
    323a:	0e 94 a8 01 	call	0x350	; 0x350 <DEVCOMMAND_ExecuteCommand>
    323e:	35 c0       	rjmp	.+106    	; 0x32aa <MainLoop+0x34e>
						settinsgMenu_values->ledStatus, time);
			} else if (BTN_3) {
    3240:	86 e3       	ldi	r24, 0x36	; 54
    3242:	90 e0       	ldi	r25, 0x00	; 0
    3244:	fc 01       	movw	r30, r24
    3246:	80 81       	ld	r24, Z
    3248:	88 2f       	mov	r24, r24
    324a:	90 e0       	ldi	r25, 0x00	; 0
    324c:	80 71       	andi	r24, 0x10	; 16
    324e:	99 27       	eor	r25, r25
    3250:	00 97       	sbiw	r24, 0x00	; 0
    3252:	89 f4       	brne	.+34     	; 0x3276 <MainLoop+0x31a>
				DEVCOMMAND_ExecuteCommand(3, *page,
    3254:	8f 81       	ldd	r24, Y+7	; 0x07
    3256:	98 85       	ldd	r25, Y+8	; 0x08
    3258:	fc 01       	movw	r30, r24
    325a:	47 81       	ldd	r20, Z+7	; 0x07
    325c:	89 85       	ldd	r24, Y+9	; 0x09
    325e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3260:	fc 01       	movw	r30, r24
    3262:	80 81       	ld	r24, Z
    3264:	91 81       	ldd	r25, Z+1	; 0x01
    3266:	29 81       	ldd	r18, Y+1	; 0x01
    3268:	3a 81       	ldd	r19, Y+2	; 0x02
    326a:	bc 01       	movw	r22, r24
    326c:	83 e0       	ldi	r24, 0x03	; 3
    326e:	90 e0       	ldi	r25, 0x00	; 0
    3270:	0e 94 a8 01 	call	0x350	; 0x350 <DEVCOMMAND_ExecuteCommand>
    3274:	1a c0       	rjmp	.+52     	; 0x32aa <MainLoop+0x34e>
						settinsgMenu_values->ledStatus, time);
			} else if (BTN_4) {
    3276:	86 e3       	ldi	r24, 0x36	; 54
    3278:	90 e0       	ldi	r25, 0x00	; 0
    327a:	fc 01       	movw	r30, r24
    327c:	80 81       	ld	r24, Z
    327e:	88 2f       	mov	r24, r24
    3280:	90 e0       	ldi	r25, 0x00	; 0
    3282:	80 72       	andi	r24, 0x20	; 32
    3284:	99 27       	eor	r25, r25
    3286:	00 97       	sbiw	r24, 0x00	; 0
    3288:	81 f4       	brne	.+32     	; 0x32aa <MainLoop+0x34e>
				DEVCOMMAND_ExecuteCommand(4, *page,
    328a:	8f 81       	ldd	r24, Y+7	; 0x07
    328c:	98 85       	ldd	r25, Y+8	; 0x08
    328e:	fc 01       	movw	r30, r24
    3290:	47 81       	ldd	r20, Z+7	; 0x07
    3292:	89 85       	ldd	r24, Y+9	; 0x09
    3294:	9a 85       	ldd	r25, Y+10	; 0x0a
    3296:	fc 01       	movw	r30, r24
    3298:	80 81       	ld	r24, Z
    329a:	91 81       	ldd	r25, Z+1	; 0x01
    329c:	29 81       	ldd	r18, Y+1	; 0x01
    329e:	3a 81       	ldd	r19, Y+2	; 0x02
    32a0:	bc 01       	movw	r22, r24
    32a2:	84 e0       	ldi	r24, 0x04	; 4
    32a4:	90 e0       	ldi	r25, 0x00	; 0
    32a6:	0e 94 a8 01 	call	0x350	; 0x350 <DEVCOMMAND_ExecuteCommand>
						settinsgMenu_values->ledStatus, time);
			}
			clkPressedButton++;
    32aa:	8b 81       	ldd	r24, Y+3	; 0x03
    32ac:	9c 81       	ldd	r25, Y+4	; 0x04
    32ae:	01 96       	adiw	r24, 0x01	; 1
    32b0:	9c 83       	std	Y+4, r25	; 0x04
    32b2:	8b 83       	std	Y+3, r24	; 0x03
			if (clkPressedButton == 3)
    32b4:	8b 81       	ldd	r24, Y+3	; 0x03
    32b6:	9c 81       	ldd	r25, Y+4	; 0x04
    32b8:	83 30       	cpi	r24, 0x03	; 3
    32ba:	91 05       	cpc	r25, r1
    32bc:	29 f4       	brne	.+10     	; 0x32c8 <MainLoop+0x36c>
				time = 150;
    32be:	86 e9       	ldi	r24, 0x96	; 150
    32c0:	90 e0       	ldi	r25, 0x00	; 0
    32c2:	9a 83       	std	Y+2, r25	; 0x02
    32c4:	89 83       	std	Y+1, r24	; 0x01
    32c6:	12 c0       	rjmp	.+36     	; 0x32ec <MainLoop+0x390>
			else if (clkPressedButton == 5)
    32c8:	8b 81       	ldd	r24, Y+3	; 0x03
    32ca:	9c 81       	ldd	r25, Y+4	; 0x04
    32cc:	85 30       	cpi	r24, 0x05	; 5
    32ce:	91 05       	cpc	r25, r1
    32d0:	29 f4       	brne	.+10     	; 0x32dc <MainLoop+0x380>
				time = 100;
    32d2:	84 e6       	ldi	r24, 0x64	; 100
    32d4:	90 e0       	ldi	r25, 0x00	; 0
    32d6:	9a 83       	std	Y+2, r25	; 0x02
    32d8:	89 83       	std	Y+1, r24	; 0x01
    32da:	08 c0       	rjmp	.+16     	; 0x32ec <MainLoop+0x390>
			else if (clkPressedButton == 8)
    32dc:	8b 81       	ldd	r24, Y+3	; 0x03
    32de:	9c 81       	ldd	r25, Y+4	; 0x04
    32e0:	88 30       	cpi	r24, 0x08	; 8
    32e2:	91 05       	cpc	r25, r1
    32e4:	19 f4       	brne	.+6      	; 0x32ec <MainLoop+0x390>
				time = 0;
    32e6:	1a 82       	std	Y+2, r1	; 0x02
    32e8:	19 82       	std	Y+1, r1	; 0x01
			} else if (BTN_4) {
				DEVCOMMAND_ExecuteCommand(4, *page,
						settinsgMenu_values->ledStatus, time);
			}
			clkPressedButton++;
			if (clkPressedButton == 3)
    32ea:	07 c0       	rjmp	.+14     	; 0x32fa <MainLoop+0x39e>
    32ec:	06 c0       	rjmp	.+12     	; 0x32fa <MainLoop+0x39e>
			else if (clkPressedButton == 5)
				time = 100;
			else if (clkPressedButton == 8)
				time = 0;
		} else {
			clkPressedButton = 0;
    32ee:	1c 82       	std	Y+4, r1	; 0x04
    32f0:	1b 82       	std	Y+3, r1	; 0x03
			time = 200;
    32f2:	88 ec       	ldi	r24, 0xC8	; 200
    32f4:	90 e0       	ldi	r25, 0x00	; 0
    32f6:	9a 83       	std	Y+2, r25	; 0x02
    32f8:	89 83       	std	Y+1, r24	; 0x01
		}
		LCD_RefreshScreen(&refreshClock, 500);
    32fa:	ce 01       	movw	r24, r28
    32fc:	05 96       	adiw	r24, 0x05	; 5
    32fe:	64 ef       	ldi	r22, 0xF4	; 244
    3300:	71 e0       	ldi	r23, 0x01	; 1
    3302:	0e 94 91 2c 	call	0x5922	; 0x5922 <LCD_RefreshScreen>
	}
    3306:	42 ce       	rjmp	.-892    	; 0x2f8c <MainLoop+0x30>

00003308 <ShowPage>:
}

void ShowPage(int time, int page, bool willShow) {
    3308:	cf 93       	push	r28
    330a:	df 93       	push	r29
    330c:	00 d0       	rcall	.+0      	; 0x330e <ShowPage+0x6>
    330e:	00 d0       	rcall	.+0      	; 0x3310 <ShowPage+0x8>
    3310:	1f 92       	push	r1
    3312:	cd b7       	in	r28, 0x3d	; 61
    3314:	de b7       	in	r29, 0x3e	; 62
    3316:	9a 83       	std	Y+2, r25	; 0x02
    3318:	89 83       	std	Y+1, r24	; 0x01
    331a:	7c 83       	std	Y+4, r23	; 0x04
    331c:	6b 83       	std	Y+3, r22	; 0x03
    331e:	4d 83       	std	Y+5, r20	; 0x05
	if (willShow) {
    3320:	8d 81       	ldd	r24, Y+5	; 0x05
    3322:	88 23       	and	r24, r24
    3324:	01 f1       	breq	.+64     	; 0x3366 <ShowPage+0x5e>
		LCD_Clear();
    3326:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
		LCD_XYPrintf(7, 0, "%d", page);
    332a:	8c 81       	ldd	r24, Y+4	; 0x04
    332c:	8f 93       	push	r24
    332e:	8b 81       	ldd	r24, Y+3	; 0x03
    3330:	8f 93       	push	r24
    3332:	88 e3       	ldi	r24, 0x38	; 56
    3334:	92 e0       	ldi	r25, 0x02	; 2
    3336:	89 2f       	mov	r24, r25
    3338:	8f 93       	push	r24
    333a:	88 e3       	ldi	r24, 0x38	; 56
    333c:	92 e0       	ldi	r25, 0x02	; 2
    333e:	8f 93       	push	r24
    3340:	1f 92       	push	r1
    3342:	1f 92       	push	r1
    3344:	1f 92       	push	r1
    3346:	87 e0       	ldi	r24, 0x07	; 7
    3348:	8f 93       	push	r24
    334a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    334e:	8d b7       	in	r24, 0x3d	; 61
    3350:	9e b7       	in	r25, 0x3e	; 62
    3352:	08 96       	adiw	r24, 0x08	; 8
    3354:	0f b6       	in	r0, 0x3f	; 63
    3356:	f8 94       	cli
    3358:	de bf       	out	0x3e, r29	; 62
    335a:	0f be       	out	0x3f, r0	; 63
    335c:	cd bf       	out	0x3d, r28	; 61
		DELAY_ms(time);
    335e:	89 81       	ldd	r24, Y+1	; 0x01
    3360:	9a 81       	ldd	r25, Y+2	; 0x02
    3362:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	}
}
    3366:	0f 90       	pop	r0
    3368:	0f 90       	pop	r0
    336a:	0f 90       	pop	r0
    336c:	0f 90       	pop	r0
    336e:	0f 90       	pop	r0
    3370:	df 91       	pop	r29
    3372:	cf 91       	pop	r28
    3374:	08 95       	ret

00003376 <DELAY_us>:
         It generates a delay of approximate 1us for each count,
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    3376:	cf 93       	push	r28
    3378:	df 93       	push	r29
    337a:	cd b7       	in	r28, 0x3d	; 61
    337c:	de b7       	in	r29, 0x3e	; 62
    337e:	a3 97       	sbiw	r28, 0x23	; 35
    3380:	0f b6       	in	r0, 0x3f	; 63
    3382:	f8 94       	cli
    3384:	de bf       	out	0x3e, r29	; 62
    3386:	0f be       	out	0x3f, r0	; 63
    3388:	cd bf       	out	0x3d, r28	; 61
    338a:	9b a3       	std	Y+35, r25	; 0x23
    338c:	8a a3       	std	Y+34, r24	; 0x22
    while (us_count != 0) 
    338e:	f8 c0       	rjmp	.+496    	; 0x3580 <DELAY_us+0x20a>
    3390:	80 e0       	ldi	r24, 0x00	; 0
    3392:	90 e0       	ldi	r25, 0x00	; 0
    3394:	a0 e8       	ldi	r26, 0x80	; 128
    3396:	bf e3       	ldi	r27, 0x3F	; 63
    3398:	89 83       	std	Y+1, r24	; 0x01
    339a:	9a 83       	std	Y+2, r25	; 0x02
    339c:	ab 83       	std	Y+3, r26	; 0x03
    339e:	bc 83       	std	Y+4, r27	; 0x04
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ; 
	__tmp = ((F_CPU) / 3e6) * __us;
    33a0:	2b ea       	ldi	r18, 0xAB	; 171
    33a2:	3a ea       	ldi	r19, 0xAA	; 170
    33a4:	4a ea       	ldi	r20, 0xAA	; 170
    33a6:	5e e3       	ldi	r21, 0x3E	; 62
    33a8:	69 81       	ldd	r22, Y+1	; 0x01
    33aa:	7a 81       	ldd	r23, Y+2	; 0x02
    33ac:	8b 81       	ldd	r24, Y+3	; 0x03
    33ae:	9c 81       	ldd	r25, Y+4	; 0x04
    33b0:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    33b4:	dc 01       	movw	r26, r24
    33b6:	cb 01       	movw	r24, r22
    33b8:	8d 83       	std	Y+5, r24	; 0x05
    33ba:	9e 83       	std	Y+6, r25	; 0x06
    33bc:	af 83       	std	Y+7, r26	; 0x07
    33be:	b8 87       	std	Y+8, r27	; 0x08
	__tmp2 = ((F_CPU) / 4e6) * __us;
    33c0:	20 e0       	ldi	r18, 0x00	; 0
    33c2:	30 e0       	ldi	r19, 0x00	; 0
    33c4:	40 e8       	ldi	r20, 0x80	; 128
    33c6:	5e e3       	ldi	r21, 0x3E	; 62
    33c8:	69 81       	ldd	r22, Y+1	; 0x01
    33ca:	7a 81       	ldd	r23, Y+2	; 0x02
    33cc:	8b 81       	ldd	r24, Y+3	; 0x03
    33ce:	9c 81       	ldd	r25, Y+4	; 0x04
    33d0:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    33d4:	dc 01       	movw	r26, r24
    33d6:	cb 01       	movw	r24, r22
    33d8:	89 87       	std	Y+9, r24	; 0x09
    33da:	9a 87       	std	Y+10, r25	; 0x0a
    33dc:	ab 87       	std	Y+11, r26	; 0x0b
    33de:	bc 87       	std	Y+12, r27	; 0x0c
	if (__tmp < 1.0)
    33e0:	20 e0       	ldi	r18, 0x00	; 0
    33e2:	30 e0       	ldi	r19, 0x00	; 0
    33e4:	40 e8       	ldi	r20, 0x80	; 128
    33e6:	5f e3       	ldi	r21, 0x3F	; 63
    33e8:	6d 81       	ldd	r22, Y+5	; 0x05
    33ea:	7e 81       	ldd	r23, Y+6	; 0x06
    33ec:	8f 81       	ldd	r24, Y+7	; 0x07
    33ee:	98 85       	ldd	r25, Y+8	; 0x08
    33f0:	0e 94 b5 32 	call	0x656a	; 0x656a <__cmpsf2>
    33f4:	88 23       	and	r24, r24
    33f6:	1c f4       	brge	.+6      	; 0x33fe <DELAY_us+0x88>
		__ticks = 1;
    33f8:	81 e0       	ldi	r24, 0x01	; 1
    33fa:	8d 87       	std	Y+13, r24	; 0x0d
    33fc:	b6 c0       	rjmp	.+364    	; 0x356a <DELAY_us+0x1f4>
	else if (__tmp2 > 65535)
    33fe:	20 e0       	ldi	r18, 0x00	; 0
    3400:	3f ef       	ldi	r19, 0xFF	; 255
    3402:	4f e7       	ldi	r20, 0x7F	; 127
    3404:	57 e4       	ldi	r21, 0x47	; 71
    3406:	69 85       	ldd	r22, Y+9	; 0x09
    3408:	7a 85       	ldd	r23, Y+10	; 0x0a
    340a:	8b 85       	ldd	r24, Y+11	; 0x0b
    340c:	9c 85       	ldd	r25, Y+12	; 0x0c
    340e:	0e 94 ff 33 	call	0x67fe	; 0x67fe <__gesf2>
    3412:	18 16       	cp	r1, r24
    3414:	0c f0       	brlt	.+2      	; 0x3418 <DELAY_us+0xa2>
    3416:	7f c0       	rjmp	.+254    	; 0x3516 <DELAY_us+0x1a0>
	{
		_delay_ms(__us / 1000.0);
    3418:	20 e0       	ldi	r18, 0x00	; 0
    341a:	30 e0       	ldi	r19, 0x00	; 0
    341c:	4a e7       	ldi	r20, 0x7A	; 122
    341e:	54 e4       	ldi	r21, 0x44	; 68
    3420:	69 81       	ldd	r22, Y+1	; 0x01
    3422:	7a 81       	ldd	r23, Y+2	; 0x02
    3424:	8b 81       	ldd	r24, Y+3	; 0x03
    3426:	9c 81       	ldd	r25, Y+4	; 0x04
    3428:	0e 94 b9 32 	call	0x6572	; 0x6572 <__divsf3>
    342c:	dc 01       	movw	r26, r24
    342e:	cb 01       	movw	r24, r22
    3430:	8e 87       	std	Y+14, r24	; 0x0e
    3432:	9f 87       	std	Y+15, r25	; 0x0f
    3434:	a8 8b       	std	Y+16, r26	; 0x10
    3436:	b9 8b       	std	Y+17, r27	; 0x11

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    3438:	20 e0       	ldi	r18, 0x00	; 0
    343a:	30 e0       	ldi	r19, 0x00	; 0
    343c:	4a e7       	ldi	r20, 0x7A	; 122
    343e:	53 e4       	ldi	r21, 0x43	; 67
    3440:	6e 85       	ldd	r22, Y+14	; 0x0e
    3442:	7f 85       	ldd	r23, Y+15	; 0x0f
    3444:	88 89       	ldd	r24, Y+16	; 0x10
    3446:	99 89       	ldd	r25, Y+17	; 0x11
    3448:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    344c:	dc 01       	movw	r26, r24
    344e:	cb 01       	movw	r24, r22
    3450:	8a 8b       	std	Y+18, r24	; 0x12
    3452:	9b 8b       	std	Y+19, r25	; 0x13
    3454:	ac 8b       	std	Y+20, r26	; 0x14
    3456:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    3458:	20 e0       	ldi	r18, 0x00	; 0
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	40 e8       	ldi	r20, 0x80	; 128
    345e:	5f e3       	ldi	r21, 0x3F	; 63
    3460:	6a 89       	ldd	r22, Y+18	; 0x12
    3462:	7b 89       	ldd	r23, Y+19	; 0x13
    3464:	8c 89       	ldd	r24, Y+20	; 0x14
    3466:	9d 89       	ldd	r25, Y+21	; 0x15
    3468:	0e 94 b5 32 	call	0x656a	; 0x656a <__cmpsf2>
    346c:	88 23       	and	r24, r24
    346e:	2c f4       	brge	.+10     	; 0x347a <DELAY_us+0x104>
		__ticks = 1;
    3470:	81 e0       	ldi	r24, 0x01	; 1
    3472:	90 e0       	ldi	r25, 0x00	; 0
    3474:	9f 8b       	std	Y+23, r25	; 0x17
    3476:	8e 8b       	std	Y+22, r24	; 0x16
    3478:	41 c0       	rjmp	.+130    	; 0x34fc <DELAY_us+0x186>
	else if (__tmp > 65535)
    347a:	20 e0       	ldi	r18, 0x00	; 0
    347c:	3f ef       	ldi	r19, 0xFF	; 255
    347e:	4f e7       	ldi	r20, 0x7F	; 127
    3480:	57 e4       	ldi	r21, 0x47	; 71
    3482:	6a 89       	ldd	r22, Y+18	; 0x12
    3484:	7b 89       	ldd	r23, Y+19	; 0x13
    3486:	8c 89       	ldd	r24, Y+20	; 0x14
    3488:	9d 89       	ldd	r25, Y+21	; 0x15
    348a:	0e 94 ff 33 	call	0x67fe	; 0x67fe <__gesf2>
    348e:	18 16       	cp	r1, r24
    3490:	5c f5       	brge	.+86     	; 0x34e8 <DELAY_us+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3492:	20 e0       	ldi	r18, 0x00	; 0
    3494:	30 e0       	ldi	r19, 0x00	; 0
    3496:	40 e2       	ldi	r20, 0x20	; 32
    3498:	51 e4       	ldi	r21, 0x41	; 65
    349a:	6e 85       	ldd	r22, Y+14	; 0x0e
    349c:	7f 85       	ldd	r23, Y+15	; 0x0f
    349e:	88 89       	ldd	r24, Y+16	; 0x10
    34a0:	99 89       	ldd	r25, Y+17	; 0x11
    34a2:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    34a6:	dc 01       	movw	r26, r24
    34a8:	cb 01       	movw	r24, r22
    34aa:	bc 01       	movw	r22, r24
    34ac:	cd 01       	movw	r24, r26
    34ae:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    34b2:	dc 01       	movw	r26, r24
    34b4:	cb 01       	movw	r24, r22
    34b6:	9f 8b       	std	Y+23, r25	; 0x17
    34b8:	8e 8b       	std	Y+22, r24	; 0x16
    34ba:	0f c0       	rjmp	.+30     	; 0x34da <DELAY_us+0x164>
    34bc:	89 e1       	ldi	r24, 0x19	; 25
    34be:	90 e0       	ldi	r25, 0x00	; 0
    34c0:	99 8f       	std	Y+25, r25	; 0x19
    34c2:	88 8f       	std	Y+24, r24	; 0x18
    34c4:	88 8d       	ldd	r24, Y+24	; 0x18
    34c6:	99 8d       	ldd	r25, Y+25	; 0x19
    34c8:	01 97       	sbiw	r24, 0x01	; 1
    34ca:	f1 f7       	brne	.-4      	; 0x34c8 <DELAY_us+0x152>
    34cc:	99 8f       	std	Y+25, r25	; 0x19
    34ce:	88 8f       	std	Y+24, r24	; 0x18
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34d0:	8e 89       	ldd	r24, Y+22	; 0x16
    34d2:	9f 89       	ldd	r25, Y+23	; 0x17
    34d4:	01 97       	sbiw	r24, 0x01	; 1
    34d6:	9f 8b       	std	Y+23, r25	; 0x17
    34d8:	8e 8b       	std	Y+22, r24	; 0x16
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34da:	8e 89       	ldd	r24, Y+22	; 0x16
    34dc:	9f 89       	ldd	r25, Y+23	; 0x17
    34de:	00 97       	sbiw	r24, 0x00	; 0
    34e0:	69 f7       	brne	.-38     	; 0x34bc <DELAY_us+0x146>
    34e2:	89 a1       	ldd	r24, Y+33	; 0x21
    34e4:	8d 87       	std	Y+13, r24	; 0x0d
    34e6:	41 c0       	rjmp	.+130    	; 0x356a <DELAY_us+0x1f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    34e8:	6a 89       	ldd	r22, Y+18	; 0x12
    34ea:	7b 89       	ldd	r23, Y+19	; 0x13
    34ec:	8c 89       	ldd	r24, Y+20	; 0x14
    34ee:	9d 89       	ldd	r25, Y+21	; 0x15
    34f0:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    34f4:	dc 01       	movw	r26, r24
    34f6:	cb 01       	movw	r24, r22
    34f8:	9f 8b       	std	Y+23, r25	; 0x17
    34fa:	8e 8b       	std	Y+22, r24	; 0x16
    34fc:	8e 89       	ldd	r24, Y+22	; 0x16
    34fe:	9f 89       	ldd	r25, Y+23	; 0x17
    3500:	9b 8f       	std	Y+27, r25	; 0x1b
    3502:	8a 8f       	std	Y+26, r24	; 0x1a
    3504:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3506:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3508:	01 97       	sbiw	r24, 0x01	; 1
    350a:	f1 f7       	brne	.-4      	; 0x3508 <DELAY_us+0x192>
    350c:	9b 8f       	std	Y+27, r25	; 0x1b
    350e:	8a 8f       	std	Y+26, r24	; 0x1a
    3510:	89 a1       	ldd	r24, Y+33	; 0x21
    3512:	8d 87       	std	Y+13, r24	; 0x0d
    3514:	2a c0       	rjmp	.+84     	; 0x356a <DELAY_us+0x1f4>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    3516:	20 e0       	ldi	r18, 0x00	; 0
    3518:	30 e0       	ldi	r19, 0x00	; 0
    351a:	4f e7       	ldi	r20, 0x7F	; 127
    351c:	53 e4       	ldi	r21, 0x43	; 67
    351e:	6d 81       	ldd	r22, Y+5	; 0x05
    3520:	7e 81       	ldd	r23, Y+6	; 0x06
    3522:	8f 81       	ldd	r24, Y+7	; 0x07
    3524:	98 85       	ldd	r25, Y+8	; 0x08
    3526:	0e 94 ff 33 	call	0x67fe	; 0x67fe <__gesf2>
    352a:	18 16       	cp	r1, r24
    352c:	ac f4       	brge	.+42     	; 0x3558 <DELAY_us+0x1e2>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    352e:	69 85       	ldd	r22, Y+9	; 0x09
    3530:	7a 85       	ldd	r23, Y+10	; 0x0a
    3532:	8b 85       	ldd	r24, Y+11	; 0x0b
    3534:	9c 85       	ldd	r25, Y+12	; 0x0c
    3536:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    353a:	dc 01       	movw	r26, r24
    353c:	cb 01       	movw	r24, r22
    353e:	9d 8f       	std	Y+29, r25	; 0x1d
    3540:	8c 8f       	std	Y+28, r24	; 0x1c
    3542:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3544:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3546:	9f 8f       	std	Y+31, r25	; 0x1f
    3548:	8e 8f       	std	Y+30, r24	; 0x1e
    354a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    354c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    354e:	01 97       	sbiw	r24, 0x01	; 1
    3550:	f1 f7       	brne	.-4      	; 0x354e <DELAY_us+0x1d8>
    3552:	9f 8f       	std	Y+31, r25	; 0x1f
    3554:	8e 8f       	std	Y+30, r24	; 0x1e
    3556:	0f c0       	rjmp	.+30     	; 0x3576 <DELAY_us+0x200>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3558:	6d 81       	ldd	r22, Y+5	; 0x05
    355a:	7e 81       	ldd	r23, Y+6	; 0x06
    355c:	8f 81       	ldd	r24, Y+7	; 0x07
    355e:	98 85       	ldd	r25, Y+8	; 0x08
    3560:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    3564:	dc 01       	movw	r26, r24
    3566:	cb 01       	movw	r24, r22
    3568:	8d 87       	std	Y+13, r24	; 0x0d
    356a:	8d 85       	ldd	r24, Y+13	; 0x0d
    356c:	88 a3       	std	Y+32, r24	; 0x20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    356e:	88 a1       	ldd	r24, Y+32	; 0x20
    3570:	8a 95       	dec	r24
    3572:	f1 f7       	brne	.-4      	; 0x3570 <DELAY_us+0x1fa>
    3574:	88 a3       	std	Y+32, r24	; 0x20
    {
        _delay_us(1);
		us_count--;
    3576:	8a a1       	ldd	r24, Y+34	; 0x22
    3578:	9b a1       	ldd	r25, Y+35	; 0x23
    357a:	01 97       	sbiw	r24, 0x01	; 1
    357c:	9b a3       	std	Y+35, r25	; 0x23
    357e:	8a a3       	std	Y+34, r24	; 0x22
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
    3580:	8a a1       	ldd	r24, Y+34	; 0x22
    3582:	9b a1       	ldd	r25, Y+35	; 0x23
    3584:	00 97       	sbiw	r24, 0x00	; 0
    3586:	09 f0       	breq	.+2      	; 0x358a <DELAY_us+0x214>
    3588:	03 cf       	rjmp	.-506    	; 0x3390 <DELAY_us+0x1a>
    {
        _delay_us(1);
		us_count--;
    }
}
    358a:	a3 96       	adiw	r28, 0x23	; 35
    358c:	0f b6       	in	r0, 0x3f	; 63
    358e:	f8 94       	cli
    3590:	de bf       	out	0x3e, r29	; 62
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	cd bf       	out	0x3d, r28	; 61
    3596:	df 91       	pop	r29
    3598:	cf 91       	pop	r28
    359a:	08 95       	ret

0000359c <DELAY_ms>:
     This function is used generate delay in ms.
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    359c:	cf 93       	push	r28
    359e:	df 93       	push	r29
    35a0:	cd b7       	in	r28, 0x3d	; 61
    35a2:	de b7       	in	r29, 0x3e	; 62
    35a4:	a3 97       	sbiw	r28, 0x23	; 35
    35a6:	0f b6       	in	r0, 0x3f	; 63
    35a8:	f8 94       	cli
    35aa:	de bf       	out	0x3e, r29	; 62
    35ac:	0f be       	out	0x3f, r0	; 63
    35ae:	cd bf       	out	0x3d, r28	; 61
    35b0:	9b a3       	std	Y+35, r25	; 0x23
    35b2:	8a a3       	std	Y+34, r24	; 0x22
    while (ms_count != 0) 
    35b4:	f8 c0       	rjmp	.+496    	; 0x37a6 <DELAY_ms+0x20a>
    35b6:	80 e0       	ldi	r24, 0x00	; 0
    35b8:	90 e0       	ldi	r25, 0x00	; 0
    35ba:	aa e7       	ldi	r26, 0x7A	; 122
    35bc:	b4 e4       	ldi	r27, 0x44	; 68
    35be:	89 83       	std	Y+1, r24	; 0x01
    35c0:	9a 83       	std	Y+2, r25	; 0x02
    35c2:	ab 83       	std	Y+3, r26	; 0x03
    35c4:	bc 83       	std	Y+4, r27	; 0x04
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ; 
	__tmp = ((F_CPU) / 3e6) * __us;
    35c6:	2b ea       	ldi	r18, 0xAB	; 171
    35c8:	3a ea       	ldi	r19, 0xAA	; 170
    35ca:	4a ea       	ldi	r20, 0xAA	; 170
    35cc:	5e e3       	ldi	r21, 0x3E	; 62
    35ce:	69 81       	ldd	r22, Y+1	; 0x01
    35d0:	7a 81       	ldd	r23, Y+2	; 0x02
    35d2:	8b 81       	ldd	r24, Y+3	; 0x03
    35d4:	9c 81       	ldd	r25, Y+4	; 0x04
    35d6:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    35da:	dc 01       	movw	r26, r24
    35dc:	cb 01       	movw	r24, r22
    35de:	8d 83       	std	Y+5, r24	; 0x05
    35e0:	9e 83       	std	Y+6, r25	; 0x06
    35e2:	af 83       	std	Y+7, r26	; 0x07
    35e4:	b8 87       	std	Y+8, r27	; 0x08
	__tmp2 = ((F_CPU) / 4e6) * __us;
    35e6:	20 e0       	ldi	r18, 0x00	; 0
    35e8:	30 e0       	ldi	r19, 0x00	; 0
    35ea:	40 e8       	ldi	r20, 0x80	; 128
    35ec:	5e e3       	ldi	r21, 0x3E	; 62
    35ee:	69 81       	ldd	r22, Y+1	; 0x01
    35f0:	7a 81       	ldd	r23, Y+2	; 0x02
    35f2:	8b 81       	ldd	r24, Y+3	; 0x03
    35f4:	9c 81       	ldd	r25, Y+4	; 0x04
    35f6:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    35fa:	dc 01       	movw	r26, r24
    35fc:	cb 01       	movw	r24, r22
    35fe:	89 87       	std	Y+9, r24	; 0x09
    3600:	9a 87       	std	Y+10, r25	; 0x0a
    3602:	ab 87       	std	Y+11, r26	; 0x0b
    3604:	bc 87       	std	Y+12, r27	; 0x0c
	if (__tmp < 1.0)
    3606:	20 e0       	ldi	r18, 0x00	; 0
    3608:	30 e0       	ldi	r19, 0x00	; 0
    360a:	40 e8       	ldi	r20, 0x80	; 128
    360c:	5f e3       	ldi	r21, 0x3F	; 63
    360e:	6d 81       	ldd	r22, Y+5	; 0x05
    3610:	7e 81       	ldd	r23, Y+6	; 0x06
    3612:	8f 81       	ldd	r24, Y+7	; 0x07
    3614:	98 85       	ldd	r25, Y+8	; 0x08
    3616:	0e 94 b5 32 	call	0x656a	; 0x656a <__cmpsf2>
    361a:	88 23       	and	r24, r24
    361c:	1c f4       	brge	.+6      	; 0x3624 <DELAY_ms+0x88>
		__ticks = 1;
    361e:	81 e0       	ldi	r24, 0x01	; 1
    3620:	8d 87       	std	Y+13, r24	; 0x0d
    3622:	b6 c0       	rjmp	.+364    	; 0x3790 <DELAY_ms+0x1f4>
	else if (__tmp2 > 65535)
    3624:	20 e0       	ldi	r18, 0x00	; 0
    3626:	3f ef       	ldi	r19, 0xFF	; 255
    3628:	4f e7       	ldi	r20, 0x7F	; 127
    362a:	57 e4       	ldi	r21, 0x47	; 71
    362c:	69 85       	ldd	r22, Y+9	; 0x09
    362e:	7a 85       	ldd	r23, Y+10	; 0x0a
    3630:	8b 85       	ldd	r24, Y+11	; 0x0b
    3632:	9c 85       	ldd	r25, Y+12	; 0x0c
    3634:	0e 94 ff 33 	call	0x67fe	; 0x67fe <__gesf2>
    3638:	18 16       	cp	r1, r24
    363a:	0c f0       	brlt	.+2      	; 0x363e <DELAY_ms+0xa2>
    363c:	7f c0       	rjmp	.+254    	; 0x373c <DELAY_ms+0x1a0>
	{
		_delay_ms(__us / 1000.0);
    363e:	20 e0       	ldi	r18, 0x00	; 0
    3640:	30 e0       	ldi	r19, 0x00	; 0
    3642:	4a e7       	ldi	r20, 0x7A	; 122
    3644:	54 e4       	ldi	r21, 0x44	; 68
    3646:	69 81       	ldd	r22, Y+1	; 0x01
    3648:	7a 81       	ldd	r23, Y+2	; 0x02
    364a:	8b 81       	ldd	r24, Y+3	; 0x03
    364c:	9c 81       	ldd	r25, Y+4	; 0x04
    364e:	0e 94 b9 32 	call	0x6572	; 0x6572 <__divsf3>
    3652:	dc 01       	movw	r26, r24
    3654:	cb 01       	movw	r24, r22
    3656:	8e 87       	std	Y+14, r24	; 0x0e
    3658:	9f 87       	std	Y+15, r25	; 0x0f
    365a:	a8 8b       	std	Y+16, r26	; 0x10
    365c:	b9 8b       	std	Y+17, r27	; 0x11

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    365e:	20 e0       	ldi	r18, 0x00	; 0
    3660:	30 e0       	ldi	r19, 0x00	; 0
    3662:	4a e7       	ldi	r20, 0x7A	; 122
    3664:	53 e4       	ldi	r21, 0x43	; 67
    3666:	6e 85       	ldd	r22, Y+14	; 0x0e
    3668:	7f 85       	ldd	r23, Y+15	; 0x0f
    366a:	88 89       	ldd	r24, Y+16	; 0x10
    366c:	99 89       	ldd	r25, Y+17	; 0x11
    366e:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    3672:	dc 01       	movw	r26, r24
    3674:	cb 01       	movw	r24, r22
    3676:	8a 8b       	std	Y+18, r24	; 0x12
    3678:	9b 8b       	std	Y+19, r25	; 0x13
    367a:	ac 8b       	std	Y+20, r26	; 0x14
    367c:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    367e:	20 e0       	ldi	r18, 0x00	; 0
    3680:	30 e0       	ldi	r19, 0x00	; 0
    3682:	40 e8       	ldi	r20, 0x80	; 128
    3684:	5f e3       	ldi	r21, 0x3F	; 63
    3686:	6a 89       	ldd	r22, Y+18	; 0x12
    3688:	7b 89       	ldd	r23, Y+19	; 0x13
    368a:	8c 89       	ldd	r24, Y+20	; 0x14
    368c:	9d 89       	ldd	r25, Y+21	; 0x15
    368e:	0e 94 b5 32 	call	0x656a	; 0x656a <__cmpsf2>
    3692:	88 23       	and	r24, r24
    3694:	2c f4       	brge	.+10     	; 0x36a0 <DELAY_ms+0x104>
		__ticks = 1;
    3696:	81 e0       	ldi	r24, 0x01	; 1
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	9f 8b       	std	Y+23, r25	; 0x17
    369c:	8e 8b       	std	Y+22, r24	; 0x16
    369e:	41 c0       	rjmp	.+130    	; 0x3722 <DELAY_ms+0x186>
	else if (__tmp > 65535)
    36a0:	20 e0       	ldi	r18, 0x00	; 0
    36a2:	3f ef       	ldi	r19, 0xFF	; 255
    36a4:	4f e7       	ldi	r20, 0x7F	; 127
    36a6:	57 e4       	ldi	r21, 0x47	; 71
    36a8:	6a 89       	ldd	r22, Y+18	; 0x12
    36aa:	7b 89       	ldd	r23, Y+19	; 0x13
    36ac:	8c 89       	ldd	r24, Y+20	; 0x14
    36ae:	9d 89       	ldd	r25, Y+21	; 0x15
    36b0:	0e 94 ff 33 	call	0x67fe	; 0x67fe <__gesf2>
    36b4:	18 16       	cp	r1, r24
    36b6:	5c f5       	brge	.+86     	; 0x370e <DELAY_ms+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    36b8:	20 e0       	ldi	r18, 0x00	; 0
    36ba:	30 e0       	ldi	r19, 0x00	; 0
    36bc:	40 e2       	ldi	r20, 0x20	; 32
    36be:	51 e4       	ldi	r21, 0x41	; 65
    36c0:	6e 85       	ldd	r22, Y+14	; 0x0e
    36c2:	7f 85       	ldd	r23, Y+15	; 0x0f
    36c4:	88 89       	ldd	r24, Y+16	; 0x10
    36c6:	99 89       	ldd	r25, Y+17	; 0x11
    36c8:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    36cc:	dc 01       	movw	r26, r24
    36ce:	cb 01       	movw	r24, r22
    36d0:	bc 01       	movw	r22, r24
    36d2:	cd 01       	movw	r24, r26
    36d4:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    36d8:	dc 01       	movw	r26, r24
    36da:	cb 01       	movw	r24, r22
    36dc:	9f 8b       	std	Y+23, r25	; 0x17
    36de:	8e 8b       	std	Y+22, r24	; 0x16
    36e0:	0f c0       	rjmp	.+30     	; 0x3700 <DELAY_ms+0x164>
    36e2:	89 e1       	ldi	r24, 0x19	; 25
    36e4:	90 e0       	ldi	r25, 0x00	; 0
    36e6:	99 8f       	std	Y+25, r25	; 0x19
    36e8:	88 8f       	std	Y+24, r24	; 0x18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    36ea:	88 8d       	ldd	r24, Y+24	; 0x18
    36ec:	99 8d       	ldd	r25, Y+25	; 0x19
    36ee:	01 97       	sbiw	r24, 0x01	; 1
    36f0:	f1 f7       	brne	.-4      	; 0x36ee <DELAY_ms+0x152>
    36f2:	99 8f       	std	Y+25, r25	; 0x19
    36f4:	88 8f       	std	Y+24, r24	; 0x18
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36f6:	8e 89       	ldd	r24, Y+22	; 0x16
    36f8:	9f 89       	ldd	r25, Y+23	; 0x17
    36fa:	01 97       	sbiw	r24, 0x01	; 1
    36fc:	9f 8b       	std	Y+23, r25	; 0x17
    36fe:	8e 8b       	std	Y+22, r24	; 0x16
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3700:	8e 89       	ldd	r24, Y+22	; 0x16
    3702:	9f 89       	ldd	r25, Y+23	; 0x17
    3704:	00 97       	sbiw	r24, 0x00	; 0
    3706:	69 f7       	brne	.-38     	; 0x36e2 <DELAY_ms+0x146>
    3708:	89 a1       	ldd	r24, Y+33	; 0x21
    370a:	8d 87       	std	Y+13, r24	; 0x0d
    370c:	41 c0       	rjmp	.+130    	; 0x3790 <DELAY_ms+0x1f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    370e:	6a 89       	ldd	r22, Y+18	; 0x12
    3710:	7b 89       	ldd	r23, Y+19	; 0x13
    3712:	8c 89       	ldd	r24, Y+20	; 0x14
    3714:	9d 89       	ldd	r25, Y+21	; 0x15
    3716:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    371a:	dc 01       	movw	r26, r24
    371c:	cb 01       	movw	r24, r22
    371e:	9f 8b       	std	Y+23, r25	; 0x17
    3720:	8e 8b       	std	Y+22, r24	; 0x16
    3722:	8e 89       	ldd	r24, Y+22	; 0x16
    3724:	9f 89       	ldd	r25, Y+23	; 0x17
    3726:	9b 8f       	std	Y+27, r25	; 0x1b
    3728:	8a 8f       	std	Y+26, r24	; 0x1a
    372a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    372c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    372e:	01 97       	sbiw	r24, 0x01	; 1
    3730:	f1 f7       	brne	.-4      	; 0x372e <DELAY_ms+0x192>
    3732:	9b 8f       	std	Y+27, r25	; 0x1b
    3734:	8a 8f       	std	Y+26, r24	; 0x1a
    3736:	89 a1       	ldd	r24, Y+33	; 0x21
    3738:	8d 87       	std	Y+13, r24	; 0x0d
    373a:	2a c0       	rjmp	.+84     	; 0x3790 <DELAY_ms+0x1f4>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    373c:	20 e0       	ldi	r18, 0x00	; 0
    373e:	30 e0       	ldi	r19, 0x00	; 0
    3740:	4f e7       	ldi	r20, 0x7F	; 127
    3742:	53 e4       	ldi	r21, 0x43	; 67
    3744:	6d 81       	ldd	r22, Y+5	; 0x05
    3746:	7e 81       	ldd	r23, Y+6	; 0x06
    3748:	8f 81       	ldd	r24, Y+7	; 0x07
    374a:	98 85       	ldd	r25, Y+8	; 0x08
    374c:	0e 94 ff 33 	call	0x67fe	; 0x67fe <__gesf2>
    3750:	18 16       	cp	r1, r24
    3752:	ac f4       	brge	.+42     	; 0x377e <DELAY_ms+0x1e2>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    3754:	69 85       	ldd	r22, Y+9	; 0x09
    3756:	7a 85       	ldd	r23, Y+10	; 0x0a
    3758:	8b 85       	ldd	r24, Y+11	; 0x0b
    375a:	9c 85       	ldd	r25, Y+12	; 0x0c
    375c:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    3760:	dc 01       	movw	r26, r24
    3762:	cb 01       	movw	r24, r22
    3764:	9d 8f       	std	Y+29, r25	; 0x1d
    3766:	8c 8f       	std	Y+28, r24	; 0x1c
    3768:	8c 8d       	ldd	r24, Y+28	; 0x1c
    376a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    376c:	9f 8f       	std	Y+31, r25	; 0x1f
    376e:	8e 8f       	std	Y+30, r24	; 0x1e
    3770:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3772:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3774:	01 97       	sbiw	r24, 0x01	; 1
    3776:	f1 f7       	brne	.-4      	; 0x3774 <DELAY_ms+0x1d8>
    3778:	9f 8f       	std	Y+31, r25	; 0x1f
    377a:	8e 8f       	std	Y+30, r24	; 0x1e
    377c:	0f c0       	rjmp	.+30     	; 0x379c <DELAY_ms+0x200>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    377e:	6d 81       	ldd	r22, Y+5	; 0x05
    3780:	7e 81       	ldd	r23, Y+6	; 0x06
    3782:	8f 81       	ldd	r24, Y+7	; 0x07
    3784:	98 85       	ldd	r25, Y+8	; 0x08
    3786:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    378a:	dc 01       	movw	r26, r24
    378c:	cb 01       	movw	r24, r22
    378e:	8d 87       	std	Y+13, r24	; 0x0d
    3790:	8d 85       	ldd	r24, Y+13	; 0x0d
    3792:	88 a3       	std	Y+32, r24	; 0x20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3794:	88 a1       	ldd	r24, Y+32	; 0x20
    3796:	8a 95       	dec	r24
    3798:	f1 f7       	brne	.-4      	; 0x3796 <DELAY_ms+0x1fa>
    379a:	88 a3       	std	Y+32, r24	; 0x20
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
    379c:	8a a1       	ldd	r24, Y+34	; 0x22
    379e:	9b a1       	ldd	r25, Y+35	; 0x23
    37a0:	01 97       	sbiw	r24, 0x01	; 1
    37a2:	9b a3       	std	Y+35, r25	; 0x23
    37a4:	8a a3       	std	Y+34, r24	; 0x22
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
    37a6:	8a a1       	ldd	r24, Y+34	; 0x22
    37a8:	9b a1       	ldd	r25, Y+35	; 0x23
    37aa:	00 97       	sbiw	r24, 0x00	; 0
    37ac:	09 f0       	breq	.+2      	; 0x37b0 <DELAY_ms+0x214>
    37ae:	03 cf       	rjmp	.-506    	; 0x35b6 <DELAY_ms+0x1a>
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
    }
}
    37b0:	a3 96       	adiw	r28, 0x23	; 35
    37b2:	0f b6       	in	r0, 0x3f	; 63
    37b4:	f8 94       	cli
    37b6:	de bf       	out	0x3e, r29	; 62
    37b8:	0f be       	out	0x3f, r0	; 63
    37ba:	cd bf       	out	0x3d, r28	; 61
    37bc:	df 91       	pop	r29
    37be:	cf 91       	pop	r28
    37c0:	08 95       	ret

000037c2 <EEPROM_WriteByte>:

 * description: This function is used to write the data at specified EEPROM_address..

 **************************************************************************************************/
void EEPROM_WriteByte(uint16_t v_eepromAddress_u16, uint8_t v_eepromData_u8)
{
    37c2:	cf 93       	push	r28
    37c4:	df 93       	push	r29
    37c6:	00 d0       	rcall	.+0      	; 0x37c8 <EEPROM_WriteByte+0x6>
    37c8:	1f 92       	push	r1
    37ca:	cd b7       	in	r28, 0x3d	; 61
    37cc:	de b7       	in	r29, 0x3e	; 62
    37ce:	9a 83       	std	Y+2, r25	; 0x02
    37d0:	89 83       	std	Y+1, r24	; 0x01
    37d2:	6b 83       	std	Y+3, r22	; 0x03
	while(util_IsBitSet(EECR,EEWE)); // Wait for completion of previous write.
    37d4:	00 00       	nop
    37d6:	8c e3       	ldi	r24, 0x3C	; 60
    37d8:	90 e0       	ldi	r25, 0x00	; 0
    37da:	fc 01       	movw	r30, r24
    37dc:	80 81       	ld	r24, Z
    37de:	88 2f       	mov	r24, r24
    37e0:	90 e0       	ldi	r25, 0x00	; 0
    37e2:	82 70       	andi	r24, 0x02	; 2
    37e4:	99 27       	eor	r25, r25
    37e6:	00 97       	sbiw	r24, 0x00	; 0
    37e8:	b1 f7       	brne	.-20     	; 0x37d6 <EEPROM_WriteByte+0x14>
	                                 // EEWE will be cleared by hardware once Eeprom write is completed.

	EEAR = v_eepromAddress_u16;  //Load the eeprom address and data
    37ea:	8e e3       	ldi	r24, 0x3E	; 62
    37ec:	90 e0       	ldi	r25, 0x00	; 0
    37ee:	29 81       	ldd	r18, Y+1	; 0x01
    37f0:	3a 81       	ldd	r19, Y+2	; 0x02
    37f2:	fc 01       	movw	r30, r24
    37f4:	31 83       	std	Z+1, r19	; 0x01
    37f6:	20 83       	st	Z, r18
	EEDR = v_eepromData_u8;
    37f8:	8d e3       	ldi	r24, 0x3D	; 61
    37fa:	90 e0       	ldi	r25, 0x00	; 0
    37fc:	2b 81       	ldd	r18, Y+3	; 0x03
    37fe:	fc 01       	movw	r30, r24
    3800:	20 83       	st	Z, r18

	util_BitSet(EECR,EEMWE);    // Eeprom Master Write Enable
    3802:	8c e3       	ldi	r24, 0x3C	; 60
    3804:	90 e0       	ldi	r25, 0x00	; 0
    3806:	2c e3       	ldi	r18, 0x3C	; 60
    3808:	30 e0       	ldi	r19, 0x00	; 0
    380a:	f9 01       	movw	r30, r18
    380c:	20 81       	ld	r18, Z
    380e:	24 60       	ori	r18, 0x04	; 4
    3810:	fc 01       	movw	r30, r24
    3812:	20 83       	st	Z, r18
	util_BitSet(EECR,EEWE);     // Start eeprom write by setting EEWE
    3814:	8c e3       	ldi	r24, 0x3C	; 60
    3816:	90 e0       	ldi	r25, 0x00	; 0
    3818:	2c e3       	ldi	r18, 0x3C	; 60
    381a:	30 e0       	ldi	r19, 0x00	; 0
    381c:	f9 01       	movw	r30, r18
    381e:	20 81       	ld	r18, Z
    3820:	22 60       	ori	r18, 0x02	; 2
    3822:	fc 01       	movw	r30, r24
    3824:	20 83       	st	Z, r18
}
    3826:	0f 90       	pop	r0
    3828:	0f 90       	pop	r0
    382a:	0f 90       	pop	r0
    382c:	df 91       	pop	r29
    382e:	cf 91       	pop	r28
    3830:	08 95       	ret

00003832 <EEPROM_ReadByte>:
 * Return value	: uint8_t: data read from Eeprom.

 * description: This function is used to read the data from specified EEPROM_address.        
 ***************************************************************************************************/
uint8_t EEPROM_ReadByte(uint16_t v_eepromAddress_u16)
{
    3832:	cf 93       	push	r28
    3834:	df 93       	push	r29
    3836:	00 d0       	rcall	.+0      	; 0x3838 <EEPROM_ReadByte+0x6>
    3838:	cd b7       	in	r28, 0x3d	; 61
    383a:	de b7       	in	r29, 0x3e	; 62
    383c:	9a 83       	std	Y+2, r25	; 0x02
    383e:	89 83       	std	Y+1, r24	; 0x01
	while(util_IsBitSet(EECR,EEWE));  //Wait for completion of previous write if any.
    3840:	00 00       	nop
    3842:	8c e3       	ldi	r24, 0x3C	; 60
    3844:	90 e0       	ldi	r25, 0x00	; 0
    3846:	fc 01       	movw	r30, r24
    3848:	80 81       	ld	r24, Z
    384a:	88 2f       	mov	r24, r24
    384c:	90 e0       	ldi	r25, 0x00	; 0
    384e:	82 70       	andi	r24, 0x02	; 2
    3850:	99 27       	eor	r25, r25
    3852:	00 97       	sbiw	r24, 0x00	; 0
    3854:	b1 f7       	brne	.-20     	; 0x3842 <EEPROM_ReadByte+0x10>

	EEAR = v_eepromAddress_u16;    //Load the address from where the data needs to be read.
    3856:	8e e3       	ldi	r24, 0x3E	; 62
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	29 81       	ldd	r18, Y+1	; 0x01
    385c:	3a 81       	ldd	r19, Y+2	; 0x02
    385e:	fc 01       	movw	r30, r24
    3860:	31 83       	std	Z+1, r19	; 0x01
    3862:	20 83       	st	Z, r18
	util_BitSet(EECR,EERE);   // start eeprom read by setting EERE
    3864:	8c e3       	ldi	r24, 0x3C	; 60
    3866:	90 e0       	ldi	r25, 0x00	; 0
    3868:	2c e3       	ldi	r18, 0x3C	; 60
    386a:	30 e0       	ldi	r19, 0x00	; 0
    386c:	f9 01       	movw	r30, r18
    386e:	20 81       	ld	r18, Z
    3870:	21 60       	ori	r18, 0x01	; 1
    3872:	fc 01       	movw	r30, r24
    3874:	20 83       	st	Z, r18

	return EEDR;             // Return data from data register
    3876:	8d e3       	ldi	r24, 0x3D	; 61
    3878:	90 e0       	ldi	r25, 0x00	; 0
    387a:	fc 01       	movw	r30, r24
    387c:	80 81       	ld	r24, Z
}
    387e:	0f 90       	pop	r0
    3880:	0f 90       	pop	r0
    3882:	df 91       	pop	r29
    3884:	cf 91       	pop	r28
    3886:	08 95       	ret

00003888 <EEPROM_WriteString>:

   NOTE: Null char is also written into the eeprom.
 ***************************************************************************************************/
#if ( ENABLE_EEPROM_WriteString == 1)
void EEPROM_WriteString(uint16_t v_eepromAddress_u16, uint8_t *ptr_stringPointer_u8)
{
    3888:	cf 93       	push	r28
    388a:	df 93       	push	r29
    388c:	00 d0       	rcall	.+0      	; 0x388e <EEPROM_WriteString+0x6>
    388e:	00 d0       	rcall	.+0      	; 0x3890 <EEPROM_WriteString+0x8>
    3890:	cd b7       	in	r28, 0x3d	; 61
    3892:	de b7       	in	r29, 0x3e	; 62
    3894:	9a 83       	std	Y+2, r25	; 0x02
    3896:	89 83       	std	Y+1, r24	; 0x01
    3898:	7c 83       	std	Y+4, r23	; 0x04
    389a:	6b 83       	std	Y+3, r22	; 0x03
	do
	{
		EEPROM_WriteByte(v_eepromAddress_u16,*ptr_stringPointer_u8); //Write a byte from RAM to EEPROM
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	fc 01       	movw	r30, r24
    38a2:	20 81       	ld	r18, Z
    38a4:	89 81       	ldd	r24, Y+1	; 0x01
    38a6:	9a 81       	ldd	r25, Y+2	; 0x02
    38a8:	62 2f       	mov	r22, r18
    38aa:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <EEPROM_WriteByte>
		ptr_stringPointer_u8++;								//Increment the RAM Address
    38ae:	8b 81       	ldd	r24, Y+3	; 0x03
    38b0:	9c 81       	ldd	r25, Y+4	; 0x04
    38b2:	01 96       	adiw	r24, 0x01	; 1
    38b4:	9c 83       	std	Y+4, r25	; 0x04
    38b6:	8b 83       	std	Y+3, r24	; 0x03
		v_eepromAddress_u16++;								//Increment the Eeprom Address
    38b8:	89 81       	ldd	r24, Y+1	; 0x01
    38ba:	9a 81       	ldd	r25, Y+2	; 0x02
    38bc:	01 96       	adiw	r24, 0x01	; 1
    38be:	9a 83       	std	Y+2, r25	; 0x02
    38c0:	89 83       	std	Y+1, r24	; 0x01
	}while(*(ptr_stringPointer_u8-1) !=0);
    38c2:	8b 81       	ldd	r24, Y+3	; 0x03
    38c4:	9c 81       	ldd	r25, Y+4	; 0x04
    38c6:	01 97       	sbiw	r24, 0x01	; 1
    38c8:	fc 01       	movw	r30, r24
    38ca:	80 81       	ld	r24, Z
    38cc:	88 23       	and	r24, r24
    38ce:	31 f7       	brne	.-52     	; 0x389c <EEPROM_WriteString+0x14>
}
    38d0:	0f 90       	pop	r0
    38d2:	0f 90       	pop	r0
    38d4:	0f 90       	pop	r0
    38d6:	0f 90       	pop	r0
    38d8:	df 91       	pop	r29
    38da:	cf 91       	pop	r28
    38dc:	08 95       	ret

000038de <EEPROM_ReadString>:
 * description:This function is used to Read a String from specified EEPROM_address.
           The string read from eeprom will be copied to specified buffer along with NULL character
 ***************************************************************************************************/
#if ( ENABLE_EEPROM_ReadString == 1)
void EEPROM_ReadString(uint16_t v_eepromAddress_u16, uint8_t *ptr_destStringAddress_u8)
{
    38de:	cf 93       	push	r28
    38e0:	df 93       	push	r29
    38e2:	00 d0       	rcall	.+0      	; 0x38e4 <EEPROM_ReadString+0x6>
    38e4:	00 d0       	rcall	.+0      	; 0x38e6 <EEPROM_ReadString+0x8>
    38e6:	1f 92       	push	r1
    38e8:	cd b7       	in	r28, 0x3d	; 61
    38ea:	de b7       	in	r29, 0x3e	; 62
    38ec:	9b 83       	std	Y+3, r25	; 0x03
    38ee:	8a 83       	std	Y+2, r24	; 0x02
    38f0:	7d 83       	std	Y+5, r23	; 0x05
    38f2:	6c 83       	std	Y+4, r22	; 0x04
	char eeprom_data;

	do
	{
		eeprom_data = EEPROM_ReadByte(v_eepromAddress_u16); //Read a byte from EEPROM to RAM
    38f4:	8a 81       	ldd	r24, Y+2	; 0x02
    38f6:	9b 81       	ldd	r25, Y+3	; 0x03
    38f8:	0e 94 19 1c 	call	0x3832	; 0x3832 <EEPROM_ReadByte>
    38fc:	89 83       	std	Y+1, r24	; 0x01
		*ptr_destStringAddress_u8 = eeprom_data;			 //Copy the data into String Buffer
    38fe:	8c 81       	ldd	r24, Y+4	; 0x04
    3900:	9d 81       	ldd	r25, Y+5	; 0x05
    3902:	29 81       	ldd	r18, Y+1	; 0x01
    3904:	fc 01       	movw	r30, r24
    3906:	20 83       	st	Z, r18
		ptr_destStringAddress_u8++;						 //Increment the RAM Address
    3908:	8c 81       	ldd	r24, Y+4	; 0x04
    390a:	9d 81       	ldd	r25, Y+5	; 0x05
    390c:	01 96       	adiw	r24, 0x01	; 1
    390e:	9d 83       	std	Y+5, r25	; 0x05
    3910:	8c 83       	std	Y+4, r24	; 0x04
		v_eepromAddress_u16++;							 //Increment the Eeprom Address
    3912:	8a 81       	ldd	r24, Y+2	; 0x02
    3914:	9b 81       	ldd	r25, Y+3	; 0x03
    3916:	01 96       	adiw	r24, 0x01	; 1
    3918:	9b 83       	std	Y+3, r25	; 0x03
    391a:	8a 83       	std	Y+2, r24	; 0x02
	}while(eeprom_data!=0);
    391c:	89 81       	ldd	r24, Y+1	; 0x01
    391e:	88 23       	and	r24, r24
    3920:	49 f7       	brne	.-46     	; 0x38f4 <EEPROM_ReadString+0x16>
}
    3922:	0f 90       	pop	r0
    3924:	0f 90       	pop	r0
    3926:	0f 90       	pop	r0
    3928:	0f 90       	pop	r0
    392a:	0f 90       	pop	r0
    392c:	df 91       	pop	r29
    392e:	cf 91       	pop	r28
    3930:	08 95       	ret

00003932 <GPIO_PinDirection>:
 * Return value    : none

 * description :This function sets the specified direction as INPUT/OUTPUT.  
 ***************************************************************************************************/
void GPIO_PinDirection(gpioPins_et enm_pinNumber, uint8_t v_pinDirn_u8)
{
    3932:	cf 93       	push	r28
    3934:	df 93       	push	r29
    3936:	00 d0       	rcall	.+0      	; 0x3938 <GPIO_PinDirection+0x6>
    3938:	1f 92       	push	r1
    393a:	cd b7       	in	r28, 0x3d	; 61
    393c:	de b7       	in	r29, 0x3e	; 62
    393e:	8a 83       	std	Y+2, r24	; 0x02
    3940:	6b 83       	std	Y+3, r22	; 0x03

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    3942:	8a 81       	ldd	r24, Y+2	; 0x02
    3944:	86 95       	lsr	r24
    3946:	86 95       	lsr	r24
    3948:	86 95       	lsr	r24
    394a:	89 83       	std	Y+1, r24	; 0x01
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
    394c:	8a 81       	ldd	r24, Y+2	; 0x02
    394e:	87 70       	andi	r24, 0x07	; 7
    3950:	8a 83       	std	Y+2, r24	; 0x02

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
    3952:	89 81       	ldd	r24, Y+1	; 0x01
    3954:	88 2f       	mov	r24, r24
    3956:	90 e0       	ldi	r25, 0x00	; 0
    3958:	81 30       	cpi	r24, 0x01	; 1
    395a:	91 05       	cpc	r25, r1
    395c:	09 f4       	brne	.+2      	; 0x3960 <GPIO_PinDirection+0x2e>
    395e:	3f c0       	rjmp	.+126    	; 0x39de <GPIO_PinDirection+0xac>
    3960:	82 30       	cpi	r24, 0x02	; 2
    3962:	91 05       	cpc	r25, r1
    3964:	1c f4       	brge	.+6      	; 0x396c <GPIO_PinDirection+0x3a>
    3966:	00 97       	sbiw	r24, 0x00	; 0
    3968:	51 f0       	breq	.+20     	; 0x397e <GPIO_PinDirection+0x4c>
    396a:	c9 c0       	rjmp	.+402    	; 0x3afe <GPIO_PinDirection+0x1cc>
    396c:	82 30       	cpi	r24, 0x02	; 2
    396e:	91 05       	cpc	r25, r1
    3970:	09 f4       	brne	.+2      	; 0x3974 <GPIO_PinDirection+0x42>
    3972:	65 c0       	rjmp	.+202    	; 0x3a3e <GPIO_PinDirection+0x10c>
    3974:	83 30       	cpi	r24, 0x03	; 3
    3976:	91 05       	cpc	r25, r1
    3978:	09 f4       	brne	.+2      	; 0x397c <GPIO_PinDirection+0x4a>
    397a:	91 c0       	rjmp	.+290    	; 0x3a9e <GPIO_PinDirection+0x16c>
    397c:	c0 c0       	rjmp	.+384    	; 0x3afe <GPIO_PinDirection+0x1cc>
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	88 23       	and	r24, r24
    3982:	b1 f0       	breq	.+44     	; 0x39b0 <GPIO_PinDirection+0x7e>
    3984:	8a e3       	ldi	r24, 0x3A	; 58
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	2a e3       	ldi	r18, 0x3A	; 58
    398a:	30 e0       	ldi	r19, 0x00	; 0
    398c:	f9 01       	movw	r30, r18
    398e:	20 81       	ld	r18, Z
    3990:	62 2f       	mov	r22, r18
    3992:	2a 81       	ldd	r18, Y+2	; 0x02
    3994:	42 2f       	mov	r20, r18
    3996:	50 e0       	ldi	r21, 0x00	; 0
    3998:	21 e0       	ldi	r18, 0x01	; 1
    399a:	30 e0       	ldi	r19, 0x00	; 0
    399c:	04 2e       	mov	r0, r20
    399e:	02 c0       	rjmp	.+4      	; 0x39a4 <GPIO_PinDirection+0x72>
    39a0:	22 0f       	add	r18, r18
    39a2:	33 1f       	adc	r19, r19
    39a4:	0a 94       	dec	r0
    39a6:	e2 f7       	brpl	.-8      	; 0x39a0 <GPIO_PinDirection+0x6e>
    39a8:	26 2b       	or	r18, r22
    39aa:	fc 01       	movw	r30, r24
    39ac:	20 83       	st	Z, r18
        break;
    39ae:	a7 c0       	rjmp	.+334    	; 0x3afe <GPIO_PinDirection+0x1cc>
        set the direction as specified*/
    switch(v_portNumber_u8)
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
    39b0:	8a e3       	ldi	r24, 0x3A	; 58
    39b2:	90 e0       	ldi	r25, 0x00	; 0
    39b4:	2a e3       	ldi	r18, 0x3A	; 58
    39b6:	30 e0       	ldi	r19, 0x00	; 0
    39b8:	f9 01       	movw	r30, r18
    39ba:	20 81       	ld	r18, Z
    39bc:	62 2f       	mov	r22, r18
    39be:	2a 81       	ldd	r18, Y+2	; 0x02
    39c0:	42 2f       	mov	r20, r18
    39c2:	50 e0       	ldi	r21, 0x00	; 0
    39c4:	21 e0       	ldi	r18, 0x01	; 1
    39c6:	30 e0       	ldi	r19, 0x00	; 0
    39c8:	04 2e       	mov	r0, r20
    39ca:	02 c0       	rjmp	.+4      	; 0x39d0 <GPIO_PinDirection+0x9e>
    39cc:	22 0f       	add	r18, r18
    39ce:	33 1f       	adc	r19, r19
    39d0:	0a 94       	dec	r0
    39d2:	e2 f7       	brpl	.-8      	; 0x39cc <GPIO_PinDirection+0x9a>
    39d4:	20 95       	com	r18
    39d6:	26 23       	and	r18, r22
    39d8:	fc 01       	movw	r30, r24
    39da:	20 83       	st	Z, r18
        break;
    39dc:	90 c0       	rjmp	.+288    	; 0x3afe <GPIO_PinDirection+0x1cc>
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
    39de:	8b 81       	ldd	r24, Y+3	; 0x03
    39e0:	88 23       	and	r24, r24
    39e2:	b1 f0       	breq	.+44     	; 0x3a10 <GPIO_PinDirection+0xde>
    39e4:	87 e3       	ldi	r24, 0x37	; 55
    39e6:	90 e0       	ldi	r25, 0x00	; 0
    39e8:	27 e3       	ldi	r18, 0x37	; 55
    39ea:	30 e0       	ldi	r19, 0x00	; 0
    39ec:	f9 01       	movw	r30, r18
    39ee:	20 81       	ld	r18, Z
    39f0:	62 2f       	mov	r22, r18
    39f2:	2a 81       	ldd	r18, Y+2	; 0x02
    39f4:	42 2f       	mov	r20, r18
    39f6:	50 e0       	ldi	r21, 0x00	; 0
    39f8:	21 e0       	ldi	r18, 0x01	; 1
    39fa:	30 e0       	ldi	r19, 0x00	; 0
    39fc:	04 2e       	mov	r0, r20
    39fe:	02 c0       	rjmp	.+4      	; 0x3a04 <GPIO_PinDirection+0xd2>
    3a00:	22 0f       	add	r18, r18
    3a02:	33 1f       	adc	r19, r19
    3a04:	0a 94       	dec	r0
    3a06:	e2 f7       	brpl	.-8      	; 0x3a00 <GPIO_PinDirection+0xce>
    3a08:	26 2b       	or	r18, r22
    3a0a:	fc 01       	movw	r30, r24
    3a0c:	20 83       	st	Z, r18
        break;
    3a0e:	77 c0       	rjmp	.+238    	; 0x3afe <GPIO_PinDirection+0x1cc>
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
    3a10:	87 e3       	ldi	r24, 0x37	; 55
    3a12:	90 e0       	ldi	r25, 0x00	; 0
    3a14:	27 e3       	ldi	r18, 0x37	; 55
    3a16:	30 e0       	ldi	r19, 0x00	; 0
    3a18:	f9 01       	movw	r30, r18
    3a1a:	20 81       	ld	r18, Z
    3a1c:	62 2f       	mov	r22, r18
    3a1e:	2a 81       	ldd	r18, Y+2	; 0x02
    3a20:	42 2f       	mov	r20, r18
    3a22:	50 e0       	ldi	r21, 0x00	; 0
    3a24:	21 e0       	ldi	r18, 0x01	; 1
    3a26:	30 e0       	ldi	r19, 0x00	; 0
    3a28:	04 2e       	mov	r0, r20
    3a2a:	02 c0       	rjmp	.+4      	; 0x3a30 <GPIO_PinDirection+0xfe>
    3a2c:	22 0f       	add	r18, r18
    3a2e:	33 1f       	adc	r19, r19
    3a30:	0a 94       	dec	r0
    3a32:	e2 f7       	brpl	.-8      	; 0x3a2c <GPIO_PinDirection+0xfa>
    3a34:	20 95       	com	r18
    3a36:	26 23       	and	r18, r22
    3a38:	fc 01       	movw	r30, r24
    3a3a:	20 83       	st	Z, r18
        break;
    3a3c:	60 c0       	rjmp	.+192    	; 0x3afe <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
    3a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a40:	88 23       	and	r24, r24
    3a42:	b1 f0       	breq	.+44     	; 0x3a70 <GPIO_PinDirection+0x13e>
    3a44:	84 e3       	ldi	r24, 0x34	; 52
    3a46:	90 e0       	ldi	r25, 0x00	; 0
    3a48:	24 e3       	ldi	r18, 0x34	; 52
    3a4a:	30 e0       	ldi	r19, 0x00	; 0
    3a4c:	f9 01       	movw	r30, r18
    3a4e:	20 81       	ld	r18, Z
    3a50:	62 2f       	mov	r22, r18
    3a52:	2a 81       	ldd	r18, Y+2	; 0x02
    3a54:	42 2f       	mov	r20, r18
    3a56:	50 e0       	ldi	r21, 0x00	; 0
    3a58:	21 e0       	ldi	r18, 0x01	; 1
    3a5a:	30 e0       	ldi	r19, 0x00	; 0
    3a5c:	04 2e       	mov	r0, r20
    3a5e:	02 c0       	rjmp	.+4      	; 0x3a64 <GPIO_PinDirection+0x132>
    3a60:	22 0f       	add	r18, r18
    3a62:	33 1f       	adc	r19, r19
    3a64:	0a 94       	dec	r0
    3a66:	e2 f7       	brpl	.-8      	; 0x3a60 <GPIO_PinDirection+0x12e>
    3a68:	26 2b       	or	r18, r22
    3a6a:	fc 01       	movw	r30, r24
    3a6c:	20 83       	st	Z, r18
        break;
    3a6e:	47 c0       	rjmp	.+142    	; 0x3afe <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
    3a70:	84 e3       	ldi	r24, 0x34	; 52
    3a72:	90 e0       	ldi	r25, 0x00	; 0
    3a74:	24 e3       	ldi	r18, 0x34	; 52
    3a76:	30 e0       	ldi	r19, 0x00	; 0
    3a78:	f9 01       	movw	r30, r18
    3a7a:	20 81       	ld	r18, Z
    3a7c:	62 2f       	mov	r22, r18
    3a7e:	2a 81       	ldd	r18, Y+2	; 0x02
    3a80:	42 2f       	mov	r20, r18
    3a82:	50 e0       	ldi	r21, 0x00	; 0
    3a84:	21 e0       	ldi	r18, 0x01	; 1
    3a86:	30 e0       	ldi	r19, 0x00	; 0
    3a88:	04 2e       	mov	r0, r20
    3a8a:	02 c0       	rjmp	.+4      	; 0x3a90 <GPIO_PinDirection+0x15e>
    3a8c:	22 0f       	add	r18, r18
    3a8e:	33 1f       	adc	r19, r19
    3a90:	0a 94       	dec	r0
    3a92:	e2 f7       	brpl	.-8      	; 0x3a8c <GPIO_PinDirection+0x15a>
    3a94:	20 95       	com	r18
    3a96:	26 23       	and	r18, r22
    3a98:	fc 01       	movw	r30, r24
    3a9a:	20 83       	st	Z, r18
        break;
    3a9c:	30 c0       	rjmp	.+96     	; 0x3afe <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
    3a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa0:	88 23       	and	r24, r24
    3aa2:	b1 f0       	breq	.+44     	; 0x3ad0 <GPIO_PinDirection+0x19e>
    3aa4:	81 e3       	ldi	r24, 0x31	; 49
    3aa6:	90 e0       	ldi	r25, 0x00	; 0
    3aa8:	21 e3       	ldi	r18, 0x31	; 49
    3aaa:	30 e0       	ldi	r19, 0x00	; 0
    3aac:	f9 01       	movw	r30, r18
    3aae:	20 81       	ld	r18, Z
    3ab0:	62 2f       	mov	r22, r18
    3ab2:	2a 81       	ldd	r18, Y+2	; 0x02
    3ab4:	42 2f       	mov	r20, r18
    3ab6:	50 e0       	ldi	r21, 0x00	; 0
    3ab8:	21 e0       	ldi	r18, 0x01	; 1
    3aba:	30 e0       	ldi	r19, 0x00	; 0
    3abc:	04 2e       	mov	r0, r20
    3abe:	02 c0       	rjmp	.+4      	; 0x3ac4 <GPIO_PinDirection+0x192>
    3ac0:	22 0f       	add	r18, r18
    3ac2:	33 1f       	adc	r19, r19
    3ac4:	0a 94       	dec	r0
    3ac6:	e2 f7       	brpl	.-8      	; 0x3ac0 <GPIO_PinDirection+0x18e>
    3ac8:	26 2b       	or	r18, r22
    3aca:	fc 01       	movw	r30, r24
    3acc:	20 83       	st	Z, r18
    3ace:	16 c0       	rjmp	.+44     	; 0x3afc <GPIO_PinDirection+0x1ca>
    3ad0:	81 e3       	ldi	r24, 0x31	; 49
    3ad2:	90 e0       	ldi	r25, 0x00	; 0
    3ad4:	21 e3       	ldi	r18, 0x31	; 49
    3ad6:	30 e0       	ldi	r19, 0x00	; 0
    3ad8:	f9 01       	movw	r30, r18
    3ada:	20 81       	ld	r18, Z
    3adc:	62 2f       	mov	r22, r18
    3ade:	2a 81       	ldd	r18, Y+2	; 0x02
    3ae0:	42 2f       	mov	r20, r18
    3ae2:	50 e0       	ldi	r21, 0x00	; 0
    3ae4:	21 e0       	ldi	r18, 0x01	; 1
    3ae6:	30 e0       	ldi	r19, 0x00	; 0
    3ae8:	04 2e       	mov	r0, r20
    3aea:	02 c0       	rjmp	.+4      	; 0x3af0 <GPIO_PinDirection+0x1be>
    3aec:	22 0f       	add	r18, r18
    3aee:	33 1f       	adc	r19, r19
    3af0:	0a 94       	dec	r0
    3af2:	e2 f7       	brpl	.-8      	; 0x3aec <GPIO_PinDirection+0x1ba>
    3af4:	20 95       	com	r18
    3af6:	26 23       	and	r18, r22
    3af8:	fc 01       	movw	r30, r24
    3afa:	20 83       	st	Z, r18
        break;
    3afc:	00 00       	nop
    case 6:
        util_UpdateBit(DDRG,enm_pinNumber,v_pinDirn_u8);
        break;
#endif    
    }                
}
    3afe:	0f 90       	pop	r0
    3b00:	0f 90       	pop	r0
    3b02:	0f 90       	pop	r0
    3b04:	df 91       	pop	r29
    3b06:	cf 91       	pop	r28
    3b08:	08 95       	ret

00003b0a <GPIO_PinWrite>:
 * description :This function updates the specified value on the selected pin.  
                Before updating the pins status, the pin function should be selected and then
                the pin should be configured as OUTPUT 
***************************************************************************************************/
void GPIO_PinWrite(gpioPins_et enm_pinNumber, uint8_t v_pinValue_u8)
{
    3b0a:	cf 93       	push	r28
    3b0c:	df 93       	push	r29
    3b0e:	00 d0       	rcall	.+0      	; 0x3b10 <GPIO_PinWrite+0x6>
    3b10:	1f 92       	push	r1
    3b12:	cd b7       	in	r28, 0x3d	; 61
    3b14:	de b7       	in	r29, 0x3e	; 62
    3b16:	8a 83       	std	Y+2, r24	; 0x02
    3b18:	6b 83       	std	Y+3, r22	; 0x03

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    3b1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3b1c:	86 95       	lsr	r24
    3b1e:	86 95       	lsr	r24
    3b20:	86 95       	lsr	r24
    3b22:	89 83       	std	Y+1, r24	; 0x01
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
    3b24:	8a 81       	ldd	r24, Y+2	; 0x02
    3b26:	87 70       	andi	r24, 0x07	; 7
    3b28:	8a 83       	std	Y+2, r24	; 0x02

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
    3b2a:	89 81       	ldd	r24, Y+1	; 0x01
    3b2c:	88 2f       	mov	r24, r24
    3b2e:	90 e0       	ldi	r25, 0x00	; 0
    3b30:	81 30       	cpi	r24, 0x01	; 1
    3b32:	91 05       	cpc	r25, r1
    3b34:	09 f4       	brne	.+2      	; 0x3b38 <GPIO_PinWrite+0x2e>
    3b36:	3f c0       	rjmp	.+126    	; 0x3bb6 <GPIO_PinWrite+0xac>
    3b38:	82 30       	cpi	r24, 0x02	; 2
    3b3a:	91 05       	cpc	r25, r1
    3b3c:	1c f4       	brge	.+6      	; 0x3b44 <GPIO_PinWrite+0x3a>
    3b3e:	00 97       	sbiw	r24, 0x00	; 0
    3b40:	51 f0       	breq	.+20     	; 0x3b56 <GPIO_PinWrite+0x4c>
    3b42:	c9 c0       	rjmp	.+402    	; 0x3cd6 <GPIO_PinWrite+0x1cc>
    3b44:	82 30       	cpi	r24, 0x02	; 2
    3b46:	91 05       	cpc	r25, r1
    3b48:	09 f4       	brne	.+2      	; 0x3b4c <GPIO_PinWrite+0x42>
    3b4a:	65 c0       	rjmp	.+202    	; 0x3c16 <GPIO_PinWrite+0x10c>
    3b4c:	83 30       	cpi	r24, 0x03	; 3
    3b4e:	91 05       	cpc	r25, r1
    3b50:	09 f4       	brne	.+2      	; 0x3b54 <GPIO_PinWrite+0x4a>
    3b52:	91 c0       	rjmp	.+290    	; 0x3c76 <GPIO_PinWrite+0x16c>
    3b54:	c0 c0       	rjmp	.+384    	; 0x3cd6 <GPIO_PinWrite+0x1cc>
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
    3b56:	8b 81       	ldd	r24, Y+3	; 0x03
    3b58:	88 23       	and	r24, r24
    3b5a:	b1 f0       	breq	.+44     	; 0x3b88 <GPIO_PinWrite+0x7e>
    3b5c:	8b e3       	ldi	r24, 0x3B	; 59
    3b5e:	90 e0       	ldi	r25, 0x00	; 0
    3b60:	2b e3       	ldi	r18, 0x3B	; 59
    3b62:	30 e0       	ldi	r19, 0x00	; 0
    3b64:	f9 01       	movw	r30, r18
    3b66:	20 81       	ld	r18, Z
    3b68:	62 2f       	mov	r22, r18
    3b6a:	2a 81       	ldd	r18, Y+2	; 0x02
    3b6c:	42 2f       	mov	r20, r18
    3b6e:	50 e0       	ldi	r21, 0x00	; 0
    3b70:	21 e0       	ldi	r18, 0x01	; 1
    3b72:	30 e0       	ldi	r19, 0x00	; 0
    3b74:	04 2e       	mov	r0, r20
    3b76:	02 c0       	rjmp	.+4      	; 0x3b7c <GPIO_PinWrite+0x72>
    3b78:	22 0f       	add	r18, r18
    3b7a:	33 1f       	adc	r19, r19
    3b7c:	0a 94       	dec	r0
    3b7e:	e2 f7       	brpl	.-8      	; 0x3b78 <GPIO_PinWrite+0x6e>
    3b80:	26 2b       	or	r18, r22
    3b82:	fc 01       	movw	r30, r24
    3b84:	20 83       	st	Z, r18
        break;
    3b86:	a7 c0       	rjmp	.+334    	; 0x3cd6 <GPIO_PinWrite+0x1cc>
        update the value of the specified pin*/
    switch(v_portNumber_u8)
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
    3b88:	8b e3       	ldi	r24, 0x3B	; 59
    3b8a:	90 e0       	ldi	r25, 0x00	; 0
    3b8c:	2b e3       	ldi	r18, 0x3B	; 59
    3b8e:	30 e0       	ldi	r19, 0x00	; 0
    3b90:	f9 01       	movw	r30, r18
    3b92:	20 81       	ld	r18, Z
    3b94:	62 2f       	mov	r22, r18
    3b96:	2a 81       	ldd	r18, Y+2	; 0x02
    3b98:	42 2f       	mov	r20, r18
    3b9a:	50 e0       	ldi	r21, 0x00	; 0
    3b9c:	21 e0       	ldi	r18, 0x01	; 1
    3b9e:	30 e0       	ldi	r19, 0x00	; 0
    3ba0:	04 2e       	mov	r0, r20
    3ba2:	02 c0       	rjmp	.+4      	; 0x3ba8 <GPIO_PinWrite+0x9e>
    3ba4:	22 0f       	add	r18, r18
    3ba6:	33 1f       	adc	r19, r19
    3ba8:	0a 94       	dec	r0
    3baa:	e2 f7       	brpl	.-8      	; 0x3ba4 <GPIO_PinWrite+0x9a>
    3bac:	20 95       	com	r18
    3bae:	26 23       	and	r18, r22
    3bb0:	fc 01       	movw	r30, r24
    3bb2:	20 83       	st	Z, r18
        break;
    3bb4:	90 c0       	rjmp	.+288    	; 0x3cd6 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
    3bb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb8:	88 23       	and	r24, r24
    3bba:	b1 f0       	breq	.+44     	; 0x3be8 <GPIO_PinWrite+0xde>
    3bbc:	88 e3       	ldi	r24, 0x38	; 56
    3bbe:	90 e0       	ldi	r25, 0x00	; 0
    3bc0:	28 e3       	ldi	r18, 0x38	; 56
    3bc2:	30 e0       	ldi	r19, 0x00	; 0
    3bc4:	f9 01       	movw	r30, r18
    3bc6:	20 81       	ld	r18, Z
    3bc8:	62 2f       	mov	r22, r18
    3bca:	2a 81       	ldd	r18, Y+2	; 0x02
    3bcc:	42 2f       	mov	r20, r18
    3bce:	50 e0       	ldi	r21, 0x00	; 0
    3bd0:	21 e0       	ldi	r18, 0x01	; 1
    3bd2:	30 e0       	ldi	r19, 0x00	; 0
    3bd4:	04 2e       	mov	r0, r20
    3bd6:	02 c0       	rjmp	.+4      	; 0x3bdc <GPIO_PinWrite+0xd2>
    3bd8:	22 0f       	add	r18, r18
    3bda:	33 1f       	adc	r19, r19
    3bdc:	0a 94       	dec	r0
    3bde:	e2 f7       	brpl	.-8      	; 0x3bd8 <GPIO_PinWrite+0xce>
    3be0:	26 2b       	or	r18, r22
    3be2:	fc 01       	movw	r30, r24
    3be4:	20 83       	st	Z, r18
        break;
    3be6:	77 c0       	rjmp	.+238    	; 0x3cd6 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
    3be8:	88 e3       	ldi	r24, 0x38	; 56
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	28 e3       	ldi	r18, 0x38	; 56
    3bee:	30 e0       	ldi	r19, 0x00	; 0
    3bf0:	f9 01       	movw	r30, r18
    3bf2:	20 81       	ld	r18, Z
    3bf4:	62 2f       	mov	r22, r18
    3bf6:	2a 81       	ldd	r18, Y+2	; 0x02
    3bf8:	42 2f       	mov	r20, r18
    3bfa:	50 e0       	ldi	r21, 0x00	; 0
    3bfc:	21 e0       	ldi	r18, 0x01	; 1
    3bfe:	30 e0       	ldi	r19, 0x00	; 0
    3c00:	04 2e       	mov	r0, r20
    3c02:	02 c0       	rjmp	.+4      	; 0x3c08 <GPIO_PinWrite+0xfe>
    3c04:	22 0f       	add	r18, r18
    3c06:	33 1f       	adc	r19, r19
    3c08:	0a 94       	dec	r0
    3c0a:	e2 f7       	brpl	.-8      	; 0x3c04 <GPIO_PinWrite+0xfa>
    3c0c:	20 95       	com	r18
    3c0e:	26 23       	and	r18, r22
    3c10:	fc 01       	movw	r30, r24
    3c12:	20 83       	st	Z, r18
        break;
    3c14:	60 c0       	rjmp	.+192    	; 0x3cd6 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
    3c16:	8b 81       	ldd	r24, Y+3	; 0x03
    3c18:	88 23       	and	r24, r24
    3c1a:	b1 f0       	breq	.+44     	; 0x3c48 <GPIO_PinWrite+0x13e>
    3c1c:	85 e3       	ldi	r24, 0x35	; 53
    3c1e:	90 e0       	ldi	r25, 0x00	; 0
    3c20:	25 e3       	ldi	r18, 0x35	; 53
    3c22:	30 e0       	ldi	r19, 0x00	; 0
    3c24:	f9 01       	movw	r30, r18
    3c26:	20 81       	ld	r18, Z
    3c28:	62 2f       	mov	r22, r18
    3c2a:	2a 81       	ldd	r18, Y+2	; 0x02
    3c2c:	42 2f       	mov	r20, r18
    3c2e:	50 e0       	ldi	r21, 0x00	; 0
    3c30:	21 e0       	ldi	r18, 0x01	; 1
    3c32:	30 e0       	ldi	r19, 0x00	; 0
    3c34:	04 2e       	mov	r0, r20
    3c36:	02 c0       	rjmp	.+4      	; 0x3c3c <GPIO_PinWrite+0x132>
    3c38:	22 0f       	add	r18, r18
    3c3a:	33 1f       	adc	r19, r19
    3c3c:	0a 94       	dec	r0
    3c3e:	e2 f7       	brpl	.-8      	; 0x3c38 <GPIO_PinWrite+0x12e>
    3c40:	26 2b       	or	r18, r22
    3c42:	fc 01       	movw	r30, r24
    3c44:	20 83       	st	Z, r18
        break;
    3c46:	47 c0       	rjmp	.+142    	; 0x3cd6 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
    3c48:	85 e3       	ldi	r24, 0x35	; 53
    3c4a:	90 e0       	ldi	r25, 0x00	; 0
    3c4c:	25 e3       	ldi	r18, 0x35	; 53
    3c4e:	30 e0       	ldi	r19, 0x00	; 0
    3c50:	f9 01       	movw	r30, r18
    3c52:	20 81       	ld	r18, Z
    3c54:	62 2f       	mov	r22, r18
    3c56:	2a 81       	ldd	r18, Y+2	; 0x02
    3c58:	42 2f       	mov	r20, r18
    3c5a:	50 e0       	ldi	r21, 0x00	; 0
    3c5c:	21 e0       	ldi	r18, 0x01	; 1
    3c5e:	30 e0       	ldi	r19, 0x00	; 0
    3c60:	04 2e       	mov	r0, r20
    3c62:	02 c0       	rjmp	.+4      	; 0x3c68 <GPIO_PinWrite+0x15e>
    3c64:	22 0f       	add	r18, r18
    3c66:	33 1f       	adc	r19, r19
    3c68:	0a 94       	dec	r0
    3c6a:	e2 f7       	brpl	.-8      	; 0x3c64 <GPIO_PinWrite+0x15a>
    3c6c:	20 95       	com	r18
    3c6e:	26 23       	and	r18, r22
    3c70:	fc 01       	movw	r30, r24
    3c72:	20 83       	st	Z, r18
        break;
    3c74:	30 c0       	rjmp	.+96     	; 0x3cd6 <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
    3c76:	8b 81       	ldd	r24, Y+3	; 0x03
    3c78:	88 23       	and	r24, r24
    3c7a:	b1 f0       	breq	.+44     	; 0x3ca8 <GPIO_PinWrite+0x19e>
    3c7c:	82 e3       	ldi	r24, 0x32	; 50
    3c7e:	90 e0       	ldi	r25, 0x00	; 0
    3c80:	22 e3       	ldi	r18, 0x32	; 50
    3c82:	30 e0       	ldi	r19, 0x00	; 0
    3c84:	f9 01       	movw	r30, r18
    3c86:	20 81       	ld	r18, Z
    3c88:	62 2f       	mov	r22, r18
    3c8a:	2a 81       	ldd	r18, Y+2	; 0x02
    3c8c:	42 2f       	mov	r20, r18
    3c8e:	50 e0       	ldi	r21, 0x00	; 0
    3c90:	21 e0       	ldi	r18, 0x01	; 1
    3c92:	30 e0       	ldi	r19, 0x00	; 0
    3c94:	04 2e       	mov	r0, r20
    3c96:	02 c0       	rjmp	.+4      	; 0x3c9c <GPIO_PinWrite+0x192>
    3c98:	22 0f       	add	r18, r18
    3c9a:	33 1f       	adc	r19, r19
    3c9c:	0a 94       	dec	r0
    3c9e:	e2 f7       	brpl	.-8      	; 0x3c98 <GPIO_PinWrite+0x18e>
    3ca0:	26 2b       	or	r18, r22
    3ca2:	fc 01       	movw	r30, r24
    3ca4:	20 83       	st	Z, r18
    3ca6:	16 c0       	rjmp	.+44     	; 0x3cd4 <GPIO_PinWrite+0x1ca>
    3ca8:	82 e3       	ldi	r24, 0x32	; 50
    3caa:	90 e0       	ldi	r25, 0x00	; 0
    3cac:	22 e3       	ldi	r18, 0x32	; 50
    3cae:	30 e0       	ldi	r19, 0x00	; 0
    3cb0:	f9 01       	movw	r30, r18
    3cb2:	20 81       	ld	r18, Z
    3cb4:	62 2f       	mov	r22, r18
    3cb6:	2a 81       	ldd	r18, Y+2	; 0x02
    3cb8:	42 2f       	mov	r20, r18
    3cba:	50 e0       	ldi	r21, 0x00	; 0
    3cbc:	21 e0       	ldi	r18, 0x01	; 1
    3cbe:	30 e0       	ldi	r19, 0x00	; 0
    3cc0:	04 2e       	mov	r0, r20
    3cc2:	02 c0       	rjmp	.+4      	; 0x3cc8 <GPIO_PinWrite+0x1be>
    3cc4:	22 0f       	add	r18, r18
    3cc6:	33 1f       	adc	r19, r19
    3cc8:	0a 94       	dec	r0
    3cca:	e2 f7       	brpl	.-8      	; 0x3cc4 <GPIO_PinWrite+0x1ba>
    3ccc:	20 95       	com	r18
    3cce:	26 23       	and	r18, r22
    3cd0:	fc 01       	movw	r30, r24
    3cd2:	20 83       	st	Z, r18
        break;
    3cd4:	00 00       	nop
    case 6:
        util_UpdateBit(PORTG,enm_pinNumber,v_pinValue_u8);
        break;
#endif      
    }                
}
    3cd6:	0f 90       	pop	r0
    3cd8:	0f 90       	pop	r0
    3cda:	0f 90       	pop	r0
    3cdc:	df 91       	pop	r29
    3cde:	cf 91       	pop	r28
    3ce0:	08 95       	ret

00003ce2 <GPIO_PinRead>:

 * description :This function returns the status of the selected pin.
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    3ce2:	cf 93       	push	r28
    3ce4:	df 93       	push	r29
    3ce6:	00 d0       	rcall	.+0      	; 0x3ce8 <GPIO_PinRead+0x6>
    3ce8:	1f 92       	push	r1
    3cea:	cd b7       	in	r28, 0x3d	; 61
    3cec:	de b7       	in	r29, 0x3e	; 62
    3cee:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
    3cf0:	19 82       	std	Y+1, r1	; 0x01

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    3cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf4:	86 95       	lsr	r24
    3cf6:	86 95       	lsr	r24
    3cf8:	86 95       	lsr	r24
    3cfa:	8a 83       	std	Y+2, r24	; 0x02
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
    3cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cfe:	87 70       	andi	r24, 0x07	; 7
    3d00:	8b 83       	std	Y+3, r24	; 0x03

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    3d02:	8a 81       	ldd	r24, Y+2	; 0x02
    3d04:	88 2f       	mov	r24, r24
    3d06:	90 e0       	ldi	r25, 0x00	; 0
    3d08:	81 30       	cpi	r24, 0x01	; 1
    3d0a:	91 05       	cpc	r25, r1
    3d0c:	21 f1       	breq	.+72     	; 0x3d56 <GPIO_PinRead+0x74>
    3d0e:	82 30       	cpi	r24, 0x02	; 2
    3d10:	91 05       	cpc	r25, r1
    3d12:	1c f4       	brge	.+6      	; 0x3d1a <GPIO_PinRead+0x38>
    3d14:	00 97       	sbiw	r24, 0x00	; 0
    3d16:	49 f0       	breq	.+18     	; 0x3d2a <GPIO_PinRead+0x48>
    3d18:	60 c0       	rjmp	.+192    	; 0x3dda <GPIO_PinRead+0xf8>
    3d1a:	82 30       	cpi	r24, 0x02	; 2
    3d1c:	91 05       	cpc	r25, r1
    3d1e:	89 f1       	breq	.+98     	; 0x3d82 <GPIO_PinRead+0xa0>
    3d20:	83 30       	cpi	r24, 0x03	; 3
    3d22:	91 05       	cpc	r25, r1
    3d24:	09 f4       	brne	.+2      	; 0x3d28 <GPIO_PinRead+0x46>
    3d26:	43 c0       	rjmp	.+134    	; 0x3dae <GPIO_PinRead+0xcc>
    3d28:	58 c0       	rjmp	.+176    	; 0x3dda <GPIO_PinRead+0xf8>
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
    3d2a:	89 e3       	ldi	r24, 0x39	; 57
    3d2c:	90 e0       	ldi	r25, 0x00	; 0
    3d2e:	fc 01       	movw	r30, r24
    3d30:	80 81       	ld	r24, Z
    3d32:	88 2f       	mov	r24, r24
    3d34:	90 e0       	ldi	r25, 0x00	; 0
    3d36:	2b 81       	ldd	r18, Y+3	; 0x03
    3d38:	22 2f       	mov	r18, r18
    3d3a:	30 e0       	ldi	r19, 0x00	; 0
    3d3c:	02 c0       	rjmp	.+4      	; 0x3d42 <GPIO_PinRead+0x60>
    3d3e:	95 95       	asr	r25
    3d40:	87 95       	ror	r24
    3d42:	2a 95       	dec	r18
    3d44:	e2 f7       	brpl	.-8      	; 0x3d3e <GPIO_PinRead+0x5c>
    3d46:	81 70       	andi	r24, 0x01	; 1
    3d48:	99 27       	eor	r25, r25
    3d4a:	21 e0       	ldi	r18, 0x01	; 1
    3d4c:	00 97       	sbiw	r24, 0x00	; 0
    3d4e:	09 f4       	brne	.+2      	; 0x3d52 <GPIO_PinRead+0x70>
    3d50:	20 e0       	ldi	r18, 0x00	; 0
    3d52:	29 83       	std	Y+1, r18	; 0x01
        break;
    3d54:	42 c0       	rjmp	.+132    	; 0x3dda <GPIO_PinRead+0xf8>
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
    3d56:	86 e3       	ldi	r24, 0x36	; 54
    3d58:	90 e0       	ldi	r25, 0x00	; 0
    3d5a:	fc 01       	movw	r30, r24
    3d5c:	80 81       	ld	r24, Z
    3d5e:	88 2f       	mov	r24, r24
    3d60:	90 e0       	ldi	r25, 0x00	; 0
    3d62:	2b 81       	ldd	r18, Y+3	; 0x03
    3d64:	22 2f       	mov	r18, r18
    3d66:	30 e0       	ldi	r19, 0x00	; 0
    3d68:	02 c0       	rjmp	.+4      	; 0x3d6e <GPIO_PinRead+0x8c>
    3d6a:	95 95       	asr	r25
    3d6c:	87 95       	ror	r24
    3d6e:	2a 95       	dec	r18
    3d70:	e2 f7       	brpl	.-8      	; 0x3d6a <GPIO_PinRead+0x88>
    3d72:	81 70       	andi	r24, 0x01	; 1
    3d74:	99 27       	eor	r25, r25
    3d76:	21 e0       	ldi	r18, 0x01	; 1
    3d78:	00 97       	sbiw	r24, 0x00	; 0
    3d7a:	09 f4       	brne	.+2      	; 0x3d7e <GPIO_PinRead+0x9c>
    3d7c:	20 e0       	ldi	r18, 0x00	; 0
    3d7e:	29 83       	std	Y+1, r18	; 0x01
        break;
    3d80:	2c c0       	rjmp	.+88     	; 0x3dda <GPIO_PinRead+0xf8>
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
    3d82:	83 e3       	ldi	r24, 0x33	; 51
    3d84:	90 e0       	ldi	r25, 0x00	; 0
    3d86:	fc 01       	movw	r30, r24
    3d88:	80 81       	ld	r24, Z
    3d8a:	88 2f       	mov	r24, r24
    3d8c:	90 e0       	ldi	r25, 0x00	; 0
    3d8e:	2b 81       	ldd	r18, Y+3	; 0x03
    3d90:	22 2f       	mov	r18, r18
    3d92:	30 e0       	ldi	r19, 0x00	; 0
    3d94:	02 c0       	rjmp	.+4      	; 0x3d9a <GPIO_PinRead+0xb8>
    3d96:	95 95       	asr	r25
    3d98:	87 95       	ror	r24
    3d9a:	2a 95       	dec	r18
    3d9c:	e2 f7       	brpl	.-8      	; 0x3d96 <GPIO_PinRead+0xb4>
    3d9e:	81 70       	andi	r24, 0x01	; 1
    3da0:	99 27       	eor	r25, r25
    3da2:	21 e0       	ldi	r18, 0x01	; 1
    3da4:	00 97       	sbiw	r24, 0x00	; 0
    3da6:	09 f4       	brne	.+2      	; 0x3daa <GPIO_PinRead+0xc8>
    3da8:	20 e0       	ldi	r18, 0x00	; 0
    3daa:	29 83       	std	Y+1, r18	; 0x01
        break;
    3dac:	16 c0       	rjmp	.+44     	; 0x3dda <GPIO_PinRead+0xf8>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
    3dae:	80 e3       	ldi	r24, 0x30	; 48
    3db0:	90 e0       	ldi	r25, 0x00	; 0
    3db2:	fc 01       	movw	r30, r24
    3db4:	80 81       	ld	r24, Z
    3db6:	88 2f       	mov	r24, r24
    3db8:	90 e0       	ldi	r25, 0x00	; 0
    3dba:	2b 81       	ldd	r18, Y+3	; 0x03
    3dbc:	22 2f       	mov	r18, r18
    3dbe:	30 e0       	ldi	r19, 0x00	; 0
    3dc0:	02 c0       	rjmp	.+4      	; 0x3dc6 <GPIO_PinRead+0xe4>
    3dc2:	95 95       	asr	r25
    3dc4:	87 95       	ror	r24
    3dc6:	2a 95       	dec	r18
    3dc8:	e2 f7       	brpl	.-8      	; 0x3dc2 <GPIO_PinRead+0xe0>
    3dca:	81 70       	andi	r24, 0x01	; 1
    3dcc:	99 27       	eor	r25, r25
    3dce:	21 e0       	ldi	r18, 0x01	; 1
    3dd0:	00 97       	sbiw	r24, 0x00	; 0
    3dd2:	09 f4       	brne	.+2      	; 0x3dd6 <GPIO_PinRead+0xf4>
    3dd4:	20 e0       	ldi	r18, 0x00	; 0
    3dd6:	29 83       	std	Y+1, r18	; 0x01
        break;
    3dd8:	00 00       	nop
    case 6:
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
    3dda:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ddc:	0f 90       	pop	r0
    3dde:	0f 90       	pop	r0
    3de0:	0f 90       	pop	r0
    3de2:	df 91       	pop	r29
    3de4:	cf 91       	pop	r28
    3de6:	08 95       	ret

00003de8 <LCD_SetUp>:
 In case of four bit mode pass P_NC as parameter for D0-D3.
 If RW is not used then pass P_NC as parameter for RS.
 **************************************************************************************************/
void LCD_SetUp(gpioPins_et RS, gpioPins_et RW, gpioPins_et EN, gpioPins_et D0,
		gpioPins_et D1, gpioPins_et D2, gpioPins_et D3, gpioPins_et D4,
		gpioPins_et D5, gpioPins_et D6, gpioPins_et D7) {
    3de8:	8f 92       	push	r8
    3dea:	af 92       	push	r10
    3dec:	cf 92       	push	r12
    3dee:	ef 92       	push	r14
    3df0:	0f 93       	push	r16
    3df2:	cf 93       	push	r28
    3df4:	df 93       	push	r29
    3df6:	cd b7       	in	r28, 0x3d	; 61
    3df8:	de b7       	in	r29, 0x3e	; 62
    3dfa:	29 97       	sbiw	r28, 0x09	; 9
    3dfc:	0f b6       	in	r0, 0x3f	; 63
    3dfe:	f8 94       	cli
    3e00:	de bf       	out	0x3e, r29	; 62
    3e02:	0f be       	out	0x3f, r0	; 63
    3e04:	cd bf       	out	0x3d, r28	; 61
    3e06:	89 83       	std	Y+1, r24	; 0x01
    3e08:	6a 83       	std	Y+2, r22	; 0x02
    3e0a:	4b 83       	std	Y+3, r20	; 0x03
    3e0c:	2c 83       	std	Y+4, r18	; 0x04
    3e0e:	0d 83       	std	Y+5, r16	; 0x05
    3e10:	ee 82       	std	Y+6, r14	; 0x06
    3e12:	cf 82       	std	Y+7, r12	; 0x07
    3e14:	a8 86       	std	Y+8, r10	; 0x08
    3e16:	89 86       	std	Y+9, r8	; 0x09
	/* Copy the PIN numbers where the LCD is connected */
	LCDConfig.RS = RS;
    3e18:	89 81       	ldd	r24, Y+1	; 0x01
    3e1a:	80 93 a7 02 	sts	0x02A7, r24
	LCDConfig.RW = RW;
    3e1e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e20:	80 93 a8 02 	sts	0x02A8, r24
	LCDConfig.EN = EN;
    3e24:	8b 81       	ldd	r24, Y+3	; 0x03
    3e26:	80 93 a9 02 	sts	0x02A9, r24

	LCDConfig.D0 = D0;
    3e2a:	8c 81       	ldd	r24, Y+4	; 0x04
    3e2c:	80 93 aa 02 	sts	0x02AA, r24
	LCDConfig.D1 = D1;
    3e30:	8d 81       	ldd	r24, Y+5	; 0x05
    3e32:	80 93 ab 02 	sts	0x02AB, r24
	LCDConfig.D2 = D2;
    3e36:	8e 81       	ldd	r24, Y+6	; 0x06
    3e38:	80 93 ac 02 	sts	0x02AC, r24
	LCDConfig.D3 = D3;
    3e3c:	8f 81       	ldd	r24, Y+7	; 0x07
    3e3e:	80 93 ad 02 	sts	0x02AD, r24
	LCDConfig.D4 = D4;
    3e42:	88 85       	ldd	r24, Y+8	; 0x08
    3e44:	80 93 ae 02 	sts	0x02AE, r24
	LCDConfig.D5 = D5;
    3e48:	89 85       	ldd	r24, Y+9	; 0x09
    3e4a:	80 93 af 02 	sts	0x02AF, r24
	LCDConfig.D6 = D6;
    3e4e:	8b 89       	ldd	r24, Y+19	; 0x13
    3e50:	80 93 b0 02 	sts	0x02B0, r24
	LCDConfig.D7 = D7;
    3e54:	8c 89       	ldd	r24, Y+20	; 0x14
    3e56:	80 93 b1 02 	sts	0x02B1, r24

	if ((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC)) {
    3e5a:	8c 81       	ldd	r24, Y+4	; 0x04
    3e5c:	8f 3f       	cpi	r24, 0xFF	; 255
    3e5e:	49 f0       	breq	.+18     	; 0x3e72 <LCD_SetUp+0x8a>
    3e60:	8d 81       	ldd	r24, Y+5	; 0x05
    3e62:	8f 3f       	cpi	r24, 0xFF	; 255
    3e64:	31 f0       	breq	.+12     	; 0x3e72 <LCD_SetUp+0x8a>
    3e66:	8e 81       	ldd	r24, Y+6	; 0x06
    3e68:	8f 3f       	cpi	r24, 0xFF	; 255
    3e6a:	19 f0       	breq	.+6      	; 0x3e72 <LCD_SetUp+0x8a>
    3e6c:	8f 81       	ldd	r24, Y+7	; 0x07
    3e6e:	8f 3f       	cpi	r24, 0xFF	; 255
    3e70:	21 f4       	brne	.+8      	; 0x3e7a <LCD_SetUp+0x92>
		LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
    3e72:	84 e0       	ldi	r24, 0x04	; 4
    3e74:	80 93 a6 02 	sts	0x02A6, r24
    3e78:	13 c0       	rjmp	.+38     	; 0x3ea0 <LCD_SetUp+0xb8>
	} else {
		LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.
    3e7a:	88 e0       	ldi	r24, 0x08	; 8
    3e7c:	80 93 a6 02 	sts	0x02A6, r24
		GPIO_PinDirection(D0, OUTPUT);
    3e80:	61 e0       	ldi	r22, 0x01	; 1
    3e82:	8c 81       	ldd	r24, Y+4	; 0x04
    3e84:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
		GPIO_PinDirection(D1, OUTPUT);
    3e88:	61 e0       	ldi	r22, 0x01	; 1
    3e8a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e8c:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
		GPIO_PinDirection(D2, OUTPUT);
    3e90:	61 e0       	ldi	r22, 0x01	; 1
    3e92:	8e 81       	ldd	r24, Y+6	; 0x06
    3e94:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
		GPIO_PinDirection(D3, OUTPUT);
    3e98:	61 e0       	ldi	r22, 0x01	; 1
    3e9a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e9c:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
	}

	/* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
	GPIO_PinDirection(RS, OUTPUT);
    3ea0:	61 e0       	ldi	r22, 0x01	; 1
    3ea2:	89 81       	ldd	r24, Y+1	; 0x01
    3ea4:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
	GPIO_PinDirection(RW, OUTPUT);
    3ea8:	61 e0       	ldi	r22, 0x01	; 1
    3eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    3eac:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
	GPIO_PinDirection(EN, OUTPUT);
    3eb0:	61 e0       	ldi	r22, 0x01	; 1
    3eb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb4:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>

	GPIO_PinDirection(D4, OUTPUT);
    3eb8:	61 e0       	ldi	r22, 0x01	; 1
    3eba:	88 85       	ldd	r24, Y+8	; 0x08
    3ebc:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
	GPIO_PinDirection(D5, OUTPUT);
    3ec0:	61 e0       	ldi	r22, 0x01	; 1
    3ec2:	89 85       	ldd	r24, Y+9	; 0x09
    3ec4:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
	GPIO_PinDirection(D6, OUTPUT);
    3ec8:	61 e0       	ldi	r22, 0x01	; 1
    3eca:	8b 89       	ldd	r24, Y+19	; 0x13
    3ecc:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
	GPIO_PinDirection(D7, OUTPUT);
    3ed0:	61 e0       	ldi	r22, 0x01	; 1
    3ed2:	8c 89       	ldd	r24, Y+20	; 0x14
    3ed4:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
}
    3ed8:	29 96       	adiw	r28, 0x09	; 9
    3eda:	0f b6       	in	r0, 0x3f	; 63
    3edc:	f8 94       	cli
    3ede:	de bf       	out	0x3e, r29	; 62
    3ee0:	0f be       	out	0x3f, r0	; 63
    3ee2:	cd bf       	out	0x3d, r28	; 61
    3ee4:	df 91       	pop	r29
    3ee6:	cf 91       	pop	r28
    3ee8:	0f 91       	pop	r16
    3eea:	ef 90       	pop	r14
    3eec:	cf 90       	pop	r12
    3eee:	af 90       	pop	r10
    3ef0:	8f 90       	pop	r8
    3ef2:	08 95       	ret

00003ef4 <LCD_Init>:
 * Return value    : none

 * description  :This function is used to initialize the lcd.
 *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
 **************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8) {
    3ef4:	cf 93       	push	r28
    3ef6:	df 93       	push	r29
    3ef8:	00 d0       	rcall	.+0      	; 0x3efa <LCD_Init+0x6>
    3efa:	cd b7       	in	r28, 0x3d	; 61
    3efc:	de b7       	in	r29, 0x3e	; 62
    3efe:	89 83       	std	Y+1, r24	; 0x01
    3f00:	6a 83       	std	Y+2, r22	; 0x02

	LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
    3f02:	8a 81       	ldd	r24, Y+2	; 0x02
    3f04:	80 93 a5 02 	sts	0x02A5, r24
	LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
    3f08:	89 81       	ldd	r24, Y+1	; 0x01
    3f0a:	80 93 a4 02 	sts	0x02A4, r24
	if (v_lcdNoOfLines_u8 > C_LcdLineTwo) {
    3f0e:	89 81       	ldd	r24, Y+1	; 0x01
    3f10:	83 30       	cpi	r24, 0x03	; 3
    3f12:	50 f0       	brcs	.+20     	; 0x3f28 <LCD_Init+0x34>
		ARR_LcdLineNumAddress_U8[C_LcdLineTwo] = 0x90
    3f14:	8a 81       	ldd	r24, Y+2	; 0x02
    3f16:	8f 70       	andi	r24, 0x0F	; 15
    3f18:	80 57       	subi	r24, 0x70	; 112
    3f1a:	80 93 62 00 	sts	0x0062, r24
				+ (v_MaxCharsPerLine_u8 & 0x0fu);
		ARR_LcdLineNumAddress_U8[C_LcdLineThree] = 0xd0
    3f1e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f20:	8f 70       	andi	r24, 0x0F	; 15
    3f22:	80 53       	subi	r24, 0x30	; 48
    3f24:	80 93 63 00 	sts	0x0063, r24
				+ (v_MaxCharsPerLine_u8 & 0x0fu);
	}

	DELAY_ms(100);
    3f28:	84 e6       	ldi	r24, 0x64	; 100
    3f2a:	90 e0       	ldi	r25, 0x00	; 0
    3f2c:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>

	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    3f30:	80 91 a6 02 	lds	r24, 0x02A6
    3f34:	88 30       	cpi	r24, 0x08	; 8
    3f36:	21 f4       	brne	.+8      	; 0x3f40 <LCD_Init+0x4c>
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    3f38:	88 e3       	ldi	r24, 0x38	; 56
    3f3a:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
    3f3e:	09 c0       	rjmp	.+18     	; 0x3f52 <LCD_Init+0x5e>
	} else if (LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8) {
    3f40:	80 91 a6 02 	lds	r24, 0x02A6
    3f44:	84 30       	cpi	r24, 0x04	; 4
    3f46:	29 f4       	brne	.+10     	; 0x3f52 <LCD_Init+0x5e>
		lcd_Reset();
    3f48:	0e 94 a1 2b 	call	0x5742	; 0x5742 <lcd_Reset>
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type
    3f4c:	88 e2       	ldi	r24, 0x28	; 40
    3f4e:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
    3f52:	8e e0       	ldi	r24, 0x0E	; 14
    3f54:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
	LCD_Clear();            // Clear the LCD and go to First line First Position
    3f58:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <LCD_Clear>
}
    3f5c:	0f 90       	pop	r0
    3f5e:	0f 90       	pop	r0
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	08 95       	ret

00003f66 <LCD_Clear>:
 * I/P Arguments: none.
 * Return value    : none

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ****************************************************************************************************/
void LCD_Clear() {
    3f66:	cf 93       	push	r28
    3f68:	df 93       	push	r29
    3f6a:	cd b7       	in	r28, 0x3d	; 61
    3f6c:	de b7       	in	r29, 0x3e	; 62
	LCD_CmdWrite(CMD_LCD_CLEAR); // Clear the LCD and go to First line First Position
    3f6e:	81 e0       	ldi	r24, 0x01	; 1
    3f70:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
	LCD_GoToLine(C_LcdLineZero);
    3f74:	80 e0       	ldi	r24, 0x00	; 0
    3f76:	0e 94 c0 1f 	call	0x3f80	; 0x3f80 <LCD_GoToLine>
}
    3f7a:	df 91       	pop	r29
    3f7c:	cf 91       	pop	r28
    3f7e:	08 95       	ret

00003f80 <LCD_GoToLine>:
 C_LcdLineOne,
 C_LcdLineTwo,
 C_LcdLineThree,

 ****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8) {
    3f80:	cf 93       	push	r28
    3f82:	df 93       	push	r29
    3f84:	1f 92       	push	r1
    3f86:	cd b7       	in	r28, 0x3d	; 61
    3f88:	de b7       	in	r29, 0x3e	; 62
    3f8a:	89 83       	std	Y+1, r24	; 0x01
	if (v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8) {
    3f8c:	90 91 a4 02 	lds	r25, 0x02A4
    3f90:	89 81       	ldd	r24, Y+1	; 0x01
    3f92:	89 17       	cp	r24, r25
    3f94:	70 f4       	brcc	.+28     	; 0x3fb2 <LCD_GoToLine+0x32>
		/* If the line number is within range then
		 Move the Cursor to beginning of the specified line */
		v_LcdTrackCursorPos_U8 = 0x00;
    3f96:	10 92 b2 02 	sts	0x02B2, r1
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
    3f9a:	89 81       	ldd	r24, Y+1	; 0x01
    3f9c:	80 93 b3 02 	sts	0x02B3, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
    3fa0:	89 81       	ldd	r24, Y+1	; 0x01
    3fa2:	88 2f       	mov	r24, r24
    3fa4:	90 e0       	ldi	r25, 0x00	; 0
    3fa6:	80 5a       	subi	r24, 0xA0	; 160
    3fa8:	9f 4f       	sbci	r25, 0xFF	; 255
    3faa:	fc 01       	movw	r30, r24
    3fac:	80 81       	ld	r24, Z
    3fae:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
	}
}
    3fb2:	0f 90       	pop	r0
    3fb4:	df 91       	pop	r29
    3fb6:	cf 91       	pop	r28
    3fb8:	08 95       	ret

00003fba <LCD_GoToNextLine>:

 * description  :This function moves the Cursor to beginning of the next line.
 If the cursor is on last line and NextLine command is issued then
 it will move the cursor to first line.
 ****************************************************************************************************/
void LCD_GoToNextLine(void) {
    3fba:	cf 93       	push	r28
    3fbc:	df 93       	push	r29
    3fbe:	cd b7       	in	r28, 0x3d	; 61
    3fc0:	de b7       	in	r29, 0x3e	; 62
	/*Increment the current line number.
	 In case it exceeds the limit, rool it back to first line */
	v_LcdTrackLineNum_U8++;
    3fc2:	80 91 b3 02 	lds	r24, 0x02B3
    3fc6:	8f 5f       	subi	r24, 0xFF	; 255
    3fc8:	80 93 b3 02 	sts	0x02B3, r24
	v_LcdTrackCursorPos_U8 = 0x00;
    3fcc:	10 92 b2 02 	sts	0x02B2, r1
	if (v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
    3fd0:	90 91 a4 02 	lds	r25, 0x02A4
    3fd4:	80 91 b3 02 	lds	r24, 0x02B3
    3fd8:	89 17       	cp	r24, r25
    3fda:	10 f0       	brcs	.+4      	; 0x3fe0 <LCD_GoToNextLine+0x26>
		v_LcdTrackLineNum_U8 = C_LcdLineZero;
    3fdc:	10 92 b3 02 	sts	0x02B3, r1
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
    3fe0:	80 91 b3 02 	lds	r24, 0x02B3
    3fe4:	88 2f       	mov	r24, r24
    3fe6:	90 e0       	ldi	r25, 0x00	; 0
    3fe8:	80 5a       	subi	r24, 0xA0	; 160
    3fea:	9f 4f       	sbci	r25, 0xFF	; 255
    3fec:	fc 01       	movw	r30, r24
    3fee:	80 81       	ld	r24, Z
    3ff0:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
}
    3ff4:	df 91       	pop	r29
    3ff6:	cf 91       	pop	r28
    3ff8:	08 95       	ret

00003ffa <LCD_SetCursor>:

 Note:If the Input(Line/Char number) are out of range
 then no action will be taken
 ****************************************************************************************************/
#if ( Enable_LCD_SetCursor    == 1 )
void LCD_SetCursor(uint8_t v_lineNumber_u8, uint8_t v_charNumber_u8) {
    3ffa:	cf 93       	push	r28
    3ffc:	df 93       	push	r29
    3ffe:	00 d0       	rcall	.+0      	; 0x4000 <LCD_SetCursor+0x6>
    4000:	cd b7       	in	r28, 0x3d	; 61
    4002:	de b7       	in	r29, 0x3e	; 62
    4004:	89 83       	std	Y+1, r24	; 0x01
    4006:	6a 83       	std	Y+2, r22	; 0x02

	if ((v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
    4008:	90 91 a4 02 	lds	r25, 0x02A4
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	89 17       	cp	r24, r25
    4010:	b0 f4       	brcc	.+44     	; 0x403e <LCD_SetCursor+0x44>
			&& (v_charNumber_u8 < LCDConfig.v_MaxSupportedChars_U8)) {
    4012:	90 91 a5 02 	lds	r25, 0x02A5
    4016:	8a 81       	ldd	r24, Y+2	; 0x02
    4018:	89 17       	cp	r24, r25
    401a:	88 f4       	brcc	.+34     	; 0x403e <LCD_SetCursor+0x44>
		/*If the line number and char are in range then
		 move the Cursor to specified Position*/
		v_LcdTrackCursorPos_U8 = v_charNumber_u8;
    401c:	8a 81       	ldd	r24, Y+2	; 0x02
    401e:	80 93 b2 02 	sts	0x02B2, r24
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
    4022:	89 81       	ldd	r24, Y+1	; 0x01
    4024:	80 93 b3 02 	sts	0x02B3, r24
		LCD_CmdWrite(
				ARR_LcdLineNumAddress_U8[v_lineNumber_u8] + v_charNumber_u8);
    4028:	89 81       	ldd	r24, Y+1	; 0x01
    402a:	88 2f       	mov	r24, r24
    402c:	90 e0       	ldi	r25, 0x00	; 0
    402e:	80 5a       	subi	r24, 0xA0	; 160
    4030:	9f 4f       	sbci	r25, 0xFF	; 255
    4032:	fc 01       	movw	r30, r24
    4034:	90 81       	ld	r25, Z
			&& (v_charNumber_u8 < LCDConfig.v_MaxSupportedChars_U8)) {
		/*If the line number and char are in range then
		 move the Cursor to specified Position*/
		v_LcdTrackCursorPos_U8 = v_charNumber_u8;
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
		LCD_CmdWrite(
    4036:	8a 81       	ldd	r24, Y+2	; 0x02
    4038:	89 0f       	add	r24, r25
    403a:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
				ARR_LcdLineNumAddress_U8[v_lineNumber_u8] + v_charNumber_u8);
	}
}
    403e:	0f 90       	pop	r0
    4040:	0f 90       	pop	r0
    4042:	df 91       	pop	r29
    4044:	cf 91       	pop	r28
    4046:	08 95       	ret

00004048 <LCD_CmdWrite>:
 * description :This function sends a command to LCD.
 Some of the commonly used commands are defined in lcd.h.
 For more commands refer the data sheet and send the supported command.
 The behaviour is undefined if unsupported commands are sent.
 ****************************************************************************************************/
void LCD_CmdWrite(uint8_t v_lcdCmd_u8) {
    4048:	cf 93       	push	r28
    404a:	df 93       	push	r29
    404c:	1f 92       	push	r1
    404e:	cd b7       	in	r28, 0x3d	; 61
    4050:	de b7       	in	r29, 0x3e	; 62
    4052:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    4054:	0e 94 4a 2b 	call	0x5694	; 0x5694 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    4058:	80 91 a6 02 	lds	r24, 0x02A6
    405c:	88 30       	cpi	r24, 0x08	; 8
    405e:	21 f4       	brne	.+8      	; 0x4068 <LCD_CmdWrite+0x20>
		lcd_SendLowerNibble(v_lcdCmd_u8);
    4060:	89 81       	ldd	r24, Y+1	; 0x01
    4062:	0e 94 0d 2c 	call	0x581a	; 0x581a <lcd_SendLowerNibble>
    4066:	09 c0       	rjmp	.+18     	; 0x407a <LCD_CmdWrite+0x32>
	} else {
		lcd_SendHigherNibble(v_lcdCmd_u8);
    4068:	89 81       	ldd	r24, Y+1	; 0x01
    406a:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
		lcd_SendCmdSignals();
    406e:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <lcd_SendCmdSignals>
		v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
    4072:	89 81       	ldd	r24, Y+1	; 0x01
    4074:	82 95       	swap	r24
    4076:	80 7f       	andi	r24, 0xF0	; 240
    4078:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(v_lcdCmd_u8);
    407a:	89 81       	ldd	r24, Y+1	; 0x01
    407c:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    4080:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <lcd_SendCmdSignals>
}
    4084:	0f 90       	pop	r0
    4086:	df 91       	pop	r29
    4088:	cf 91       	pop	r28
    408a:	08 95       	ret

0000408c <LCD_DisplayChar>:

 * description  : This function sends a character to be displayed on LCD.
 Any valid ascii value can be passed to display respective character

 ****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8) {
    408c:	cf 93       	push	r28
    408e:	df 93       	push	r29
    4090:	1f 92       	push	r1
    4092:	cd b7       	in	r28, 0x3d	; 61
    4094:	de b7       	in	r29, 0x3e	; 62
    4096:	89 83       	std	Y+1, r24	; 0x01
	if ((v_LcdTrackCursorPos_U8 >= LCDConfig.v_MaxSupportedChars_U8)
    4098:	90 91 a5 02 	lds	r25, 0x02A5
    409c:	80 91 b2 02 	lds	r24, 0x02B2
    40a0:	89 17       	cp	r24, r25
    40a2:	18 f4       	brcc	.+6      	; 0x40aa <LCD_DisplayChar+0x1e>
			|| (v_lcdData_u8 == '\n')) {
    40a4:	89 81       	ldd	r24, Y+1	; 0x01
    40a6:	8a 30       	cpi	r24, 0x0A	; 10
    40a8:	11 f4       	brne	.+4      	; 0x40ae <LCD_DisplayChar+0x22>
		/* If the cursor has reached to end of line on page1
		 OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
    40aa:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <LCD_GoToNextLine>
	}
	if (v_lcdData_u8 != '\n') /* Display the character if its not newLine Char */
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
    40b0:	8a 30       	cpi	r24, 0x0A	; 10
    40b2:	41 f0       	breq	.+16     	; 0x40c4 <LCD_DisplayChar+0x38>
	{

		lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
    40b4:	89 81       	ldd	r24, Y+1	; 0x01
    40b6:	0e 94 06 2b 	call	0x560c	; 0x560c <lcd_DataWrite>
		v_LcdTrackCursorPos_U8++;
    40ba:	80 91 b2 02 	lds	r24, 0x02B2
    40be:	8f 5f       	subi	r24, 0xFF	; 255
    40c0:	80 93 b2 02 	sts	0x02B2, r24
	}
}
    40c4:	0f 90       	pop	r0
    40c6:	df 91       	pop	r29
    40c8:	cf 91       	pop	r28
    40ca:	08 95       	ret

000040cc <LCD_DisplayString>:
 1.The ptr_stringPointer_u8 points to the first char of the string
 and traverses till the end(NULL CHAR)and displays a char each time.

 ****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8) {
    40cc:	cf 93       	push	r28
    40ce:	df 93       	push	r29
    40d0:	00 d0       	rcall	.+0      	; 0x40d2 <LCD_DisplayString+0x6>
    40d2:	cd b7       	in	r28, 0x3d	; 61
    40d4:	de b7       	in	r29, 0x3e	; 62
    40d6:	9a 83       	std	Y+2, r25	; 0x02
    40d8:	89 83       	std	Y+1, r24	; 0x01
	while ((*ptr_stringPointer_u8) != 0)
    40da:	0b c0       	rjmp	.+22     	; 0x40f2 <LCD_DisplayString+0x26>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
    40dc:	89 81       	ldd	r24, Y+1	; 0x01
    40de:	9a 81       	ldd	r25, Y+2	; 0x02
    40e0:	9c 01       	movw	r18, r24
    40e2:	2f 5f       	subi	r18, 0xFF	; 255
    40e4:	3f 4f       	sbci	r19, 0xFF	; 255
    40e6:	3a 83       	std	Y+2, r19	; 0x02
    40e8:	29 83       	std	Y+1, r18	; 0x01
    40ea:	fc 01       	movw	r30, r24
    40ec:	80 81       	ld	r24, Z
    40ee:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
 and traverses till the end(NULL CHAR)and displays a char each time.

 ****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8) {
	while ((*ptr_stringPointer_u8) != 0)
    40f2:	89 81       	ldd	r24, Y+1	; 0x01
    40f4:	9a 81       	ldd	r25, Y+2	; 0x02
    40f6:	fc 01       	movw	r30, r24
    40f8:	80 81       	ld	r24, Z
    40fa:	88 23       	and	r24, r24
    40fc:	79 f7       	brne	.-34     	; 0x40dc <LCD_DisplayString+0x10>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
    40fe:	0f 90       	pop	r0
    4100:	0f 90       	pop	r0
    4102:	df 91       	pop	r29
    4104:	cf 91       	pop	r28
    4106:	08 95       	ret

00004108 <LCD_DisplayStringWithAddingToBuffor>:
#endif

#if (Enable_LCD_DisplayString==1)
void LCD_DisplayStringWithAddingToBuffor(const char *ptr_stringPointer_u8,
		int *x, int y) {
    4108:	cf 93       	push	r28
    410a:	df 93       	push	r29
    410c:	cd b7       	in	r28, 0x3d	; 61
    410e:	de b7       	in	r29, 0x3e	; 62
    4110:	27 97       	sbiw	r28, 0x07	; 7
    4112:	0f b6       	in	r0, 0x3f	; 63
    4114:	f8 94       	cli
    4116:	de bf       	out	0x3e, r29	; 62
    4118:	0f be       	out	0x3f, r0	; 63
    411a:	cd bf       	out	0x3d, r28	; 61
    411c:	9b 83       	std	Y+3, r25	; 0x03
    411e:	8a 83       	std	Y+2, r24	; 0x02
    4120:	7d 83       	std	Y+5, r23	; 0x05
    4122:	6c 83       	std	Y+4, r22	; 0x04
    4124:	5f 83       	std	Y+7, r21	; 0x07
    4126:	4e 83       	std	Y+6, r20	; 0x06
	while ((*ptr_stringPointer_u8) != 0) {
    4128:	36 c2       	rjmp	.+1132   	; 0x4596 <LCD_DisplayStringWithAddingToBuffor+0x48e>
		char tmp = (*ptr_stringPointer_u8++);
    412a:	8a 81       	ldd	r24, Y+2	; 0x02
    412c:	9b 81       	ldd	r25, Y+3	; 0x03
    412e:	9c 01       	movw	r18, r24
    4130:	2f 5f       	subi	r18, 0xFF	; 255
    4132:	3f 4f       	sbci	r19, 0xFF	; 255
    4134:	3b 83       	std	Y+3, r19	; 0x03
    4136:	2a 83       	std	Y+2, r18	; 0x02
    4138:	fc 01       	movw	r30, r24
    413a:	80 81       	ld	r24, Z
    413c:	89 83       	std	Y+1, r24	; 0x01

		if (tmp == '%') {
    413e:	89 81       	ldd	r24, Y+1	; 0x01
    4140:	85 32       	cpi	r24, 0x25	; 37
    4142:	09 f0       	breq	.+2      	; 0x4146 <LCD_DisplayStringWithAddingToBuffor+0x3e>
    4144:	04 c2       	rjmp	.+1032   	; 0x454e <LCD_DisplayStringWithAddingToBuffor+0x446>
			switch (*ptr_stringPointer_u8++) {
    4146:	8a 81       	ldd	r24, Y+2	; 0x02
    4148:	9b 81       	ldd	r25, Y+3	; 0x03
    414a:	9c 01       	movw	r18, r24
    414c:	2f 5f       	subi	r18, 0xFF	; 255
    414e:	3f 4f       	sbci	r19, 0xFF	; 255
    4150:	3b 83       	std	Y+3, r19	; 0x03
    4152:	2a 83       	std	Y+2, r18	; 0x02
    4154:	fc 01       	movw	r30, r24
    4156:	80 81       	ld	r24, Z
    4158:	88 2f       	mov	r24, r24
    415a:	90 e0       	ldi	r25, 0x00	; 0
    415c:	aa 27       	eor	r26, r26
    415e:	97 fd       	sbrc	r25, 7
    4160:	a0 95       	com	r26
    4162:	ba 2f       	mov	r27, r26
    4164:	45 e2       	ldi	r20, 0x25	; 37
    4166:	50 e0       	ldi	r21, 0x00	; 0
    4168:	28 e5       	ldi	r18, 0x58	; 88
    416a:	30 e0       	ldi	r19, 0x00	; 0
    416c:	84 1b       	sub	r24, r20
    416e:	95 0b       	sbc	r25, r21
    4170:	28 17       	cp	r18, r24
    4172:	39 07       	cpc	r19, r25
    4174:	08 f4       	brcc	.+2      	; 0x4178 <LCD_DisplayStringWithAddingToBuffor+0x70>
    4176:	0f c2       	rjmp	.+1054   	; 0x4596 <LCD_DisplayStringWithAddingToBuffor+0x48e>
    4178:	86 5d       	subi	r24, 0xD6	; 214
    417a:	9f 4f       	sbci	r25, 0xFF	; 255
    417c:	fc 01       	movw	r30, r24
    417e:	0c 94 36 32 	jmp	0x646c	; 0x646c <__tablejump2__>
			case '%':
				LCD_DisplayChar('%');
    4182:	85 e2       	ldi	r24, 0x25	; 37
    4184:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
				LCD_BUFFOR[y][(*x)] = '%';
    4188:	8c 81       	ldd	r24, Y+4	; 0x04
    418a:	9d 81       	ldd	r25, Y+5	; 0x05
    418c:	fc 01       	movw	r30, r24
    418e:	80 81       	ld	r24, Z
    4190:	91 81       	ldd	r25, Z+1	; 0x01
    4192:	2e 81       	ldd	r18, Y+6	; 0x06
    4194:	3f 81       	ldd	r19, Y+7	; 0x07
    4196:	22 95       	swap	r18
    4198:	32 95       	swap	r19
    419a:	30 7f       	andi	r19, 0xF0	; 240
    419c:	32 27       	eor	r19, r18
    419e:	20 7f       	andi	r18, 0xF0	; 240
    41a0:	32 27       	eor	r19, r18
    41a2:	82 0f       	add	r24, r18
    41a4:	93 1f       	adc	r25, r19
    41a6:	8c 57       	subi	r24, 0x7C	; 124
    41a8:	9d 4f       	sbci	r25, 0xFD	; 253
    41aa:	25 e2       	ldi	r18, 0x25	; 37
    41ac:	fc 01       	movw	r30, r24
    41ae:	20 83       	st	Z, r18
				(*x)++;
    41b0:	8c 81       	ldd	r24, Y+4	; 0x04
    41b2:	9d 81       	ldd	r25, Y+5	; 0x05
    41b4:	fc 01       	movw	r30, r24
    41b6:	80 81       	ld	r24, Z
    41b8:	91 81       	ldd	r25, Z+1	; 0x01
    41ba:	9c 01       	movw	r18, r24
    41bc:	2f 5f       	subi	r18, 0xFF	; 255
    41be:	3f 4f       	sbci	r19, 0xFF	; 255
    41c0:	8c 81       	ldd	r24, Y+4	; 0x04
    41c2:	9d 81       	ldd	r25, Y+5	; 0x05
    41c4:	fc 01       	movw	r30, r24
    41c6:	31 83       	std	Z+1, r19	; 0x01
    41c8:	20 83       	st	Z, r18
				break;
    41ca:	c0 c1       	rjmp	.+896    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '>':
				LCD_PrintSymbol(1);
    41cc:	81 e0       	ldi	r24, 0x01	; 1
    41ce:	90 e0       	ldi	r25, 0x00	; 0
    41d0:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '>';
    41d4:	8c 81       	ldd	r24, Y+4	; 0x04
    41d6:	9d 81       	ldd	r25, Y+5	; 0x05
    41d8:	fc 01       	movw	r30, r24
    41da:	80 81       	ld	r24, Z
    41dc:	91 81       	ldd	r25, Z+1	; 0x01
    41de:	2e 81       	ldd	r18, Y+6	; 0x06
    41e0:	3f 81       	ldd	r19, Y+7	; 0x07
    41e2:	22 95       	swap	r18
    41e4:	32 95       	swap	r19
    41e6:	30 7f       	andi	r19, 0xF0	; 240
    41e8:	32 27       	eor	r19, r18
    41ea:	20 7f       	andi	r18, 0xF0	; 240
    41ec:	32 27       	eor	r19, r18
    41ee:	82 0f       	add	r24, r18
    41f0:	93 1f       	adc	r25, r19
    41f2:	8c 57       	subi	r24, 0x7C	; 124
    41f4:	9d 4f       	sbci	r25, 0xFD	; 253
    41f6:	2e e3       	ldi	r18, 0x3E	; 62
    41f8:	fc 01       	movw	r30, r24
    41fa:	20 83       	st	Z, r18
				(*x)++;
    41fc:	8c 81       	ldd	r24, Y+4	; 0x04
    41fe:	9d 81       	ldd	r25, Y+5	; 0x05
    4200:	fc 01       	movw	r30, r24
    4202:	80 81       	ld	r24, Z
    4204:	91 81       	ldd	r25, Z+1	; 0x01
    4206:	9c 01       	movw	r18, r24
    4208:	2f 5f       	subi	r18, 0xFF	; 255
    420a:	3f 4f       	sbci	r19, 0xFF	; 255
    420c:	8c 81       	ldd	r24, Y+4	; 0x04
    420e:	9d 81       	ldd	r25, Y+5	; 0x05
    4210:	fc 01       	movw	r30, r24
    4212:	31 83       	std	Z+1, r19	; 0x01
    4214:	20 83       	st	Z, r18
				break;
    4216:	9a c1       	rjmp	.+820    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '<':
				LCD_PrintSymbol(2);
    4218:	82 e0       	ldi	r24, 0x02	; 2
    421a:	90 e0       	ldi	r25, 0x00	; 0
    421c:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '<';
    4220:	8c 81       	ldd	r24, Y+4	; 0x04
    4222:	9d 81       	ldd	r25, Y+5	; 0x05
    4224:	fc 01       	movw	r30, r24
    4226:	80 81       	ld	r24, Z
    4228:	91 81       	ldd	r25, Z+1	; 0x01
    422a:	2e 81       	ldd	r18, Y+6	; 0x06
    422c:	3f 81       	ldd	r19, Y+7	; 0x07
    422e:	22 95       	swap	r18
    4230:	32 95       	swap	r19
    4232:	30 7f       	andi	r19, 0xF0	; 240
    4234:	32 27       	eor	r19, r18
    4236:	20 7f       	andi	r18, 0xF0	; 240
    4238:	32 27       	eor	r19, r18
    423a:	82 0f       	add	r24, r18
    423c:	93 1f       	adc	r25, r19
    423e:	8c 57       	subi	r24, 0x7C	; 124
    4240:	9d 4f       	sbci	r25, 0xFD	; 253
    4242:	2c e3       	ldi	r18, 0x3C	; 60
    4244:	fc 01       	movw	r30, r24
    4246:	20 83       	st	Z, r18
				(*x)++;
    4248:	8c 81       	ldd	r24, Y+4	; 0x04
    424a:	9d 81       	ldd	r25, Y+5	; 0x05
    424c:	fc 01       	movw	r30, r24
    424e:	80 81       	ld	r24, Z
    4250:	91 81       	ldd	r25, Z+1	; 0x01
    4252:	9c 01       	movw	r18, r24
    4254:	2f 5f       	subi	r18, 0xFF	; 255
    4256:	3f 4f       	sbci	r19, 0xFF	; 255
    4258:	8c 81       	ldd	r24, Y+4	; 0x04
    425a:	9d 81       	ldd	r25, Y+5	; 0x05
    425c:	fc 01       	movw	r30, r24
    425e:	31 83       	std	Z+1, r19	; 0x01
    4260:	20 83       	st	Z, r18
				break;
    4262:	74 c1       	rjmp	.+744    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '|':
				LCD_PrintSymbol(3);
    4264:	83 e0       	ldi	r24, 0x03	; 3
    4266:	90 e0       	ldi	r25, 0x00	; 0
    4268:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '|';
    426c:	8c 81       	ldd	r24, Y+4	; 0x04
    426e:	9d 81       	ldd	r25, Y+5	; 0x05
    4270:	fc 01       	movw	r30, r24
    4272:	80 81       	ld	r24, Z
    4274:	91 81       	ldd	r25, Z+1	; 0x01
    4276:	2e 81       	ldd	r18, Y+6	; 0x06
    4278:	3f 81       	ldd	r19, Y+7	; 0x07
    427a:	22 95       	swap	r18
    427c:	32 95       	swap	r19
    427e:	30 7f       	andi	r19, 0xF0	; 240
    4280:	32 27       	eor	r19, r18
    4282:	20 7f       	andi	r18, 0xF0	; 240
    4284:	32 27       	eor	r19, r18
    4286:	82 0f       	add	r24, r18
    4288:	93 1f       	adc	r25, r19
    428a:	8c 57       	subi	r24, 0x7C	; 124
    428c:	9d 4f       	sbci	r25, 0xFD	; 253
    428e:	2c e7       	ldi	r18, 0x7C	; 124
    4290:	fc 01       	movw	r30, r24
    4292:	20 83       	st	Z, r18
				(*x)++;
    4294:	8c 81       	ldd	r24, Y+4	; 0x04
    4296:	9d 81       	ldd	r25, Y+5	; 0x05
    4298:	fc 01       	movw	r30, r24
    429a:	80 81       	ld	r24, Z
    429c:	91 81       	ldd	r25, Z+1	; 0x01
    429e:	9c 01       	movw	r18, r24
    42a0:	2f 5f       	subi	r18, 0xFF	; 255
    42a2:	3f 4f       	sbci	r19, 0xFF	; 255
    42a4:	8c 81       	ldd	r24, Y+4	; 0x04
    42a6:	9d 81       	ldd	r25, Y+5	; 0x05
    42a8:	fc 01       	movw	r30, r24
    42aa:	31 83       	std	Z+1, r19	; 0x01
    42ac:	20 83       	st	Z, r18
				break;
    42ae:	4e c1       	rjmp	.+668    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '{':
				LCD_PrintSymbol(4);
    42b0:	84 e0       	ldi	r24, 0x04	; 4
    42b2:	90 e0       	ldi	r25, 0x00	; 0
    42b4:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '{';
    42b8:	8c 81       	ldd	r24, Y+4	; 0x04
    42ba:	9d 81       	ldd	r25, Y+5	; 0x05
    42bc:	fc 01       	movw	r30, r24
    42be:	80 81       	ld	r24, Z
    42c0:	91 81       	ldd	r25, Z+1	; 0x01
    42c2:	2e 81       	ldd	r18, Y+6	; 0x06
    42c4:	3f 81       	ldd	r19, Y+7	; 0x07
    42c6:	22 95       	swap	r18
    42c8:	32 95       	swap	r19
    42ca:	30 7f       	andi	r19, 0xF0	; 240
    42cc:	32 27       	eor	r19, r18
    42ce:	20 7f       	andi	r18, 0xF0	; 240
    42d0:	32 27       	eor	r19, r18
    42d2:	82 0f       	add	r24, r18
    42d4:	93 1f       	adc	r25, r19
    42d6:	8c 57       	subi	r24, 0x7C	; 124
    42d8:	9d 4f       	sbci	r25, 0xFD	; 253
    42da:	2b e7       	ldi	r18, 0x7B	; 123
    42dc:	fc 01       	movw	r30, r24
    42de:	20 83       	st	Z, r18
				(*x)++;
    42e0:	8c 81       	ldd	r24, Y+4	; 0x04
    42e2:	9d 81       	ldd	r25, Y+5	; 0x05
    42e4:	fc 01       	movw	r30, r24
    42e6:	80 81       	ld	r24, Z
    42e8:	91 81       	ldd	r25, Z+1	; 0x01
    42ea:	9c 01       	movw	r18, r24
    42ec:	2f 5f       	subi	r18, 0xFF	; 255
    42ee:	3f 4f       	sbci	r19, 0xFF	; 255
    42f0:	8c 81       	ldd	r24, Y+4	; 0x04
    42f2:	9d 81       	ldd	r25, Y+5	; 0x05
    42f4:	fc 01       	movw	r30, r24
    42f6:	31 83       	std	Z+1, r19	; 0x01
    42f8:	20 83       	st	Z, r18
				break;
    42fa:	28 c1       	rjmp	.+592    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '}':
				LCD_PrintSymbol(5);
    42fc:	85 e0       	ldi	r24, 0x05	; 5
    42fe:	90 e0       	ldi	r25, 0x00	; 0
    4300:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '}';
    4304:	8c 81       	ldd	r24, Y+4	; 0x04
    4306:	9d 81       	ldd	r25, Y+5	; 0x05
    4308:	fc 01       	movw	r30, r24
    430a:	80 81       	ld	r24, Z
    430c:	91 81       	ldd	r25, Z+1	; 0x01
    430e:	2e 81       	ldd	r18, Y+6	; 0x06
    4310:	3f 81       	ldd	r19, Y+7	; 0x07
    4312:	22 95       	swap	r18
    4314:	32 95       	swap	r19
    4316:	30 7f       	andi	r19, 0xF0	; 240
    4318:	32 27       	eor	r19, r18
    431a:	20 7f       	andi	r18, 0xF0	; 240
    431c:	32 27       	eor	r19, r18
    431e:	82 0f       	add	r24, r18
    4320:	93 1f       	adc	r25, r19
    4322:	8c 57       	subi	r24, 0x7C	; 124
    4324:	9d 4f       	sbci	r25, 0xFD	; 253
    4326:	2d e7       	ldi	r18, 0x7D	; 125
    4328:	fc 01       	movw	r30, r24
    432a:	20 83       	st	Z, r18
				(*x)++;
    432c:	8c 81       	ldd	r24, Y+4	; 0x04
    432e:	9d 81       	ldd	r25, Y+5	; 0x05
    4330:	fc 01       	movw	r30, r24
    4332:	80 81       	ld	r24, Z
    4334:	91 81       	ldd	r25, Z+1	; 0x01
    4336:	9c 01       	movw	r18, r24
    4338:	2f 5f       	subi	r18, 0xFF	; 255
    433a:	3f 4f       	sbci	r19, 0xFF	; 255
    433c:	8c 81       	ldd	r24, Y+4	; 0x04
    433e:	9d 81       	ldd	r25, Y+5	; 0x05
    4340:	fc 01       	movw	r30, r24
    4342:	31 83       	std	Z+1, r19	; 0x01
    4344:	20 83       	st	Z, r18
				break;
    4346:	02 c1       	rjmp	.+516    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ',':
				LCD_PrintSymbol(6);
    4348:	86 e0       	ldi	r24, 0x06	; 6
    434a:	90 e0       	ldi	r25, 0x00	; 0
    434c:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ',';
    4350:	8c 81       	ldd	r24, Y+4	; 0x04
    4352:	9d 81       	ldd	r25, Y+5	; 0x05
    4354:	fc 01       	movw	r30, r24
    4356:	80 81       	ld	r24, Z
    4358:	91 81       	ldd	r25, Z+1	; 0x01
    435a:	2e 81       	ldd	r18, Y+6	; 0x06
    435c:	3f 81       	ldd	r19, Y+7	; 0x07
    435e:	22 95       	swap	r18
    4360:	32 95       	swap	r19
    4362:	30 7f       	andi	r19, 0xF0	; 240
    4364:	32 27       	eor	r19, r18
    4366:	20 7f       	andi	r18, 0xF0	; 240
    4368:	32 27       	eor	r19, r18
    436a:	82 0f       	add	r24, r18
    436c:	93 1f       	adc	r25, r19
    436e:	8c 57       	subi	r24, 0x7C	; 124
    4370:	9d 4f       	sbci	r25, 0xFD	; 253
    4372:	2c e2       	ldi	r18, 0x2C	; 44
    4374:	fc 01       	movw	r30, r24
    4376:	20 83       	st	Z, r18
				(*x)++;
    4378:	8c 81       	ldd	r24, Y+4	; 0x04
    437a:	9d 81       	ldd	r25, Y+5	; 0x05
    437c:	fc 01       	movw	r30, r24
    437e:	80 81       	ld	r24, Z
    4380:	91 81       	ldd	r25, Z+1	; 0x01
    4382:	9c 01       	movw	r18, r24
    4384:	2f 5f       	subi	r18, 0xFF	; 255
    4386:	3f 4f       	sbci	r19, 0xFF	; 255
    4388:	8c 81       	ldd	r24, Y+4	; 0x04
    438a:	9d 81       	ldd	r25, Y+5	; 0x05
    438c:	fc 01       	movw	r30, r24
    438e:	31 83       	std	Z+1, r19	; 0x01
    4390:	20 83       	st	Z, r18
				break;
    4392:	dc c0       	rjmp	.+440    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ':':
				LCD_PrintSymbol(7);
    4394:	87 e0       	ldi	r24, 0x07	; 7
    4396:	90 e0       	ldi	r25, 0x00	; 0
    4398:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ':';
    439c:	8c 81       	ldd	r24, Y+4	; 0x04
    439e:	9d 81       	ldd	r25, Y+5	; 0x05
    43a0:	fc 01       	movw	r30, r24
    43a2:	80 81       	ld	r24, Z
    43a4:	91 81       	ldd	r25, Z+1	; 0x01
    43a6:	2e 81       	ldd	r18, Y+6	; 0x06
    43a8:	3f 81       	ldd	r19, Y+7	; 0x07
    43aa:	22 95       	swap	r18
    43ac:	32 95       	swap	r19
    43ae:	30 7f       	andi	r19, 0xF0	; 240
    43b0:	32 27       	eor	r19, r18
    43b2:	20 7f       	andi	r18, 0xF0	; 240
    43b4:	32 27       	eor	r19, r18
    43b6:	82 0f       	add	r24, r18
    43b8:	93 1f       	adc	r25, r19
    43ba:	8c 57       	subi	r24, 0x7C	; 124
    43bc:	9d 4f       	sbci	r25, 0xFD	; 253
    43be:	2a e3       	ldi	r18, 0x3A	; 58
    43c0:	fc 01       	movw	r30, r24
    43c2:	20 83       	st	Z, r18
				(*x)++;
    43c4:	8c 81       	ldd	r24, Y+4	; 0x04
    43c6:	9d 81       	ldd	r25, Y+5	; 0x05
    43c8:	fc 01       	movw	r30, r24
    43ca:	80 81       	ld	r24, Z
    43cc:	91 81       	ldd	r25, Z+1	; 0x01
    43ce:	9c 01       	movw	r18, r24
    43d0:	2f 5f       	subi	r18, 0xFF	; 255
    43d2:	3f 4f       	sbci	r19, 0xFF	; 255
    43d4:	8c 81       	ldd	r24, Y+4	; 0x04
    43d6:	9d 81       	ldd	r25, Y+5	; 0x05
    43d8:	fc 01       	movw	r30, r24
    43da:	31 83       	std	Z+1, r19	; 0x01
    43dc:	20 83       	st	Z, r18
				break;
    43de:	b6 c0       	rjmp	.+364    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ';':
				LCD_PrintSymbol(8);
    43e0:	88 e0       	ldi	r24, 0x08	; 8
    43e2:	90 e0       	ldi	r25, 0x00	; 0
    43e4:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ';';
    43e8:	8c 81       	ldd	r24, Y+4	; 0x04
    43ea:	9d 81       	ldd	r25, Y+5	; 0x05
    43ec:	fc 01       	movw	r30, r24
    43ee:	80 81       	ld	r24, Z
    43f0:	91 81       	ldd	r25, Z+1	; 0x01
    43f2:	2e 81       	ldd	r18, Y+6	; 0x06
    43f4:	3f 81       	ldd	r19, Y+7	; 0x07
    43f6:	22 95       	swap	r18
    43f8:	32 95       	swap	r19
    43fa:	30 7f       	andi	r19, 0xF0	; 240
    43fc:	32 27       	eor	r19, r18
    43fe:	20 7f       	andi	r18, 0xF0	; 240
    4400:	32 27       	eor	r19, r18
    4402:	82 0f       	add	r24, r18
    4404:	93 1f       	adc	r25, r19
    4406:	8c 57       	subi	r24, 0x7C	; 124
    4408:	9d 4f       	sbci	r25, 0xFD	; 253
    440a:	2b e3       	ldi	r18, 0x3B	; 59
    440c:	fc 01       	movw	r30, r24
    440e:	20 83       	st	Z, r18
				(*x)++;
    4410:	8c 81       	ldd	r24, Y+4	; 0x04
    4412:	9d 81       	ldd	r25, Y+5	; 0x05
    4414:	fc 01       	movw	r30, r24
    4416:	80 81       	ld	r24, Z
    4418:	91 81       	ldd	r25, Z+1	; 0x01
    441a:	9c 01       	movw	r18, r24
    441c:	2f 5f       	subi	r18, 0xFF	; 255
    441e:	3f 4f       	sbci	r19, 0xFF	; 255
    4420:	8c 81       	ldd	r24, Y+4	; 0x04
    4422:	9d 81       	ldd	r25, Y+5	; 0x05
    4424:	fc 01       	movw	r30, r24
    4426:	31 83       	std	Z+1, r19	; 0x01
    4428:	20 83       	st	Z, r18
				break;
    442a:	90 c0       	rjmp	.+288    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '?':
				LCD_PrintBlock();
    442c:	0e 94 8f 2d 	call	0x5b1e	; 0x5b1e <LCD_PrintBlock>
				LCD_BUFFOR[y][(*x)] = '?';
    4430:	8c 81       	ldd	r24, Y+4	; 0x04
    4432:	9d 81       	ldd	r25, Y+5	; 0x05
    4434:	fc 01       	movw	r30, r24
    4436:	80 81       	ld	r24, Z
    4438:	91 81       	ldd	r25, Z+1	; 0x01
    443a:	2e 81       	ldd	r18, Y+6	; 0x06
    443c:	3f 81       	ldd	r19, Y+7	; 0x07
    443e:	22 95       	swap	r18
    4440:	32 95       	swap	r19
    4442:	30 7f       	andi	r19, 0xF0	; 240
    4444:	32 27       	eor	r19, r18
    4446:	20 7f       	andi	r18, 0xF0	; 240
    4448:	32 27       	eor	r19, r18
    444a:	82 0f       	add	r24, r18
    444c:	93 1f       	adc	r25, r19
    444e:	8c 57       	subi	r24, 0x7C	; 124
    4450:	9d 4f       	sbci	r25, 0xFD	; 253
    4452:	2f e3       	ldi	r18, 0x3F	; 63
    4454:	fc 01       	movw	r30, r24
    4456:	20 83       	st	Z, r18
				(*x)++;
    4458:	8c 81       	ldd	r24, Y+4	; 0x04
    445a:	9d 81       	ldd	r25, Y+5	; 0x05
    445c:	fc 01       	movw	r30, r24
    445e:	80 81       	ld	r24, Z
    4460:	91 81       	ldd	r25, Z+1	; 0x01
    4462:	9c 01       	movw	r18, r24
    4464:	2f 5f       	subi	r18, 0xFF	; 255
    4466:	3f 4f       	sbci	r19, 0xFF	; 255
    4468:	8c 81       	ldd	r24, Y+4	; 0x04
    446a:	9d 81       	ldd	r25, Y+5	; 0x05
    446c:	fc 01       	movw	r30, r24
    446e:	31 83       	std	Z+1, r19	; 0x01
    4470:	20 83       	st	Z, r18
				break;
    4472:	6c c0       	rjmp	.+216    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '[':
				LCD_PrintLArrow();
    4474:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <LCD_PrintLArrow>
				LCD_BUFFOR[y][(*x)] = '[';
    4478:	8c 81       	ldd	r24, Y+4	; 0x04
    447a:	9d 81       	ldd	r25, Y+5	; 0x05
    447c:	fc 01       	movw	r30, r24
    447e:	80 81       	ld	r24, Z
    4480:	91 81       	ldd	r25, Z+1	; 0x01
    4482:	2e 81       	ldd	r18, Y+6	; 0x06
    4484:	3f 81       	ldd	r19, Y+7	; 0x07
    4486:	22 95       	swap	r18
    4488:	32 95       	swap	r19
    448a:	30 7f       	andi	r19, 0xF0	; 240
    448c:	32 27       	eor	r19, r18
    448e:	20 7f       	andi	r18, 0xF0	; 240
    4490:	32 27       	eor	r19, r18
    4492:	82 0f       	add	r24, r18
    4494:	93 1f       	adc	r25, r19
    4496:	8c 57       	subi	r24, 0x7C	; 124
    4498:	9d 4f       	sbci	r25, 0xFD	; 253
    449a:	2b e5       	ldi	r18, 0x5B	; 91
    449c:	fc 01       	movw	r30, r24
    449e:	20 83       	st	Z, r18
				(*x)++;
    44a0:	8c 81       	ldd	r24, Y+4	; 0x04
    44a2:	9d 81       	ldd	r25, Y+5	; 0x05
    44a4:	fc 01       	movw	r30, r24
    44a6:	80 81       	ld	r24, Z
    44a8:	91 81       	ldd	r25, Z+1	; 0x01
    44aa:	9c 01       	movw	r18, r24
    44ac:	2f 5f       	subi	r18, 0xFF	; 255
    44ae:	3f 4f       	sbci	r19, 0xFF	; 255
    44b0:	8c 81       	ldd	r24, Y+4	; 0x04
    44b2:	9d 81       	ldd	r25, Y+5	; 0x05
    44b4:	fc 01       	movw	r30, r24
    44b6:	31 83       	std	Z+1, r19	; 0x01
    44b8:	20 83       	st	Z, r18
				break;
    44ba:	48 c0       	rjmp	.+144    	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ']':
				LCD_PrintRArrow();
    44bc:	0e 94 a3 2d 	call	0x5b46	; 0x5b46 <LCD_PrintRArrow>
				LCD_BUFFOR[y][(*x)] = ']';
    44c0:	8c 81       	ldd	r24, Y+4	; 0x04
    44c2:	9d 81       	ldd	r25, Y+5	; 0x05
    44c4:	fc 01       	movw	r30, r24
    44c6:	80 81       	ld	r24, Z
    44c8:	91 81       	ldd	r25, Z+1	; 0x01
    44ca:	2e 81       	ldd	r18, Y+6	; 0x06
    44cc:	3f 81       	ldd	r19, Y+7	; 0x07
    44ce:	22 95       	swap	r18
    44d0:	32 95       	swap	r19
    44d2:	30 7f       	andi	r19, 0xF0	; 240
    44d4:	32 27       	eor	r19, r18
    44d6:	20 7f       	andi	r18, 0xF0	; 240
    44d8:	32 27       	eor	r19, r18
    44da:	82 0f       	add	r24, r18
    44dc:	93 1f       	adc	r25, r19
    44de:	8c 57       	subi	r24, 0x7C	; 124
    44e0:	9d 4f       	sbci	r25, 0xFD	; 253
    44e2:	2d e5       	ldi	r18, 0x5D	; 93
    44e4:	fc 01       	movw	r30, r24
    44e6:	20 83       	st	Z, r18
				(*x)++;
    44e8:	8c 81       	ldd	r24, Y+4	; 0x04
    44ea:	9d 81       	ldd	r25, Y+5	; 0x05
    44ec:	fc 01       	movw	r30, r24
    44ee:	80 81       	ld	r24, Z
    44f0:	91 81       	ldd	r25, Z+1	; 0x01
    44f2:	9c 01       	movw	r18, r24
    44f4:	2f 5f       	subi	r18, 0xFF	; 255
    44f6:	3f 4f       	sbci	r19, 0xFF	; 255
    44f8:	8c 81       	ldd	r24, Y+4	; 0x04
    44fa:	9d 81       	ldd	r25, Y+5	; 0x05
    44fc:	fc 01       	movw	r30, r24
    44fe:	31 83       	std	Z+1, r19	; 0x01
    4500:	20 83       	st	Z, r18
				break;
    4502:	24 c0       	rjmp	.+72     	; 0x454c <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '.':
				LCD_PrintDot();
    4504:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <LCD_PrintDot>
				LCD_BUFFOR[y][(*x)] = '.';
    4508:	8c 81       	ldd	r24, Y+4	; 0x04
    450a:	9d 81       	ldd	r25, Y+5	; 0x05
    450c:	fc 01       	movw	r30, r24
    450e:	80 81       	ld	r24, Z
    4510:	91 81       	ldd	r25, Z+1	; 0x01
    4512:	2e 81       	ldd	r18, Y+6	; 0x06
    4514:	3f 81       	ldd	r19, Y+7	; 0x07
    4516:	22 95       	swap	r18
    4518:	32 95       	swap	r19
    451a:	30 7f       	andi	r19, 0xF0	; 240
    451c:	32 27       	eor	r19, r18
    451e:	20 7f       	andi	r18, 0xF0	; 240
    4520:	32 27       	eor	r19, r18
    4522:	82 0f       	add	r24, r18
    4524:	93 1f       	adc	r25, r19
    4526:	8c 57       	subi	r24, 0x7C	; 124
    4528:	9d 4f       	sbci	r25, 0xFD	; 253
    452a:	2e e2       	ldi	r18, 0x2E	; 46
    452c:	fc 01       	movw	r30, r24
    452e:	20 83       	st	Z, r18
				(*x)++;
    4530:	8c 81       	ldd	r24, Y+4	; 0x04
    4532:	9d 81       	ldd	r25, Y+5	; 0x05
    4534:	fc 01       	movw	r30, r24
    4536:	80 81       	ld	r24, Z
    4538:	91 81       	ldd	r25, Z+1	; 0x01
    453a:	9c 01       	movw	r18, r24
    453c:	2f 5f       	subi	r18, 0xFF	; 255
    453e:	3f 4f       	sbci	r19, 0xFF	; 255
    4540:	8c 81       	ldd	r24, Y+4	; 0x04
    4542:	9d 81       	ldd	r25, Y+5	; 0x05
    4544:	fc 01       	movw	r30, r24
    4546:	31 83       	std	Z+1, r19	; 0x01
    4548:	20 83       	st	Z, r18
				break;
    454a:	00 00       	nop
    454c:	24 c0       	rjmp	.+72     	; 0x4596 <LCD_DisplayStringWithAddingToBuffor+0x48e>
			}
		} else {
			LCD_DisplayChar(tmp);
    454e:	89 81       	ldd	r24, Y+1	; 0x01
    4550:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = tmp;
    4554:	8c 81       	ldd	r24, Y+4	; 0x04
    4556:	9d 81       	ldd	r25, Y+5	; 0x05
    4558:	fc 01       	movw	r30, r24
    455a:	80 81       	ld	r24, Z
    455c:	91 81       	ldd	r25, Z+1	; 0x01
    455e:	2e 81       	ldd	r18, Y+6	; 0x06
    4560:	3f 81       	ldd	r19, Y+7	; 0x07
    4562:	22 95       	swap	r18
    4564:	32 95       	swap	r19
    4566:	30 7f       	andi	r19, 0xF0	; 240
    4568:	32 27       	eor	r19, r18
    456a:	20 7f       	andi	r18, 0xF0	; 240
    456c:	32 27       	eor	r19, r18
    456e:	82 0f       	add	r24, r18
    4570:	93 1f       	adc	r25, r19
    4572:	8c 57       	subi	r24, 0x7C	; 124
    4574:	9d 4f       	sbci	r25, 0xFD	; 253
    4576:	29 81       	ldd	r18, Y+1	; 0x01
    4578:	fc 01       	movw	r30, r24
    457a:	20 83       	st	Z, r18
			(*x)++;
    457c:	8c 81       	ldd	r24, Y+4	; 0x04
    457e:	9d 81       	ldd	r25, Y+5	; 0x05
    4580:	fc 01       	movw	r30, r24
    4582:	80 81       	ld	r24, Z
    4584:	91 81       	ldd	r25, Z+1	; 0x01
    4586:	9c 01       	movw	r18, r24
    4588:	2f 5f       	subi	r18, 0xFF	; 255
    458a:	3f 4f       	sbci	r19, 0xFF	; 255
    458c:	8c 81       	ldd	r24, Y+4	; 0x04
    458e:	9d 81       	ldd	r25, Y+5	; 0x05
    4590:	fc 01       	movw	r30, r24
    4592:	31 83       	std	Z+1, r19	; 0x01
    4594:	20 83       	st	Z, r18
#endif

#if (Enable_LCD_DisplayString==1)
void LCD_DisplayStringWithAddingToBuffor(const char *ptr_stringPointer_u8,
		int *x, int y) {
	while ((*ptr_stringPointer_u8) != 0) {
    4596:	8a 81       	ldd	r24, Y+2	; 0x02
    4598:	9b 81       	ldd	r25, Y+3	; 0x03
    459a:	fc 01       	movw	r30, r24
    459c:	80 81       	ld	r24, Z
    459e:	88 23       	and	r24, r24
    45a0:	09 f0       	breq	.+2      	; 0x45a4 <LCD_DisplayStringWithAddingToBuffor+0x49c>
    45a2:	c3 cd       	rjmp	.-1146   	; 0x412a <LCD_DisplayStringWithAddingToBuffor+0x22>
			LCD_DisplayChar(tmp);
			LCD_BUFFOR[y][(*x)] = tmp;
			(*x)++;
		}
	}
}
    45a4:	27 96       	adiw	r28, 0x07	; 7
    45a6:	0f b6       	in	r0, 0x3f	; 63
    45a8:	f8 94       	cli
    45aa:	de bf       	out	0x3e, r29	; 62
    45ac:	0f be       	out	0x3f, r0	; 63
    45ae:	cd bf       	out	0x3d, r28	; 61
    45b0:	df 91       	pop	r29
    45b2:	cf 91       	pop	r28
    45b4:	08 95       	ret

000045b6 <LCD_ScrollMessage>:
 * description  :This function scrolls the given message on the specified line.
 If the specified line number is out of range then the message
 will be scrolled on first line
 ****************************************************************************************************/
#if ( Enable_LCD_ScrollMessage  == 1 )
void LCD_ScrollMessage(uint8_t v_lineNumber_u8, char *ptr_msgPointer_u8) {
    45b6:	cf 93       	push	r28
    45b8:	df 93       	push	r29
    45ba:	00 d0       	rcall	.+0      	; 0x45bc <LCD_ScrollMessage+0x6>
    45bc:	00 d0       	rcall	.+0      	; 0x45be <LCD_ScrollMessage+0x8>
    45be:	1f 92       	push	r1
    45c0:	cd b7       	in	r28, 0x3d	; 61
    45c2:	de b7       	in	r29, 0x3e	; 62
    45c4:	8b 83       	std	Y+3, r24	; 0x03
    45c6:	7d 83       	std	Y+5, r23	; 0x05
    45c8:	6c 83       	std	Y+4, r22	; 0x04
	unsigned char i, j;

	if (v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
    45ca:	90 91 a4 02 	lds	r25, 0x02A4
    45ce:	8b 81       	ldd	r24, Y+3	; 0x03
    45d0:	89 17       	cp	r24, r25
    45d2:	08 f0       	brcs	.+2      	; 0x45d6 <LCD_ScrollMessage+0x20>
		v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range
    45d4:	1b 82       	std	Y+3, r1	; 0x03

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor
    45d6:	8c e0       	ldi	r24, 0x0C	; 12
    45d8:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>

	for (i = 0; ptr_msgPointer_u8[i]; i++) {
    45dc:	19 82       	std	Y+1, r1	; 0x01
    45de:	40 c0       	rjmp	.+128    	; 0x4660 <LCD_ScrollMessage+0xaa>
		/* Loop to display the complete string,    each time 16 chars are displayed and
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line
    45e0:	8b 81       	ldd	r24, Y+3	; 0x03
    45e2:	0e 94 c0 1f 	call	0x3f80	; 0x3f80 <LCD_GoToLine>

		for (j = 0;
    45e6:	1a 82       	std	Y+2, r1	; 0x02
    45e8:	13 c0       	rjmp	.+38     	; 0x4610 <LCD_ScrollMessage+0x5a>
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
    45ea:	89 81       	ldd	r24, Y+1	; 0x01
    45ec:	28 2f       	mov	r18, r24
    45ee:	30 e0       	ldi	r19, 0x00	; 0
    45f0:	8a 81       	ldd	r24, Y+2	; 0x02
    45f2:	88 2f       	mov	r24, r24
    45f4:	90 e0       	ldi	r25, 0x00	; 0
    45f6:	82 0f       	add	r24, r18
    45f8:	93 1f       	adc	r25, r19
    45fa:	2c 81       	ldd	r18, Y+4	; 0x04
    45fc:	3d 81       	ldd	r19, Y+5	; 0x05
    45fe:	82 0f       	add	r24, r18
    4600:	93 1f       	adc	r25, r19
    4602:	fc 01       	movw	r30, r24
    4604:	80 81       	ld	r24, Z
    4606:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
    460a:	8a 81       	ldd	r24, Y+2	; 0x02
    460c:	8f 5f       	subi	r24, 0xFF	; 255
    460e:	8a 83       	std	Y+2, r24	; 0x02
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
				(j < LCDConfig.v_MaxSupportedChars_U8)
    4610:	90 91 a5 02 	lds	r25, 0x02A5
		/* Loop to display the complete string,    each time 16 chars are displayed and
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
    4614:	8a 81       	ldd	r24, Y+2	; 0x02
    4616:	89 17       	cp	r24, r25
    4618:	80 f4       	brcc	.+32     	; 0x463a <LCD_ScrollMessage+0x84>
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
    461a:	89 81       	ldd	r24, Y+1	; 0x01
    461c:	28 2f       	mov	r18, r24
    461e:	30 e0       	ldi	r19, 0x00	; 0
    4620:	8a 81       	ldd	r24, Y+2	; 0x02
    4622:	88 2f       	mov	r24, r24
    4624:	90 e0       	ldi	r25, 0x00	; 0
    4626:	82 0f       	add	r24, r18
    4628:	93 1f       	adc	r25, r19
    462a:	2c 81       	ldd	r18, Y+4	; 0x04
    462c:	3d 81       	ldd	r19, Y+5	; 0x05
    462e:	82 0f       	add	r24, r18
    4630:	93 1f       	adc	r25, r19
    4632:	fc 01       	movw	r30, r24
    4634:	80 81       	ld	r24, Z
    4636:	88 23       	and	r24, r24
    4638:	c1 f6       	brne	.-80     	; 0x45ea <LCD_ScrollMessage+0x34>
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
		}

		while (j < LCDConfig.v_MaxSupportedChars_U8) {
    463a:	06 c0       	rjmp	.+12     	; 0x4648 <LCD_ScrollMessage+0x92>
			/*If the chars to be scrolled are less than MaxLcdChars,
			 then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
    463c:	80 e2       	ldi	r24, 0x20	; 32
    463e:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
			j++;
    4642:	8a 81       	ldd	r24, Y+2	; 0x02
    4644:	8f 5f       	subi	r24, 0xFF	; 255
    4646:	8a 83       	std	Y+2, r24	; 0x02
						&& (ptr_msgPointer_u8[i + j]); j++) {
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
		}

		while (j < LCDConfig.v_MaxSupportedChars_U8) {
    4648:	90 91 a5 02 	lds	r25, 0x02A5
    464c:	8a 81       	ldd	r24, Y+2	; 0x02
    464e:	89 17       	cp	r24, r25
    4650:	a8 f3       	brcs	.-22     	; 0x463c <LCD_ScrollMessage+0x86>
			 then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
			j++;
		}

		DELAY_ms(C_ScrollDelayTime_U8);
    4652:	88 ec       	ldi	r24, 0xC8	; 200
    4654:	90 e0       	ldi	r25, 0x00	; 0
    4656:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	if (v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
		v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor

	for (i = 0; ptr_msgPointer_u8[i]; i++) {
    465a:	89 81       	ldd	r24, Y+1	; 0x01
    465c:	8f 5f       	subi	r24, 0xFF	; 255
    465e:	89 83       	std	Y+1, r24	; 0x01
    4660:	89 81       	ldd	r24, Y+1	; 0x01
    4662:	88 2f       	mov	r24, r24
    4664:	90 e0       	ldi	r25, 0x00	; 0
    4666:	2c 81       	ldd	r18, Y+4	; 0x04
    4668:	3d 81       	ldd	r19, Y+5	; 0x05
    466a:	82 0f       	add	r24, r18
    466c:	93 1f       	adc	r25, r19
    466e:	fc 01       	movw	r30, r24
    4670:	80 81       	ld	r24, Z
    4672:	88 23       	and	r24, r24
    4674:	09 f0       	breq	.+2      	; 0x4678 <LCD_ScrollMessage+0xc2>
    4676:	b4 cf       	rjmp	.-152    	; 0x45e0 <LCD_ScrollMessage+0x2a>
			j++;
		}

		DELAY_ms(C_ScrollDelayTime_U8);
	}
	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);         // Finally enable the Cursor
    4678:	8e e0       	ldi	r24, 0x0E	; 14
    467a:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
}
    467e:	0f 90       	pop	r0
    4680:	0f 90       	pop	r0
    4682:	0f 90       	pop	r0
    4684:	0f 90       	pop	r0
    4686:	0f 90       	pop	r0
    4688:	df 91       	pop	r29
    468a:	cf 91       	pop	r28
    468c:	08 95       	ret

0000468e <LCD_DisplayNumber>:
 8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
 9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32,
		uint8_t v_numOfDigitsToDisplay_u8) {
    468e:	ff 92       	push	r15
    4690:	0f 93       	push	r16
    4692:	1f 93       	push	r17
    4694:	cf 93       	push	r28
    4696:	df 93       	push	r29
    4698:	cd b7       	in	r28, 0x3d	; 61
    469a:	de b7       	in	r29, 0x3e	; 62
    469c:	69 97       	sbiw	r28, 0x19	; 25
    469e:	0f b6       	in	r0, 0x3f	; 63
    46a0:	f8 94       	cli
    46a2:	de bf       	out	0x3e, r29	; 62
    46a4:	0f be       	out	0x3f, r0	; 63
    46a6:	cd bf       	out	0x3d, r28	; 61
    46a8:	8c 87       	std	Y+12, r24	; 0x0c
    46aa:	4d 87       	std	Y+13, r20	; 0x0d
    46ac:	5e 87       	std	Y+14, r21	; 0x0e
    46ae:	6f 87       	std	Y+15, r22	; 0x0f
    46b0:	78 8b       	std	Y+16, r23	; 0x10
    46b2:	29 8b       	std	Y+17, r18	; 0x11
	uint8_t i = 0, a[10];
    46b4:	19 82       	std	Y+1, r1	; 0x01

	if (C_BINARY_U8 == v_numericSystem_u8) {
    46b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    46b8:	82 30       	cpi	r24, 0x02	; 2
    46ba:	69 f5       	brne	.+90     	; 0x4716 <LCD_DisplayNumber+0x88>
		while (v_numOfDigitsToDisplay_u8 != 0) {
    46bc:	28 c0       	rjmp	.+80     	; 0x470e <LCD_DisplayNumber+0x80>
			/* Start Extracting the bits from the specified bit positions.
			 Get the Acsii values of the bits and display */
			i = util_GetBitStatus(v_number_u32,
    46be:	89 89       	ldd	r24, Y+17	; 0x11
    46c0:	88 2f       	mov	r24, r24
    46c2:	90 e0       	ldi	r25, 0x00	; 0
    46c4:	9c 01       	movw	r18, r24
    46c6:	21 50       	subi	r18, 0x01	; 1
    46c8:	31 09       	sbc	r19, r1
    46ca:	81 e0       	ldi	r24, 0x01	; 1
    46cc:	90 e0       	ldi	r25, 0x00	; 0
    46ce:	02 c0       	rjmp	.+4      	; 0x46d4 <LCD_DisplayNumber+0x46>
    46d0:	88 0f       	add	r24, r24
    46d2:	99 1f       	adc	r25, r25
    46d4:	2a 95       	dec	r18
    46d6:	e2 f7       	brpl	.-8      	; 0x46d0 <LCD_DisplayNumber+0x42>
    46d8:	9c 01       	movw	r18, r24
    46da:	44 27       	eor	r20, r20
    46dc:	37 fd       	sbrc	r19, 7
    46de:	40 95       	com	r20
    46e0:	54 2f       	mov	r21, r20
    46e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    46e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    46e6:	af 85       	ldd	r26, Y+15	; 0x0f
    46e8:	b8 89       	ldd	r27, Y+16	; 0x10
    46ea:	82 23       	and	r24, r18
    46ec:	93 23       	and	r25, r19
    46ee:	a4 23       	and	r26, r20
    46f0:	b5 23       	and	r27, r21
    46f2:	21 e0       	ldi	r18, 0x01	; 1
    46f4:	00 97       	sbiw	r24, 0x00	; 0
    46f6:	a1 05       	cpc	r26, r1
    46f8:	b1 05       	cpc	r27, r1
    46fa:	09 f4       	brne	.+2      	; 0x46fe <LCD_DisplayNumber+0x70>
    46fc:	20 e0       	ldi	r18, 0x00	; 0
    46fe:	29 83       	std	Y+1, r18	; 0x01
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
    4700:	89 81       	ldd	r24, Y+1	; 0x01
    4702:	80 5d       	subi	r24, 0xD0	; 208
    4704:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
			v_numOfDigitsToDisplay_u8--;
    4708:	89 89       	ldd	r24, Y+17	; 0x11
    470a:	81 50       	subi	r24, 0x01	; 1
    470c:	89 8b       	std	Y+17, r24	; 0x11
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32,
		uint8_t v_numOfDigitsToDisplay_u8) {
	uint8_t i = 0, a[10];

	if (C_BINARY_U8 == v_numericSystem_u8) {
		while (v_numOfDigitsToDisplay_u8 != 0) {
    470e:	89 89       	ldd	r24, Y+17	; 0x11
    4710:	88 23       	and	r24, r24
    4712:	a9 f6       	brne	.-86     	; 0x46be <LCD_DisplayNumber+0x30>
    4714:	91 c0       	rjmp	.+290    	; 0x4838 <LCD_DisplayNumber+0x1aa>
			i = util_GetBitStatus(v_number_u32,
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
			v_numOfDigitsToDisplay_u8--;
		}
	} else if (v_number_u32 == 0) {
    4716:	8d 85       	ldd	r24, Y+13	; 0x0d
    4718:	9e 85       	ldd	r25, Y+14	; 0x0e
    471a:	af 85       	ldd	r26, Y+15	; 0x0f
    471c:	b8 89       	ldd	r27, Y+16	; 0x10
    471e:	00 97       	sbiw	r24, 0x00	; 0
    4720:	a1 05       	cpc	r26, r1
    4722:	b1 05       	cpc	r27, r1
    4724:	21 f4       	brne	.+8      	; 0x472e <LCD_DisplayNumber+0xa0>
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
    4726:	80 e3       	ldi	r24, 0x30	; 48
    4728:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
    472c:	85 c0       	rjmp	.+266    	; 0x4838 <LCD_DisplayNumber+0x1aa>
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    472e:	19 82       	std	Y+1, r1	; 0x01
    4730:	4f c0       	rjmp	.+158    	; 0x47d0 <LCD_DisplayNumber+0x142>
			/* Continue extracting the digits from right side
			 till the Specified v_numOfDigitsToDisplay_u8 */
			if (v_number_u32 != 0) {
    4732:	8d 85       	ldd	r24, Y+13	; 0x0d
    4734:	9e 85       	ldd	r25, Y+14	; 0x0e
    4736:	af 85       	ldd	r26, Y+15	; 0x0f
    4738:	b8 89       	ldd	r27, Y+16	; 0x10
    473a:	00 97       	sbiw	r24, 0x00	; 0
    473c:	a1 05       	cpc	r26, r1
    473e:	b1 05       	cpc	r27, r1
    4740:	a1 f1       	breq	.+104    	; 0x47aa <LCD_DisplayNumber+0x11c>
				 First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.

				 example for Decimal number:
				 If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
				 The process continues till it becomes zero or max digits reached*/
				a[i] = util_GetMod32(v_number_u32, v_numericSystem_u8);
    4742:	89 81       	ldd	r24, Y+1	; 0x01
    4744:	08 2f       	mov	r16, r24
    4746:	10 e0       	ldi	r17, 0x00	; 0
    4748:	fd 84       	ldd	r15, Y+13	; 0x0d
    474a:	8c 85       	ldd	r24, Y+12	; 0x0c
    474c:	28 2f       	mov	r18, r24
    474e:	30 e0       	ldi	r19, 0x00	; 0
    4750:	40 e0       	ldi	r20, 0x00	; 0
    4752:	50 e0       	ldi	r21, 0x00	; 0
    4754:	8d 85       	ldd	r24, Y+13	; 0x0d
    4756:	9e 85       	ldd	r25, Y+14	; 0x0e
    4758:	af 85       	ldd	r26, Y+15	; 0x0f
    475a:	b8 89       	ldd	r27, Y+16	; 0x10
    475c:	bc 01       	movw	r22, r24
    475e:	cd 01       	movw	r24, r26
    4760:	0e 94 14 32 	call	0x6428	; 0x6428 <__udivmodsi4>
    4764:	da 01       	movw	r26, r20
    4766:	c9 01       	movw	r24, r18
    4768:	98 2f       	mov	r25, r24
    476a:	8c 85       	ldd	r24, Y+12	; 0x0c
    476c:	98 9f       	mul	r25, r24
    476e:	80 2d       	mov	r24, r0
    4770:	11 24       	eor	r1, r1
    4772:	2f 2d       	mov	r18, r15
    4774:	28 1b       	sub	r18, r24
    4776:	ce 01       	movw	r24, r28
    4778:	02 96       	adiw	r24, 0x02	; 2
    477a:	80 0f       	add	r24, r16
    477c:	91 1f       	adc	r25, r17
    477e:	fc 01       	movw	r30, r24
    4780:	20 83       	st	Z, r18
				v_number_u32 = v_number_u32 / v_numericSystem_u8;
    4782:	8c 85       	ldd	r24, Y+12	; 0x0c
    4784:	28 2f       	mov	r18, r24
    4786:	30 e0       	ldi	r19, 0x00	; 0
    4788:	40 e0       	ldi	r20, 0x00	; 0
    478a:	50 e0       	ldi	r21, 0x00	; 0
    478c:	8d 85       	ldd	r24, Y+13	; 0x0d
    478e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4790:	af 85       	ldd	r26, Y+15	; 0x0f
    4792:	b8 89       	ldd	r27, Y+16	; 0x10
    4794:	bc 01       	movw	r22, r24
    4796:	cd 01       	movw	r24, r26
    4798:	0e 94 14 32 	call	0x6428	; 0x6428 <__udivmodsi4>
    479c:	da 01       	movw	r26, r20
    479e:	c9 01       	movw	r24, r18
    47a0:	8d 87       	std	Y+13, r24	; 0x0d
    47a2:	9e 87       	std	Y+14, r25	; 0x0e
    47a4:	af 87       	std	Y+15, r26	; 0x0f
    47a6:	b8 8b       	std	Y+16, r27	; 0x10
    47a8:	10 c0       	rjmp	.+32     	; 0x47ca <LCD_DisplayNumber+0x13c>
			} else if ((v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8)
    47aa:	89 89       	ldd	r24, Y+17	; 0x11
    47ac:	8f 3f       	cpi	r24, 0xFF	; 255
    47ae:	a9 f0       	breq	.+42     	; 0x47da <LCD_DisplayNumber+0x14c>
					|| (v_numOfDigitsToDisplay_u8 > C_MaxDigitsToDisplay_U8)) {
    47b0:	89 89       	ldd	r24, Y+17	; 0x11
    47b2:	8b 30       	cpi	r24, 0x0B	; 11
    47b4:	90 f4       	brcc	.+36     	; 0x47da <LCD_DisplayNumber+0x14c>
				break;
			} else {
				/* In case user expects more digits to be displayed than the actual digits in number,
				 then update the remaining digits with zero.
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
    47b6:	89 81       	ldd	r24, Y+1	; 0x01
    47b8:	88 2f       	mov	r24, r24
    47ba:	90 e0       	ldi	r25, 0x00	; 0
    47bc:	9e 01       	movw	r18, r28
    47be:	2e 5f       	subi	r18, 0xFE	; 254
    47c0:	3f 4f       	sbci	r19, 0xFF	; 255
    47c2:	82 0f       	add	r24, r18
    47c4:	93 1f       	adc	r25, r19
    47c6:	fc 01       	movw	r30, r24
    47c8:	10 82       	st	Z, r1
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    47ca:	89 81       	ldd	r24, Y+1	; 0x01
    47cc:	8f 5f       	subi	r24, 0xFF	; 255
    47ce:	89 83       	std	Y+1, r24	; 0x01
    47d0:	99 81       	ldd	r25, Y+1	; 0x01
    47d2:	89 89       	ldd	r24, Y+17	; 0x11
    47d4:	98 17       	cp	r25, r24
    47d6:	08 f4       	brcc	.+2      	; 0x47da <LCD_DisplayNumber+0x14c>
    47d8:	ac cf       	rjmp	.-168    	; 0x4732 <LCD_DisplayNumber+0xa4>
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    47da:	2b c0       	rjmp	.+86     	; 0x4832 <LCD_DisplayNumber+0x1a4>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
    47dc:	89 81       	ldd	r24, Y+1	; 0x01
    47de:	88 2f       	mov	r24, r24
    47e0:	90 e0       	ldi	r25, 0x00	; 0
    47e2:	01 97       	sbiw	r24, 0x01	; 1
    47e4:	9e 01       	movw	r18, r28
    47e6:	2e 5f       	subi	r18, 0xFE	; 254
    47e8:	3f 4f       	sbci	r19, 0xFF	; 255
    47ea:	82 0f       	add	r24, r18
    47ec:	93 1f       	adc	r25, r19
    47ee:	fc 01       	movw	r30, r24
    47f0:	80 81       	ld	r24, Z
    47f2:	8a 30       	cpi	r24, 0x0A	; 10
    47f4:	68 f0       	brcs	.+26     	; 0x4810 <LCD_DisplayNumber+0x182>
    47f6:	89 81       	ldd	r24, Y+1	; 0x01
    47f8:	88 2f       	mov	r24, r24
    47fa:	90 e0       	ldi	r25, 0x00	; 0
    47fc:	01 97       	sbiw	r24, 0x01	; 1
    47fe:	9e 01       	movw	r18, r28
    4800:	2e 5f       	subi	r18, 0xFE	; 254
    4802:	3f 4f       	sbci	r19, 0xFF	; 255
    4804:	82 0f       	add	r24, r18
    4806:	93 1f       	adc	r25, r19
    4808:	fc 01       	movw	r30, r24
    480a:	80 81       	ld	r24, Z
    480c:	89 5c       	subi	r24, 0xC9	; 201
    480e:	0c c0       	rjmp	.+24     	; 0x4828 <LCD_DisplayNumber+0x19a>
    4810:	89 81       	ldd	r24, Y+1	; 0x01
    4812:	88 2f       	mov	r24, r24
    4814:	90 e0       	ldi	r25, 0x00	; 0
    4816:	01 97       	sbiw	r24, 0x01	; 1
    4818:	9e 01       	movw	r18, r28
    481a:	2e 5f       	subi	r18, 0xFE	; 254
    481c:	3f 4f       	sbci	r19, 0xFF	; 255
    481e:	82 0f       	add	r24, r18
    4820:	93 1f       	adc	r25, r19
    4822:	fc 01       	movw	r30, r24
    4824:	80 81       	ld	r24, Z
    4826:	80 5d       	subi	r24, 0xD0	; 208
    4828:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
			i--;
    482c:	89 81       	ldd	r24, Y+1	; 0x01
    482e:	81 50       	subi	r24, 0x01	; 1
    4830:	89 83       	std	Y+1, r24	; 0x01
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    4832:	89 81       	ldd	r24, Y+1	; 0x01
    4834:	88 23       	and	r24, r24
    4836:	91 f6       	brne	.-92     	; 0x47dc <LCD_DisplayNumber+0x14e>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
			i--;
		}
	}
}
    4838:	69 96       	adiw	r28, 0x19	; 25
    483a:	0f b6       	in	r0, 0x3f	; 63
    483c:	f8 94       	cli
    483e:	de bf       	out	0x3e, r29	; 62
    4840:	0f be       	out	0x3f, r0	; 63
    4842:	cd bf       	out	0x3d, r28	; 61
    4844:	df 91       	pop	r29
    4846:	cf 91       	pop	r28
    4848:	1f 91       	pop	r17
    484a:	0f 91       	pop	r16
    484c:	ff 90       	pop	r15
    484e:	08 95       	ret

00004850 <LCD_DisplayNumberWithAddingToBuffor>:
#endif

#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumberWithAddingToBuffor(uint8_t v_numericSystem_u8,
		uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8, int *x, int y) {
    4850:	ef 92       	push	r14
    4852:	ff 92       	push	r15
    4854:	0f 93       	push	r16
    4856:	1f 93       	push	r17
    4858:	cf 93       	push	r28
    485a:	df 93       	push	r29
    485c:	cd b7       	in	r28, 0x3d	; 61
    485e:	de b7       	in	r29, 0x3e	; 62
    4860:	6d 97       	sbiw	r28, 0x1d	; 29
    4862:	0f b6       	in	r0, 0x3f	; 63
    4864:	f8 94       	cli
    4866:	de bf       	out	0x3e, r29	; 62
    4868:	0f be       	out	0x3f, r0	; 63
    486a:	cd bf       	out	0x3d, r28	; 61
    486c:	8c 87       	std	Y+12, r24	; 0x0c
    486e:	4d 87       	std	Y+13, r20	; 0x0d
    4870:	5e 87       	std	Y+14, r21	; 0x0e
    4872:	6f 87       	std	Y+15, r22	; 0x0f
    4874:	78 8b       	std	Y+16, r23	; 0x10
    4876:	29 8b       	std	Y+17, r18	; 0x11
    4878:	1b 8b       	std	Y+19, r17	; 0x13
    487a:	0a 8b       	std	Y+18, r16	; 0x12
    487c:	fd 8a       	std	Y+21, r15	; 0x15
    487e:	ec 8a       	std	Y+20, r14	; 0x14
	uint8_t i = 0, a[10];
    4880:	19 82       	std	Y+1, r1	; 0x01

	if (C_BINARY_U8 == v_numericSystem_u8) {
    4882:	8c 85       	ldd	r24, Y+12	; 0x0c
    4884:	82 30       	cpi	r24, 0x02	; 2
    4886:	09 f0       	breq	.+2      	; 0x488a <LCD_DisplayNumberWithAddingToBuffor+0x3a>
    4888:	51 c0       	rjmp	.+162    	; 0x492c <LCD_DisplayNumberWithAddingToBuffor+0xdc>
		while (v_numOfDigitsToDisplay_u8 != 0) {
    488a:	4b c0       	rjmp	.+150    	; 0x4922 <LCD_DisplayNumberWithAddingToBuffor+0xd2>
			/* Start Extracting the bits from the specified bit positions.
			 Get the Acsii values of the bits and display */
			i = util_GetBitStatus(v_number_u32,
    488c:	89 89       	ldd	r24, Y+17	; 0x11
    488e:	88 2f       	mov	r24, r24
    4890:	90 e0       	ldi	r25, 0x00	; 0
    4892:	9c 01       	movw	r18, r24
    4894:	21 50       	subi	r18, 0x01	; 1
    4896:	31 09       	sbc	r19, r1
    4898:	81 e0       	ldi	r24, 0x01	; 1
    489a:	90 e0       	ldi	r25, 0x00	; 0
    489c:	02 c0       	rjmp	.+4      	; 0x48a2 <LCD_DisplayNumberWithAddingToBuffor+0x52>
    489e:	88 0f       	add	r24, r24
    48a0:	99 1f       	adc	r25, r25
    48a2:	2a 95       	dec	r18
    48a4:	e2 f7       	brpl	.-8      	; 0x489e <LCD_DisplayNumberWithAddingToBuffor+0x4e>
    48a6:	9c 01       	movw	r18, r24
    48a8:	44 27       	eor	r20, r20
    48aa:	37 fd       	sbrc	r19, 7
    48ac:	40 95       	com	r20
    48ae:	54 2f       	mov	r21, r20
    48b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    48b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    48b4:	af 85       	ldd	r26, Y+15	; 0x0f
    48b6:	b8 89       	ldd	r27, Y+16	; 0x10
    48b8:	82 23       	and	r24, r18
    48ba:	93 23       	and	r25, r19
    48bc:	a4 23       	and	r26, r20
    48be:	b5 23       	and	r27, r21
    48c0:	21 e0       	ldi	r18, 0x01	; 1
    48c2:	00 97       	sbiw	r24, 0x00	; 0
    48c4:	a1 05       	cpc	r26, r1
    48c6:	b1 05       	cpc	r27, r1
    48c8:	09 f4       	brne	.+2      	; 0x48cc <LCD_DisplayNumberWithAddingToBuffor+0x7c>
    48ca:	20 e0       	ldi	r18, 0x00	; 0
    48cc:	29 83       	std	Y+1, r18	; 0x01
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
    48ce:	89 81       	ldd	r24, Y+1	; 0x01
    48d0:	80 5d       	subi	r24, 0xD0	; 208
    48d2:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = util_Dec2Ascii(i);
    48d6:	8a 89       	ldd	r24, Y+18	; 0x12
    48d8:	9b 89       	ldd	r25, Y+19	; 0x13
    48da:	fc 01       	movw	r30, r24
    48dc:	80 81       	ld	r24, Z
    48de:	91 81       	ldd	r25, Z+1	; 0x01
    48e0:	29 81       	ldd	r18, Y+1	; 0x01
    48e2:	40 e3       	ldi	r20, 0x30	; 48
    48e4:	42 0f       	add	r20, r18
    48e6:	2c 89       	ldd	r18, Y+20	; 0x14
    48e8:	3d 89       	ldd	r19, Y+21	; 0x15
    48ea:	22 95       	swap	r18
    48ec:	32 95       	swap	r19
    48ee:	30 7f       	andi	r19, 0xF0	; 240
    48f0:	32 27       	eor	r19, r18
    48f2:	20 7f       	andi	r18, 0xF0	; 240
    48f4:	32 27       	eor	r19, r18
    48f6:	82 0f       	add	r24, r18
    48f8:	93 1f       	adc	r25, r19
    48fa:	8c 57       	subi	r24, 0x7C	; 124
    48fc:	9d 4f       	sbci	r25, 0xFD	; 253
    48fe:	fc 01       	movw	r30, r24
    4900:	40 83       	st	Z, r20
			(*x)++;
    4902:	8a 89       	ldd	r24, Y+18	; 0x12
    4904:	9b 89       	ldd	r25, Y+19	; 0x13
    4906:	fc 01       	movw	r30, r24
    4908:	80 81       	ld	r24, Z
    490a:	91 81       	ldd	r25, Z+1	; 0x01
    490c:	9c 01       	movw	r18, r24
    490e:	2f 5f       	subi	r18, 0xFF	; 255
    4910:	3f 4f       	sbci	r19, 0xFF	; 255
    4912:	8a 89       	ldd	r24, Y+18	; 0x12
    4914:	9b 89       	ldd	r25, Y+19	; 0x13
    4916:	fc 01       	movw	r30, r24
    4918:	31 83       	std	Z+1, r19	; 0x01
    491a:	20 83       	st	Z, r18
			v_numOfDigitsToDisplay_u8--;
    491c:	89 89       	ldd	r24, Y+17	; 0x11
    491e:	81 50       	subi	r24, 0x01	; 1
    4920:	89 8b       	std	Y+17, r24	; 0x11
void LCD_DisplayNumberWithAddingToBuffor(uint8_t v_numericSystem_u8,
		uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8, int *x, int y) {
	uint8_t i = 0, a[10];

	if (C_BINARY_U8 == v_numericSystem_u8) {
		while (v_numOfDigitsToDisplay_u8 != 0) {
    4922:	89 89       	ldd	r24, Y+17	; 0x11
    4924:	88 23       	and	r24, r24
    4926:	09 f0       	breq	.+2      	; 0x492a <LCD_DisplayNumberWithAddingToBuffor+0xda>
    4928:	b1 cf       	rjmp	.-158    	; 0x488c <LCD_DisplayNumberWithAddingToBuffor+0x3c>
    492a:	fe c0       	rjmp	.+508    	; 0x4b28 <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
			LCD_DisplayChar(util_Dec2Ascii(i));
			LCD_BUFFOR[y][(*x)] = util_Dec2Ascii(i);
			(*x)++;
			v_numOfDigitsToDisplay_u8--;
		}
	} else if (v_number_u32 == 0) {
    492c:	8d 85       	ldd	r24, Y+13	; 0x0d
    492e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4930:	af 85       	ldd	r26, Y+15	; 0x0f
    4932:	b8 89       	ldd	r27, Y+16	; 0x10
    4934:	00 97       	sbiw	r24, 0x00	; 0
    4936:	a1 05       	cpc	r26, r1
    4938:	b1 05       	cpc	r27, r1
    493a:	29 f5       	brne	.+74     	; 0x4986 <LCD_DisplayNumberWithAddingToBuffor+0x136>
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
    493c:	80 e3       	ldi	r24, 0x30	; 48
    493e:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
		LCD_BUFFOR[y][(*x)] = '0';
    4942:	8a 89       	ldd	r24, Y+18	; 0x12
    4944:	9b 89       	ldd	r25, Y+19	; 0x13
    4946:	fc 01       	movw	r30, r24
    4948:	80 81       	ld	r24, Z
    494a:	91 81       	ldd	r25, Z+1	; 0x01
    494c:	2c 89       	ldd	r18, Y+20	; 0x14
    494e:	3d 89       	ldd	r19, Y+21	; 0x15
    4950:	22 95       	swap	r18
    4952:	32 95       	swap	r19
    4954:	30 7f       	andi	r19, 0xF0	; 240
    4956:	32 27       	eor	r19, r18
    4958:	20 7f       	andi	r18, 0xF0	; 240
    495a:	32 27       	eor	r19, r18
    495c:	82 0f       	add	r24, r18
    495e:	93 1f       	adc	r25, r19
    4960:	8c 57       	subi	r24, 0x7C	; 124
    4962:	9d 4f       	sbci	r25, 0xFD	; 253
    4964:	20 e3       	ldi	r18, 0x30	; 48
    4966:	fc 01       	movw	r30, r24
    4968:	20 83       	st	Z, r18
		(*x)++;
    496a:	8a 89       	ldd	r24, Y+18	; 0x12
    496c:	9b 89       	ldd	r25, Y+19	; 0x13
    496e:	fc 01       	movw	r30, r24
    4970:	80 81       	ld	r24, Z
    4972:	91 81       	ldd	r25, Z+1	; 0x01
    4974:	9c 01       	movw	r18, r24
    4976:	2f 5f       	subi	r18, 0xFF	; 255
    4978:	3f 4f       	sbci	r19, 0xFF	; 255
    497a:	8a 89       	ldd	r24, Y+18	; 0x12
    497c:	9b 89       	ldd	r25, Y+19	; 0x13
    497e:	fc 01       	movw	r30, r24
    4980:	31 83       	std	Z+1, r19	; 0x01
    4982:	20 83       	st	Z, r18
    4984:	d1 c0       	rjmp	.+418    	; 0x4b28 <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    4986:	19 82       	std	Y+1, r1	; 0x01
    4988:	4f c0       	rjmp	.+158    	; 0x4a28 <LCD_DisplayNumberWithAddingToBuffor+0x1d8>
			/* Continue extracting the digits from right side
			 till the Specified v_numOfDigitsToDisplay_u8 */
			if (v_number_u32 != 0) {
    498a:	8d 85       	ldd	r24, Y+13	; 0x0d
    498c:	9e 85       	ldd	r25, Y+14	; 0x0e
    498e:	af 85       	ldd	r26, Y+15	; 0x0f
    4990:	b8 89       	ldd	r27, Y+16	; 0x10
    4992:	00 97       	sbiw	r24, 0x00	; 0
    4994:	a1 05       	cpc	r26, r1
    4996:	b1 05       	cpc	r27, r1
    4998:	a1 f1       	breq	.+104    	; 0x4a02 <LCD_DisplayNumberWithAddingToBuffor+0x1b2>
				 First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.

				 example for Decimal number:
				 If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
				 The process continues till it becomes zero or max digits reached*/
				a[i] = util_GetMod32(v_number_u32, v_numericSystem_u8);
    499a:	89 81       	ldd	r24, Y+1	; 0x01
    499c:	08 2f       	mov	r16, r24
    499e:	10 e0       	ldi	r17, 0x00	; 0
    49a0:	fd 84       	ldd	r15, Y+13	; 0x0d
    49a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    49a4:	28 2f       	mov	r18, r24
    49a6:	30 e0       	ldi	r19, 0x00	; 0
    49a8:	40 e0       	ldi	r20, 0x00	; 0
    49aa:	50 e0       	ldi	r21, 0x00	; 0
    49ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    49ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    49b0:	af 85       	ldd	r26, Y+15	; 0x0f
    49b2:	b8 89       	ldd	r27, Y+16	; 0x10
    49b4:	bc 01       	movw	r22, r24
    49b6:	cd 01       	movw	r24, r26
    49b8:	0e 94 14 32 	call	0x6428	; 0x6428 <__udivmodsi4>
    49bc:	da 01       	movw	r26, r20
    49be:	c9 01       	movw	r24, r18
    49c0:	98 2f       	mov	r25, r24
    49c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    49c4:	98 9f       	mul	r25, r24
    49c6:	80 2d       	mov	r24, r0
    49c8:	11 24       	eor	r1, r1
    49ca:	2f 2d       	mov	r18, r15
    49cc:	28 1b       	sub	r18, r24
    49ce:	ce 01       	movw	r24, r28
    49d0:	02 96       	adiw	r24, 0x02	; 2
    49d2:	80 0f       	add	r24, r16
    49d4:	91 1f       	adc	r25, r17
    49d6:	fc 01       	movw	r30, r24
    49d8:	20 83       	st	Z, r18
				v_number_u32 = v_number_u32 / v_numericSystem_u8;
    49da:	8c 85       	ldd	r24, Y+12	; 0x0c
    49dc:	28 2f       	mov	r18, r24
    49de:	30 e0       	ldi	r19, 0x00	; 0
    49e0:	40 e0       	ldi	r20, 0x00	; 0
    49e2:	50 e0       	ldi	r21, 0x00	; 0
    49e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    49e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    49e8:	af 85       	ldd	r26, Y+15	; 0x0f
    49ea:	b8 89       	ldd	r27, Y+16	; 0x10
    49ec:	bc 01       	movw	r22, r24
    49ee:	cd 01       	movw	r24, r26
    49f0:	0e 94 14 32 	call	0x6428	; 0x6428 <__udivmodsi4>
    49f4:	da 01       	movw	r26, r20
    49f6:	c9 01       	movw	r24, r18
    49f8:	8d 87       	std	Y+13, r24	; 0x0d
    49fa:	9e 87       	std	Y+14, r25	; 0x0e
    49fc:	af 87       	std	Y+15, r26	; 0x0f
    49fe:	b8 8b       	std	Y+16, r27	; 0x10
    4a00:	10 c0       	rjmp	.+32     	; 0x4a22 <LCD_DisplayNumberWithAddingToBuffor+0x1d2>
			} else if ((v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8)
    4a02:	89 89       	ldd	r24, Y+17	; 0x11
    4a04:	8f 3f       	cpi	r24, 0xFF	; 255
    4a06:	a9 f0       	breq	.+42     	; 0x4a32 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
					|| (v_numOfDigitsToDisplay_u8 > C_MaxDigitsToDisplay_U8)) {
    4a08:	89 89       	ldd	r24, Y+17	; 0x11
    4a0a:	8b 30       	cpi	r24, 0x0B	; 11
    4a0c:	90 f4       	brcc	.+36     	; 0x4a32 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
				break;
			} else {
				/* In case user expects more digits to be displayed than the actual digits in number,
				 then update the remaining digits with zero.
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
    4a0e:	89 81       	ldd	r24, Y+1	; 0x01
    4a10:	88 2f       	mov	r24, r24
    4a12:	90 e0       	ldi	r25, 0x00	; 0
    4a14:	9e 01       	movw	r18, r28
    4a16:	2e 5f       	subi	r18, 0xFE	; 254
    4a18:	3f 4f       	sbci	r19, 0xFF	; 255
    4a1a:	82 0f       	add	r24, r18
    4a1c:	93 1f       	adc	r25, r19
    4a1e:	fc 01       	movw	r30, r24
    4a20:	10 82       	st	Z, r1
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
		LCD_BUFFOR[y][(*x)] = '0';
		(*x)++;
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    4a22:	89 81       	ldd	r24, Y+1	; 0x01
    4a24:	8f 5f       	subi	r24, 0xFF	; 255
    4a26:	89 83       	std	Y+1, r24	; 0x01
    4a28:	99 81       	ldd	r25, Y+1	; 0x01
    4a2a:	89 89       	ldd	r24, Y+17	; 0x11
    4a2c:	98 17       	cp	r25, r24
    4a2e:	08 f4       	brcc	.+2      	; 0x4a32 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
    4a30:	ac cf       	rjmp	.-168    	; 0x498a <LCD_DisplayNumberWithAddingToBuffor+0x13a>
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    4a32:	76 c0       	rjmp	.+236    	; 0x4b20 <LCD_DisplayNumberWithAddingToBuffor+0x2d0>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
    4a34:	89 81       	ldd	r24, Y+1	; 0x01
    4a36:	88 2f       	mov	r24, r24
    4a38:	90 e0       	ldi	r25, 0x00	; 0
    4a3a:	01 97       	sbiw	r24, 0x01	; 1
    4a3c:	9e 01       	movw	r18, r28
    4a3e:	2e 5f       	subi	r18, 0xFE	; 254
    4a40:	3f 4f       	sbci	r19, 0xFF	; 255
    4a42:	82 0f       	add	r24, r18
    4a44:	93 1f       	adc	r25, r19
    4a46:	fc 01       	movw	r30, r24
    4a48:	80 81       	ld	r24, Z
    4a4a:	8a 30       	cpi	r24, 0x0A	; 10
    4a4c:	68 f0       	brcs	.+26     	; 0x4a68 <LCD_DisplayNumberWithAddingToBuffor+0x218>
    4a4e:	89 81       	ldd	r24, Y+1	; 0x01
    4a50:	88 2f       	mov	r24, r24
    4a52:	90 e0       	ldi	r25, 0x00	; 0
    4a54:	01 97       	sbiw	r24, 0x01	; 1
    4a56:	9e 01       	movw	r18, r28
    4a58:	2e 5f       	subi	r18, 0xFE	; 254
    4a5a:	3f 4f       	sbci	r19, 0xFF	; 255
    4a5c:	82 0f       	add	r24, r18
    4a5e:	93 1f       	adc	r25, r19
    4a60:	fc 01       	movw	r30, r24
    4a62:	80 81       	ld	r24, Z
    4a64:	89 5c       	subi	r24, 0xC9	; 201
    4a66:	0c c0       	rjmp	.+24     	; 0x4a80 <LCD_DisplayNumberWithAddingToBuffor+0x230>
    4a68:	89 81       	ldd	r24, Y+1	; 0x01
    4a6a:	88 2f       	mov	r24, r24
    4a6c:	90 e0       	ldi	r25, 0x00	; 0
    4a6e:	01 97       	sbiw	r24, 0x01	; 1
    4a70:	9e 01       	movw	r18, r28
    4a72:	2e 5f       	subi	r18, 0xFE	; 254
    4a74:	3f 4f       	sbci	r19, 0xFF	; 255
    4a76:	82 0f       	add	r24, r18
    4a78:	93 1f       	adc	r25, r19
    4a7a:	fc 01       	movw	r30, r24
    4a7c:	80 81       	ld	r24, Z
    4a7e:	80 5d       	subi	r24, 0xD0	; 208
    4a80:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = util_Hex2Ascii(a[i - 1]);
    4a84:	8a 89       	ldd	r24, Y+18	; 0x12
    4a86:	9b 89       	ldd	r25, Y+19	; 0x13
    4a88:	fc 01       	movw	r30, r24
    4a8a:	80 81       	ld	r24, Z
    4a8c:	91 81       	ldd	r25, Z+1	; 0x01
    4a8e:	29 81       	ldd	r18, Y+1	; 0x01
    4a90:	22 2f       	mov	r18, r18
    4a92:	30 e0       	ldi	r19, 0x00	; 0
    4a94:	21 50       	subi	r18, 0x01	; 1
    4a96:	31 09       	sbc	r19, r1
    4a98:	ae 01       	movw	r20, r28
    4a9a:	4e 5f       	subi	r20, 0xFE	; 254
    4a9c:	5f 4f       	sbci	r21, 0xFF	; 255
    4a9e:	24 0f       	add	r18, r20
    4aa0:	35 1f       	adc	r19, r21
    4aa2:	f9 01       	movw	r30, r18
    4aa4:	20 81       	ld	r18, Z
    4aa6:	2a 30       	cpi	r18, 0x0A	; 10
    4aa8:	78 f0       	brcs	.+30     	; 0x4ac8 <LCD_DisplayNumberWithAddingToBuffor+0x278>
    4aaa:	29 81       	ldd	r18, Y+1	; 0x01
    4aac:	22 2f       	mov	r18, r18
    4aae:	30 e0       	ldi	r19, 0x00	; 0
    4ab0:	21 50       	subi	r18, 0x01	; 1
    4ab2:	31 09       	sbc	r19, r1
    4ab4:	ae 01       	movw	r20, r28
    4ab6:	4e 5f       	subi	r20, 0xFE	; 254
    4ab8:	5f 4f       	sbci	r21, 0xFF	; 255
    4aba:	24 0f       	add	r18, r20
    4abc:	35 1f       	adc	r19, r21
    4abe:	f9 01       	movw	r30, r18
    4ac0:	20 81       	ld	r18, Z
    4ac2:	47 e3       	ldi	r20, 0x37	; 55
    4ac4:	42 0f       	add	r20, r18
    4ac6:	0e c0       	rjmp	.+28     	; 0x4ae4 <LCD_DisplayNumberWithAddingToBuffor+0x294>
    4ac8:	29 81       	ldd	r18, Y+1	; 0x01
    4aca:	22 2f       	mov	r18, r18
    4acc:	30 e0       	ldi	r19, 0x00	; 0
    4ace:	21 50       	subi	r18, 0x01	; 1
    4ad0:	31 09       	sbc	r19, r1
    4ad2:	ae 01       	movw	r20, r28
    4ad4:	4e 5f       	subi	r20, 0xFE	; 254
    4ad6:	5f 4f       	sbci	r21, 0xFF	; 255
    4ad8:	24 0f       	add	r18, r20
    4ada:	35 1f       	adc	r19, r21
    4adc:	f9 01       	movw	r30, r18
    4ade:	20 81       	ld	r18, Z
    4ae0:	40 e3       	ldi	r20, 0x30	; 48
    4ae2:	42 0f       	add	r20, r18
    4ae4:	2c 89       	ldd	r18, Y+20	; 0x14
    4ae6:	3d 89       	ldd	r19, Y+21	; 0x15
    4ae8:	22 95       	swap	r18
    4aea:	32 95       	swap	r19
    4aec:	30 7f       	andi	r19, 0xF0	; 240
    4aee:	32 27       	eor	r19, r18
    4af0:	20 7f       	andi	r18, 0xF0	; 240
    4af2:	32 27       	eor	r19, r18
    4af4:	82 0f       	add	r24, r18
    4af6:	93 1f       	adc	r25, r19
    4af8:	8c 57       	subi	r24, 0x7C	; 124
    4afa:	9d 4f       	sbci	r25, 0xFD	; 253
    4afc:	fc 01       	movw	r30, r24
    4afe:	40 83       	st	Z, r20
			(*x)++;
    4b00:	8a 89       	ldd	r24, Y+18	; 0x12
    4b02:	9b 89       	ldd	r25, Y+19	; 0x13
    4b04:	fc 01       	movw	r30, r24
    4b06:	80 81       	ld	r24, Z
    4b08:	91 81       	ldd	r25, Z+1	; 0x01
    4b0a:	9c 01       	movw	r18, r24
    4b0c:	2f 5f       	subi	r18, 0xFF	; 255
    4b0e:	3f 4f       	sbci	r19, 0xFF	; 255
    4b10:	8a 89       	ldd	r24, Y+18	; 0x12
    4b12:	9b 89       	ldd	r25, Y+19	; 0x13
    4b14:	fc 01       	movw	r30, r24
    4b16:	31 83       	std	Z+1, r19	; 0x01
    4b18:	20 83       	st	Z, r18
			i--;
    4b1a:	89 81       	ldd	r24, Y+1	; 0x01
    4b1c:	81 50       	subi	r24, 0x01	; 1
    4b1e:	89 83       	std	Y+1, r24	; 0x01
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    4b20:	89 81       	ldd	r24, Y+1	; 0x01
    4b22:	88 23       	and	r24, r24
    4b24:	09 f0       	breq	.+2      	; 0x4b28 <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
    4b26:	86 cf       	rjmp	.-244    	; 0x4a34 <LCD_DisplayNumberWithAddingToBuffor+0x1e4>
			LCD_BUFFOR[y][(*x)] = util_Hex2Ascii(a[i - 1]);
			(*x)++;
			i--;
		}
	}
}
    4b28:	6d 96       	adiw	r28, 0x1d	; 29
    4b2a:	0f b6       	in	r0, 0x3f	; 63
    4b2c:	f8 94       	cli
    4b2e:	de bf       	out	0x3e, r29	; 62
    4b30:	0f be       	out	0x3f, r0	; 63
    4b32:	cd bf       	out	0x3d, r28	; 61
    4b34:	df 91       	pop	r29
    4b36:	cf 91       	pop	r28
    4b38:	1f 91       	pop	r17
    4b3a:	0f 91       	pop	r16
    4b3c:	ff 90       	pop	r15
    4b3e:	ef 90       	pop	r14
    4b40:	08 95       	ret

00004b42 <LCD_XYPrintf>:
 #####: In case of printing the 8-bit variables, it is recommended to type cast and promote them to uint16_t.
 uint8_t v_Num_u8;
 LCD_Printf("num1:%u",(uint16_t)v_Num_u8);
 **************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_XYPrintf(int x, int y, const char *argList, ...) {
    4b42:	ef 92       	push	r14
    4b44:	ff 92       	push	r15
    4b46:	0f 93       	push	r16
    4b48:	1f 93       	push	r17
    4b4a:	cf 93       	push	r28
    4b4c:	df 93       	push	r29
    4b4e:	cd b7       	in	r28, 0x3d	; 61
    4b50:	de b7       	in	r29, 0x3e	; 62
    4b52:	66 97       	sbiw	r28, 0x16	; 22
    4b54:	0f b6       	in	r0, 0x3f	; 63
    4b56:	f8 94       	cli
    4b58:	de bf       	out	0x3e, r29	; 62
    4b5a:	0f be       	out	0x3f, r0	; 63
    4b5c:	cd bf       	out	0x3d, r28	; 61
	LCD_SetCursor(y, x);
    4b5e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    4b60:	89 a1       	ldd	r24, Y+33	; 0x21
    4b62:	69 2f       	mov	r22, r25
    4b64:	0e 94 fd 1f 	call	0x3ffa	; 0x3ffa <LCD_SetCursor>
	int tmpX = x;
    4b68:	8f 8d       	ldd	r24, Y+31	; 0x1f
    4b6a:	98 a1       	ldd	r25, Y+32	; 0x20
    4b6c:	9c 8b       	std	Y+20, r25	; 0x14
    4b6e:	8b 8b       	std	Y+19, r24	; 0x13
	uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)  
    double v_floatNum_f32;
#endif

	va_start(argp, argList);
    4b70:	ce 01       	movw	r24, r28
    4b72:	85 96       	adiw	r24, 0x25	; 37
    4b74:	9e 8b       	std	Y+22, r25	; 0x16
    4b76:	8d 8b       	std	Y+21, r24	; 0x15

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    4b78:	8b a1       	ldd	r24, Y+35	; 0x23
    4b7a:	9c a1       	ldd	r25, Y+36	; 0x24
    4b7c:	9a 83       	std	Y+2, r25	; 0x02
    4b7e:	89 83       	std	Y+1, r24	; 0x01
    4b80:	61 c3       	rjmp	.+1730   	; 0x5244 <LCD_XYPrintf+0x702>
		ch = *ptr;
    4b82:	89 81       	ldd	r24, Y+1	; 0x01
    4b84:	9a 81       	ldd	r25, Y+2	; 0x02
    4b86:	fc 01       	movw	r30, r24
    4b88:	80 81       	ld	r24, Z
    4b8a:	89 87       	std	Y+9, r24	; 0x09
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
    4b8c:	89 85       	ldd	r24, Y+9	; 0x09
    4b8e:	85 32       	cpi	r24, 0x25	; 37
    4b90:	09 f0       	breq	.+2      	; 0x4b94 <LCD_XYPrintf+0x52>
    4b92:	3a c3       	rjmp	.+1652   	; 0x5208 <LCD_XYPrintf+0x6c6>
		{
			ptr++;
    4b94:	89 81       	ldd	r24, Y+1	; 0x01
    4b96:	9a 81       	ldd	r25, Y+2	; 0x02
    4b98:	01 96       	adiw	r24, 0x01	; 1
    4b9a:	9a 83       	std	Y+2, r25	; 0x02
    4b9c:	89 83       	std	Y+1, r24	; 0x01
			ch = *ptr;
    4b9e:	89 81       	ldd	r24, Y+1	; 0x01
    4ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ba2:	fc 01       	movw	r30, r24
    4ba4:	80 81       	ld	r24, Z
    4ba6:	89 87       	std	Y+9, r24	; 0x09
			if ((ch >= 0x30) && (ch <= 0x39)) {
    4ba8:	89 85       	ldd	r24, Y+9	; 0x09
    4baa:	80 33       	cpi	r24, 0x30	; 48
    4bac:	00 f1       	brcs	.+64     	; 0x4bee <LCD_XYPrintf+0xac>
    4bae:	89 85       	ldd	r24, Y+9	; 0x09
    4bb0:	8a 33       	cpi	r24, 0x3A	; 58
    4bb2:	e8 f4       	brcc	.+58     	; 0x4bee <LCD_XYPrintf+0xac>
				v_numOfDigitsToDisp_u8 = 0;
    4bb4:	1a 86       	std	Y+10, r1	; 0x0a
				while ((ch >= 0x30) && (ch <= 0x39)) {
    4bb6:	14 c0       	rjmp	.+40     	; 0x4be0 <LCD_XYPrintf+0x9e>
					v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10)
    4bb8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4bba:	88 0f       	add	r24, r24
    4bbc:	98 2f       	mov	r25, r24
    4bbe:	99 0f       	add	r25, r25
    4bc0:	99 0f       	add	r25, r25
    4bc2:	98 0f       	add	r25, r24
    4bc4:	89 85       	ldd	r24, Y+9	; 0x09
    4bc6:	89 0f       	add	r24, r25
    4bc8:	80 53       	subi	r24, 0x30	; 48
    4bca:	8a 87       	std	Y+10, r24	; 0x0a
							+ (ch - 0x30);
					ptr++;
    4bcc:	89 81       	ldd	r24, Y+1	; 0x01
    4bce:	9a 81       	ldd	r25, Y+2	; 0x02
    4bd0:	01 96       	adiw	r24, 0x01	; 1
    4bd2:	9a 83       	std	Y+2, r25	; 0x02
    4bd4:	89 83       	std	Y+1, r24	; 0x01
					ch = *ptr;
    4bd6:	89 81       	ldd	r24, Y+1	; 0x01
    4bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bda:	fc 01       	movw	r30, r24
    4bdc:	80 81       	ld	r24, Z
    4bde:	89 87       	std	Y+9, r24	; 0x09
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
				v_numOfDigitsToDisp_u8 = 0;
				while ((ch >= 0x30) && (ch <= 0x39)) {
    4be0:	89 85       	ldd	r24, Y+9	; 0x09
    4be2:	80 33       	cpi	r24, 0x30	; 48
    4be4:	18 f0       	brcs	.+6      	; 0x4bec <LCD_XYPrintf+0xaa>
    4be6:	89 85       	ldd	r24, Y+9	; 0x09
    4be8:	8a 33       	cpi	r24, 0x3A	; 58
    4bea:	30 f3       	brcs	.-52     	; 0x4bb8 <LCD_XYPrintf+0x76>
		ch = *ptr;
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
    4bec:	02 c0       	rjmp	.+4      	; 0x4bf2 <LCD_XYPrintf+0xb0>
							+ (ch - 0x30);
					ptr++;
					ch = *ptr;
				}
			} else {
				v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    4bee:	8f ef       	ldi	r24, 0xFF	; 255
    4bf0:	8a 87       	std	Y+10, r24	; 0x0a
			}

			switch (ch) /* Decode the type of the argument */
    4bf2:	89 85       	ldd	r24, Y+9	; 0x09
    4bf4:	88 2f       	mov	r24, r24
    4bf6:	90 e0       	ldi	r25, 0x00	; 0
    4bf8:	aa 27       	eor	r26, r26
    4bfa:	97 fd       	sbrc	r25, 7
    4bfc:	a0 95       	com	r26
    4bfe:	ba 2f       	mov	r27, r26
    4c00:	45 e2       	ldi	r20, 0x25	; 37
    4c02:	50 e0       	ldi	r21, 0x00	; 0
    4c04:	28 e5       	ldi	r18, 0x58	; 88
    4c06:	30 e0       	ldi	r19, 0x00	; 0
    4c08:	84 1b       	sub	r24, r20
    4c0a:	95 0b       	sbc	r25, r21
    4c0c:	28 17       	cp	r18, r24
    4c0e:	39 07       	cpc	r19, r25
    4c10:	08 f4       	brcc	.+2      	; 0x4c14 <LCD_XYPrintf+0xd2>
    4c12:	13 c3       	rjmp	.+1574   	; 0x523a <LCD_XYPrintf+0x6f8>
    4c14:	8d 57       	subi	r24, 0x7D	; 125
    4c16:	9f 4f       	sbci	r25, 0xFF	; 255
    4c18:	fc 01       	movw	r30, r24
    4c1a:	0c 94 36 32 	jmp	0x646c	; 0x646c <__tablejump2__>
			{
			case '>':
				LCD_PrintSymbol(1);
    4c1e:	81 e0       	ldi	r24, 0x01	; 1
    4c20:	90 e0       	ldi	r25, 0x00	; 0
    4c22:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '>';
    4c26:	8b 89       	ldd	r24, Y+19	; 0x13
    4c28:	9c 89       	ldd	r25, Y+20	; 0x14
    4c2a:	29 a1       	ldd	r18, Y+33	; 0x21
    4c2c:	3a a1       	ldd	r19, Y+34	; 0x22
    4c2e:	22 95       	swap	r18
    4c30:	32 95       	swap	r19
    4c32:	30 7f       	andi	r19, 0xF0	; 240
    4c34:	32 27       	eor	r19, r18
    4c36:	20 7f       	andi	r18, 0xF0	; 240
    4c38:	32 27       	eor	r19, r18
    4c3a:	82 0f       	add	r24, r18
    4c3c:	93 1f       	adc	r25, r19
    4c3e:	8c 57       	subi	r24, 0x7C	; 124
    4c40:	9d 4f       	sbci	r25, 0xFD	; 253
    4c42:	2e e3       	ldi	r18, 0x3E	; 62
    4c44:	fc 01       	movw	r30, r24
    4c46:	20 83       	st	Z, r18
				tmpX++;
    4c48:	8b 89       	ldd	r24, Y+19	; 0x13
    4c4a:	9c 89       	ldd	r25, Y+20	; 0x14
    4c4c:	01 96       	adiw	r24, 0x01	; 1
    4c4e:	9c 8b       	std	Y+20, r25	; 0x14
    4c50:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4c52:	d9 c2       	rjmp	.+1458   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case '<':
				LCD_PrintSymbol(2);
    4c54:	82 e0       	ldi	r24, 0x02	; 2
    4c56:	90 e0       	ldi	r25, 0x00	; 0
    4c58:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '<';
    4c5c:	8b 89       	ldd	r24, Y+19	; 0x13
    4c5e:	9c 89       	ldd	r25, Y+20	; 0x14
    4c60:	29 a1       	ldd	r18, Y+33	; 0x21
    4c62:	3a a1       	ldd	r19, Y+34	; 0x22
    4c64:	22 95       	swap	r18
    4c66:	32 95       	swap	r19
    4c68:	30 7f       	andi	r19, 0xF0	; 240
    4c6a:	32 27       	eor	r19, r18
    4c6c:	20 7f       	andi	r18, 0xF0	; 240
    4c6e:	32 27       	eor	r19, r18
    4c70:	82 0f       	add	r24, r18
    4c72:	93 1f       	adc	r25, r19
    4c74:	8c 57       	subi	r24, 0x7C	; 124
    4c76:	9d 4f       	sbci	r25, 0xFD	; 253
    4c78:	2c e3       	ldi	r18, 0x3C	; 60
    4c7a:	fc 01       	movw	r30, r24
    4c7c:	20 83       	st	Z, r18
				tmpX++;
    4c7e:	8b 89       	ldd	r24, Y+19	; 0x13
    4c80:	9c 89       	ldd	r25, Y+20	; 0x14
    4c82:	01 96       	adiw	r24, 0x01	; 1
    4c84:	9c 8b       	std	Y+20, r25	; 0x14
    4c86:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4c88:	be c2       	rjmp	.+1404   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case '|':
				LCD_PrintSymbol(3);
    4c8a:	83 e0       	ldi	r24, 0x03	; 3
    4c8c:	90 e0       	ldi	r25, 0x00	; 0
    4c8e:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '|';
    4c92:	8b 89       	ldd	r24, Y+19	; 0x13
    4c94:	9c 89       	ldd	r25, Y+20	; 0x14
    4c96:	29 a1       	ldd	r18, Y+33	; 0x21
    4c98:	3a a1       	ldd	r19, Y+34	; 0x22
    4c9a:	22 95       	swap	r18
    4c9c:	32 95       	swap	r19
    4c9e:	30 7f       	andi	r19, 0xF0	; 240
    4ca0:	32 27       	eor	r19, r18
    4ca2:	20 7f       	andi	r18, 0xF0	; 240
    4ca4:	32 27       	eor	r19, r18
    4ca6:	82 0f       	add	r24, r18
    4ca8:	93 1f       	adc	r25, r19
    4caa:	8c 57       	subi	r24, 0x7C	; 124
    4cac:	9d 4f       	sbci	r25, 0xFD	; 253
    4cae:	2c e7       	ldi	r18, 0x7C	; 124
    4cb0:	fc 01       	movw	r30, r24
    4cb2:	20 83       	st	Z, r18
				tmpX++;
    4cb4:	8b 89       	ldd	r24, Y+19	; 0x13
    4cb6:	9c 89       	ldd	r25, Y+20	; 0x14
    4cb8:	01 96       	adiw	r24, 0x01	; 1
    4cba:	9c 8b       	std	Y+20, r25	; 0x14
    4cbc:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4cbe:	a3 c2       	rjmp	.+1350   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case '{':
				LCD_PrintSymbol(4);
    4cc0:	84 e0       	ldi	r24, 0x04	; 4
    4cc2:	90 e0       	ldi	r25, 0x00	; 0
    4cc4:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '{';
    4cc8:	8b 89       	ldd	r24, Y+19	; 0x13
    4cca:	9c 89       	ldd	r25, Y+20	; 0x14
    4ccc:	29 a1       	ldd	r18, Y+33	; 0x21
    4cce:	3a a1       	ldd	r19, Y+34	; 0x22
    4cd0:	22 95       	swap	r18
    4cd2:	32 95       	swap	r19
    4cd4:	30 7f       	andi	r19, 0xF0	; 240
    4cd6:	32 27       	eor	r19, r18
    4cd8:	20 7f       	andi	r18, 0xF0	; 240
    4cda:	32 27       	eor	r19, r18
    4cdc:	82 0f       	add	r24, r18
    4cde:	93 1f       	adc	r25, r19
    4ce0:	8c 57       	subi	r24, 0x7C	; 124
    4ce2:	9d 4f       	sbci	r25, 0xFD	; 253
    4ce4:	2b e7       	ldi	r18, 0x7B	; 123
    4ce6:	fc 01       	movw	r30, r24
    4ce8:	20 83       	st	Z, r18
				tmpX++;
    4cea:	8b 89       	ldd	r24, Y+19	; 0x13
    4cec:	9c 89       	ldd	r25, Y+20	; 0x14
    4cee:	01 96       	adiw	r24, 0x01	; 1
    4cf0:	9c 8b       	std	Y+20, r25	; 0x14
    4cf2:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4cf4:	88 c2       	rjmp	.+1296   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case '}':
				LCD_PrintSymbol(5);
    4cf6:	85 e0       	ldi	r24, 0x05	; 5
    4cf8:	90 e0       	ldi	r25, 0x00	; 0
    4cfa:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '}';
    4cfe:	8b 89       	ldd	r24, Y+19	; 0x13
    4d00:	9c 89       	ldd	r25, Y+20	; 0x14
    4d02:	29 a1       	ldd	r18, Y+33	; 0x21
    4d04:	3a a1       	ldd	r19, Y+34	; 0x22
    4d06:	22 95       	swap	r18
    4d08:	32 95       	swap	r19
    4d0a:	30 7f       	andi	r19, 0xF0	; 240
    4d0c:	32 27       	eor	r19, r18
    4d0e:	20 7f       	andi	r18, 0xF0	; 240
    4d10:	32 27       	eor	r19, r18
    4d12:	82 0f       	add	r24, r18
    4d14:	93 1f       	adc	r25, r19
    4d16:	8c 57       	subi	r24, 0x7C	; 124
    4d18:	9d 4f       	sbci	r25, 0xFD	; 253
    4d1a:	2d e7       	ldi	r18, 0x7D	; 125
    4d1c:	fc 01       	movw	r30, r24
    4d1e:	20 83       	st	Z, r18
				tmpX++;
    4d20:	8b 89       	ldd	r24, Y+19	; 0x13
    4d22:	9c 89       	ldd	r25, Y+20	; 0x14
    4d24:	01 96       	adiw	r24, 0x01	; 1
    4d26:	9c 8b       	std	Y+20, r25	; 0x14
    4d28:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4d2a:	6d c2       	rjmp	.+1242   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case ',':
				LCD_PrintSymbol(6);
    4d2c:	86 e0       	ldi	r24, 0x06	; 6
    4d2e:	90 e0       	ldi	r25, 0x00	; 0
    4d30:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ',';
    4d34:	8b 89       	ldd	r24, Y+19	; 0x13
    4d36:	9c 89       	ldd	r25, Y+20	; 0x14
    4d38:	29 a1       	ldd	r18, Y+33	; 0x21
    4d3a:	3a a1       	ldd	r19, Y+34	; 0x22
    4d3c:	22 95       	swap	r18
    4d3e:	32 95       	swap	r19
    4d40:	30 7f       	andi	r19, 0xF0	; 240
    4d42:	32 27       	eor	r19, r18
    4d44:	20 7f       	andi	r18, 0xF0	; 240
    4d46:	32 27       	eor	r19, r18
    4d48:	82 0f       	add	r24, r18
    4d4a:	93 1f       	adc	r25, r19
    4d4c:	8c 57       	subi	r24, 0x7C	; 124
    4d4e:	9d 4f       	sbci	r25, 0xFD	; 253
    4d50:	2c e2       	ldi	r18, 0x2C	; 44
    4d52:	fc 01       	movw	r30, r24
    4d54:	20 83       	st	Z, r18
				tmpX++;
    4d56:	8b 89       	ldd	r24, Y+19	; 0x13
    4d58:	9c 89       	ldd	r25, Y+20	; 0x14
    4d5a:	01 96       	adiw	r24, 0x01	; 1
    4d5c:	9c 8b       	std	Y+20, r25	; 0x14
    4d5e:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4d60:	52 c2       	rjmp	.+1188   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case ':':
				LCD_PrintSymbol(7);
    4d62:	87 e0       	ldi	r24, 0x07	; 7
    4d64:	90 e0       	ldi	r25, 0x00	; 0
    4d66:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ':';
    4d6a:	8b 89       	ldd	r24, Y+19	; 0x13
    4d6c:	9c 89       	ldd	r25, Y+20	; 0x14
    4d6e:	29 a1       	ldd	r18, Y+33	; 0x21
    4d70:	3a a1       	ldd	r19, Y+34	; 0x22
    4d72:	22 95       	swap	r18
    4d74:	32 95       	swap	r19
    4d76:	30 7f       	andi	r19, 0xF0	; 240
    4d78:	32 27       	eor	r19, r18
    4d7a:	20 7f       	andi	r18, 0xF0	; 240
    4d7c:	32 27       	eor	r19, r18
    4d7e:	82 0f       	add	r24, r18
    4d80:	93 1f       	adc	r25, r19
    4d82:	8c 57       	subi	r24, 0x7C	; 124
    4d84:	9d 4f       	sbci	r25, 0xFD	; 253
    4d86:	2a e3       	ldi	r18, 0x3A	; 58
    4d88:	fc 01       	movw	r30, r24
    4d8a:	20 83       	st	Z, r18
				tmpX++;
    4d8c:	8b 89       	ldd	r24, Y+19	; 0x13
    4d8e:	9c 89       	ldd	r25, Y+20	; 0x14
    4d90:	01 96       	adiw	r24, 0x01	; 1
    4d92:	9c 8b       	std	Y+20, r25	; 0x14
    4d94:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4d96:	37 c2       	rjmp	.+1134   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case ';':
				LCD_PrintSymbol(8);
    4d98:	88 e0       	ldi	r24, 0x08	; 8
    4d9a:	90 e0       	ldi	r25, 0x00	; 0
    4d9c:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ';';
    4da0:	8b 89       	ldd	r24, Y+19	; 0x13
    4da2:	9c 89       	ldd	r25, Y+20	; 0x14
    4da4:	29 a1       	ldd	r18, Y+33	; 0x21
    4da6:	3a a1       	ldd	r19, Y+34	; 0x22
    4da8:	22 95       	swap	r18
    4daa:	32 95       	swap	r19
    4dac:	30 7f       	andi	r19, 0xF0	; 240
    4dae:	32 27       	eor	r19, r18
    4db0:	20 7f       	andi	r18, 0xF0	; 240
    4db2:	32 27       	eor	r19, r18
    4db4:	82 0f       	add	r24, r18
    4db6:	93 1f       	adc	r25, r19
    4db8:	8c 57       	subi	r24, 0x7C	; 124
    4dba:	9d 4f       	sbci	r25, 0xFD	; 253
    4dbc:	2b e3       	ldi	r18, 0x3B	; 59
    4dbe:	fc 01       	movw	r30, r24
    4dc0:	20 83       	st	Z, r18
				tmpX++;
    4dc2:	8b 89       	ldd	r24, Y+19	; 0x13
    4dc4:	9c 89       	ldd	r25, Y+20	; 0x14
    4dc6:	01 96       	adiw	r24, 0x01	; 1
    4dc8:	9c 8b       	std	Y+20, r25	; 0x14
    4dca:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4dcc:	1c c2       	rjmp	.+1080   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case '?':
				LCD_PrintBlock();
    4dce:	0e 94 8f 2d 	call	0x5b1e	; 0x5b1e <LCD_PrintBlock>
				LCD_BUFFOR[y][tmpX] = '?';
    4dd2:	8b 89       	ldd	r24, Y+19	; 0x13
    4dd4:	9c 89       	ldd	r25, Y+20	; 0x14
    4dd6:	29 a1       	ldd	r18, Y+33	; 0x21
    4dd8:	3a a1       	ldd	r19, Y+34	; 0x22
    4dda:	22 95       	swap	r18
    4ddc:	32 95       	swap	r19
    4dde:	30 7f       	andi	r19, 0xF0	; 240
    4de0:	32 27       	eor	r19, r18
    4de2:	20 7f       	andi	r18, 0xF0	; 240
    4de4:	32 27       	eor	r19, r18
    4de6:	82 0f       	add	r24, r18
    4de8:	93 1f       	adc	r25, r19
    4dea:	8c 57       	subi	r24, 0x7C	; 124
    4dec:	9d 4f       	sbci	r25, 0xFD	; 253
    4dee:	2f e3       	ldi	r18, 0x3F	; 63
    4df0:	fc 01       	movw	r30, r24
    4df2:	20 83       	st	Z, r18
				tmpX++;
    4df4:	8b 89       	ldd	r24, Y+19	; 0x13
    4df6:	9c 89       	ldd	r25, Y+20	; 0x14
    4df8:	01 96       	adiw	r24, 0x01	; 1
    4dfa:	9c 8b       	std	Y+20, r25	; 0x14
    4dfc:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4dfe:	03 c2       	rjmp	.+1030   	; 0x5206 <LCD_XYPrintf+0x6c4>
			case '[':
				LCD_PrintLArrow();
    4e00:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <LCD_PrintLArrow>
				LCD_BUFFOR[y][tmpX] = '[';
    4e04:	8b 89       	ldd	r24, Y+19	; 0x13
    4e06:	9c 89       	ldd	r25, Y+20	; 0x14
    4e08:	29 a1       	ldd	r18, Y+33	; 0x21
    4e0a:	3a a1       	ldd	r19, Y+34	; 0x22
    4e0c:	22 95       	swap	r18
    4e0e:	32 95       	swap	r19
    4e10:	30 7f       	andi	r19, 0xF0	; 240
    4e12:	32 27       	eor	r19, r18
    4e14:	20 7f       	andi	r18, 0xF0	; 240
    4e16:	32 27       	eor	r19, r18
    4e18:	82 0f       	add	r24, r18
    4e1a:	93 1f       	adc	r25, r19
    4e1c:	8c 57       	subi	r24, 0x7C	; 124
    4e1e:	9d 4f       	sbci	r25, 0xFD	; 253
    4e20:	2b e5       	ldi	r18, 0x5B	; 91
    4e22:	fc 01       	movw	r30, r24
    4e24:	20 83       	st	Z, r18
				tmpX++;
    4e26:	8b 89       	ldd	r24, Y+19	; 0x13
    4e28:	9c 89       	ldd	r25, Y+20	; 0x14
    4e2a:	01 96       	adiw	r24, 0x01	; 1
    4e2c:	9c 8b       	std	Y+20, r25	; 0x14
    4e2e:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4e30:	ea c1       	rjmp	.+980    	; 0x5206 <LCD_XYPrintf+0x6c4>
			case ']':
				LCD_PrintRArrow();
    4e32:	0e 94 a3 2d 	call	0x5b46	; 0x5b46 <LCD_PrintRArrow>
				LCD_BUFFOR[y][tmpX] = ']';
    4e36:	8b 89       	ldd	r24, Y+19	; 0x13
    4e38:	9c 89       	ldd	r25, Y+20	; 0x14
    4e3a:	29 a1       	ldd	r18, Y+33	; 0x21
    4e3c:	3a a1       	ldd	r19, Y+34	; 0x22
    4e3e:	22 95       	swap	r18
    4e40:	32 95       	swap	r19
    4e42:	30 7f       	andi	r19, 0xF0	; 240
    4e44:	32 27       	eor	r19, r18
    4e46:	20 7f       	andi	r18, 0xF0	; 240
    4e48:	32 27       	eor	r19, r18
    4e4a:	82 0f       	add	r24, r18
    4e4c:	93 1f       	adc	r25, r19
    4e4e:	8c 57       	subi	r24, 0x7C	; 124
    4e50:	9d 4f       	sbci	r25, 0xFD	; 253
    4e52:	2d e5       	ldi	r18, 0x5D	; 93
    4e54:	fc 01       	movw	r30, r24
    4e56:	20 83       	st	Z, r18
				tmpX++;
    4e58:	8b 89       	ldd	r24, Y+19	; 0x13
    4e5a:	9c 89       	ldd	r25, Y+20	; 0x14
    4e5c:	01 96       	adiw	r24, 0x01	; 1
    4e5e:	9c 8b       	std	Y+20, r25	; 0x14
    4e60:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4e62:	d1 c1       	rjmp	.+930    	; 0x5206 <LCD_XYPrintf+0x6c4>
			case '.':
				LCD_PrintDot();
    4e64:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <LCD_PrintDot>
				LCD_BUFFOR[y][tmpX] = '.';
    4e68:	8b 89       	ldd	r24, Y+19	; 0x13
    4e6a:	9c 89       	ldd	r25, Y+20	; 0x14
    4e6c:	29 a1       	ldd	r18, Y+33	; 0x21
    4e6e:	3a a1       	ldd	r19, Y+34	; 0x22
    4e70:	22 95       	swap	r18
    4e72:	32 95       	swap	r19
    4e74:	30 7f       	andi	r19, 0xF0	; 240
    4e76:	32 27       	eor	r19, r18
    4e78:	20 7f       	andi	r18, 0xF0	; 240
    4e7a:	32 27       	eor	r19, r18
    4e7c:	82 0f       	add	r24, r18
    4e7e:	93 1f       	adc	r25, r19
    4e80:	8c 57       	subi	r24, 0x7C	; 124
    4e82:	9d 4f       	sbci	r25, 0xFD	; 253
    4e84:	2e e2       	ldi	r18, 0x2E	; 46
    4e86:	fc 01       	movw	r30, r24
    4e88:	20 83       	st	Z, r18
				tmpX++;
    4e8a:	8b 89       	ldd	r24, Y+19	; 0x13
    4e8c:	9c 89       	ldd	r25, Y+20	; 0x14
    4e8e:	01 96       	adiw	r24, 0x01	; 1
    4e90:	9c 8b       	std	Y+20, r25	; 0x14
    4e92:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4e94:	b8 c1       	rjmp	.+880    	; 0x5206 <LCD_XYPrintf+0x6c4>
			case 'C':
			case 'c': /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    4e96:	8d 89       	ldd	r24, Y+21	; 0x15
    4e98:	9e 89       	ldd	r25, Y+22	; 0x16
    4e9a:	9c 01       	movw	r18, r24
    4e9c:	2e 5f       	subi	r18, 0xFE	; 254
    4e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    4ea0:	3e 8b       	std	Y+22, r19	; 0x16
    4ea2:	2d 8b       	std	Y+21, r18	; 0x15
    4ea4:	fc 01       	movw	r30, r24
    4ea6:	80 81       	ld	r24, Z
    4ea8:	91 81       	ldd	r25, Z+1	; 0x01
    4eaa:	89 87       	std	Y+9, r24	; 0x09
				LCD_DisplayChar(ch);
    4eac:	89 85       	ldd	r24, Y+9	; 0x09
    4eae:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
				LCD_BUFFOR[y][tmpX] = ch;
    4eb2:	8b 89       	ldd	r24, Y+19	; 0x13
    4eb4:	9c 89       	ldd	r25, Y+20	; 0x14
    4eb6:	29 a1       	ldd	r18, Y+33	; 0x21
    4eb8:	3a a1       	ldd	r19, Y+34	; 0x22
    4eba:	22 95       	swap	r18
    4ebc:	32 95       	swap	r19
    4ebe:	30 7f       	andi	r19, 0xF0	; 240
    4ec0:	32 27       	eor	r19, r18
    4ec2:	20 7f       	andi	r18, 0xF0	; 240
    4ec4:	32 27       	eor	r19, r18
    4ec6:	82 0f       	add	r24, r18
    4ec8:	93 1f       	adc	r25, r19
    4eca:	8c 57       	subi	r24, 0x7C	; 124
    4ecc:	9d 4f       	sbci	r25, 0xFD	; 253
    4ece:	29 85       	ldd	r18, Y+9	; 0x09
    4ed0:	fc 01       	movw	r30, r24
    4ed2:	20 83       	st	Z, r18
				tmpX++;
    4ed4:	8b 89       	ldd	r24, Y+19	; 0x13
    4ed6:	9c 89       	ldd	r25, Y+20	; 0x14
    4ed8:	01 96       	adiw	r24, 0x01	; 1
    4eda:	9c 8b       	std	Y+20, r25	; 0x14
    4edc:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    4ede:	93 c1       	rjmp	.+806    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'd': /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, int);
    4ee0:	8d 89       	ldd	r24, Y+21	; 0x15
    4ee2:	9e 89       	ldd	r25, Y+22	; 0x16
    4ee4:	9c 01       	movw	r18, r24
    4ee6:	2e 5f       	subi	r18, 0xFE	; 254
    4ee8:	3f 4f       	sbci	r19, 0xFF	; 255
    4eea:	3e 8b       	std	Y+22, r19	; 0x16
    4eec:	2d 8b       	std	Y+21, r18	; 0x15
    4eee:	fc 01       	movw	r30, r24
    4ef0:	80 81       	ld	r24, Z
    4ef2:	91 81       	ldd	r25, Z+1	; 0x01
    4ef4:	9c 83       	std	Y+4, r25	; 0x04
    4ef6:	8b 83       	std	Y+3, r24	; 0x03
				if (v_num_s16 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    4ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    4efa:	9c 81       	ldd	r25, Y+4	; 0x04
    4efc:	99 23       	and	r25, r25
    4efe:	04 f5       	brge	.+64     	; 0x4f40 <LCD_XYPrintf+0x3fe>
					v_num_s16 = -v_num_s16;
    4f00:	8b 81       	ldd	r24, Y+3	; 0x03
    4f02:	9c 81       	ldd	r25, Y+4	; 0x04
    4f04:	91 95       	neg	r25
    4f06:	81 95       	neg	r24
    4f08:	91 09       	sbc	r25, r1
    4f0a:	9c 83       	std	Y+4, r25	; 0x04
    4f0c:	8b 83       	std	Y+3, r24	; 0x03
					LCD_DisplayChar('-');
    4f0e:	8d e2       	ldi	r24, 0x2D	; 45
    4f10:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
					LCD_BUFFOR[y][tmpX] = '-';
    4f14:	8b 89       	ldd	r24, Y+19	; 0x13
    4f16:	9c 89       	ldd	r25, Y+20	; 0x14
    4f18:	29 a1       	ldd	r18, Y+33	; 0x21
    4f1a:	3a a1       	ldd	r19, Y+34	; 0x22
    4f1c:	22 95       	swap	r18
    4f1e:	32 95       	swap	r19
    4f20:	30 7f       	andi	r19, 0xF0	; 240
    4f22:	32 27       	eor	r19, r18
    4f24:	20 7f       	andi	r18, 0xF0	; 240
    4f26:	32 27       	eor	r19, r18
    4f28:	82 0f       	add	r24, r18
    4f2a:	93 1f       	adc	r25, r19
    4f2c:	8c 57       	subi	r24, 0x7C	; 124
    4f2e:	9d 4f       	sbci	r25, 0xFD	; 253
    4f30:	2d e2       	ldi	r18, 0x2D	; 45
    4f32:	fc 01       	movw	r30, r24
    4f34:	20 83       	st	Z, r18
					tmpX++;
    4f36:	8b 89       	ldd	r24, Y+19	; 0x13
    4f38:	9c 89       	ldd	r25, Y+20	; 0x14
    4f3a:	01 96       	adiw	r24, 0x01	; 1
    4f3c:	9c 8b       	std	Y+20, r25	; 0x14
    4f3e:	8b 8b       	std	Y+19, r24	; 0x13
				}
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_s16,
    4f40:	8b 81       	ldd	r24, Y+3	; 0x03
    4f42:	9c 81       	ldd	r25, Y+4	; 0x04
    4f44:	aa 27       	eor	r26, r26
    4f46:	97 fd       	sbrc	r25, 7
    4f48:	a0 95       	com	r26
    4f4a:	ba 2f       	mov	r27, r26
    4f4c:	49 a1       	ldd	r20, Y+33	; 0x21
    4f4e:	5a a1       	ldd	r21, Y+34	; 0x22
    4f50:	9e 01       	movw	r18, r28
    4f52:	2d 5e       	subi	r18, 0xED	; 237
    4f54:	3f 4f       	sbci	r19, 0xFF	; 255
    4f56:	7a 01       	movw	r14, r20
    4f58:	89 01       	movw	r16, r18
    4f5a:	2a 85       	ldd	r18, Y+10	; 0x0a
    4f5c:	ac 01       	movw	r20, r24
    4f5e:	bd 01       	movw	r22, r26
    4f60:	8a e0       	ldi	r24, 0x0A	; 10
    4f62:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    4f66:	4f c1       	rjmp	.+670    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'D': /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);
    4f68:	8d 89       	ldd	r24, Y+21	; 0x15
    4f6a:	9e 89       	ldd	r25, Y+22	; 0x16
    4f6c:	9c 01       	movw	r18, r24
    4f6e:	2c 5f       	subi	r18, 0xFC	; 252
    4f70:	3f 4f       	sbci	r19, 0xFF	; 255
    4f72:	3e 8b       	std	Y+22, r19	; 0x16
    4f74:	2d 8b       	std	Y+21, r18	; 0x15
    4f76:	fc 01       	movw	r30, r24
    4f78:	80 81       	ld	r24, Z
    4f7a:	91 81       	ldd	r25, Z+1	; 0x01
    4f7c:	a2 81       	ldd	r26, Z+2	; 0x02
    4f7e:	b3 81       	ldd	r27, Z+3	; 0x03
    4f80:	8d 83       	std	Y+5, r24	; 0x05
    4f82:	9e 83       	std	Y+6, r25	; 0x06
    4f84:	af 83       	std	Y+7, r26	; 0x07
    4f86:	b8 87       	std	Y+8, r27	; 0x08
				if (v_num_s32 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    4f88:	8d 81       	ldd	r24, Y+5	; 0x05
    4f8a:	9e 81       	ldd	r25, Y+6	; 0x06
    4f8c:	af 81       	ldd	r26, Y+7	; 0x07
    4f8e:	b8 85       	ldd	r27, Y+8	; 0x08
    4f90:	bb 23       	and	r27, r27
    4f92:	44 f5       	brge	.+80     	; 0x4fe4 <LCD_XYPrintf+0x4a2>
					v_num_s32 = -v_num_s32;
    4f94:	8d 81       	ldd	r24, Y+5	; 0x05
    4f96:	9e 81       	ldd	r25, Y+6	; 0x06
    4f98:	af 81       	ldd	r26, Y+7	; 0x07
    4f9a:	b8 85       	ldd	r27, Y+8	; 0x08
    4f9c:	b0 95       	com	r27
    4f9e:	a0 95       	com	r26
    4fa0:	90 95       	com	r25
    4fa2:	81 95       	neg	r24
    4fa4:	9f 4f       	sbci	r25, 0xFF	; 255
    4fa6:	af 4f       	sbci	r26, 0xFF	; 255
    4fa8:	bf 4f       	sbci	r27, 0xFF	; 255
    4faa:	8d 83       	std	Y+5, r24	; 0x05
    4fac:	9e 83       	std	Y+6, r25	; 0x06
    4fae:	af 83       	std	Y+7, r26	; 0x07
    4fb0:	b8 87       	std	Y+8, r27	; 0x08
					LCD_DisplayChar('-');
    4fb2:	8d e2       	ldi	r24, 0x2D	; 45
    4fb4:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
					LCD_BUFFOR[y][tmpX] = '-';
    4fb8:	8b 89       	ldd	r24, Y+19	; 0x13
    4fba:	9c 89       	ldd	r25, Y+20	; 0x14
    4fbc:	29 a1       	ldd	r18, Y+33	; 0x21
    4fbe:	3a a1       	ldd	r19, Y+34	; 0x22
    4fc0:	22 95       	swap	r18
    4fc2:	32 95       	swap	r19
    4fc4:	30 7f       	andi	r19, 0xF0	; 240
    4fc6:	32 27       	eor	r19, r18
    4fc8:	20 7f       	andi	r18, 0xF0	; 240
    4fca:	32 27       	eor	r19, r18
    4fcc:	82 0f       	add	r24, r18
    4fce:	93 1f       	adc	r25, r19
    4fd0:	8c 57       	subi	r24, 0x7C	; 124
    4fd2:	9d 4f       	sbci	r25, 0xFD	; 253
    4fd4:	2d e2       	ldi	r18, 0x2D	; 45
    4fd6:	fc 01       	movw	r30, r24
    4fd8:	20 83       	st	Z, r18
					tmpX++;
    4fda:	8b 89       	ldd	r24, Y+19	; 0x13
    4fdc:	9c 89       	ldd	r25, Y+20	; 0x14
    4fde:	01 96       	adiw	r24, 0x01	; 1
    4fe0:	9c 8b       	std	Y+20, r25	; 0x14
    4fe2:	8b 8b       	std	Y+19, r24	; 0x13
				}
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_s32,
    4fe4:	8d 81       	ldd	r24, Y+5	; 0x05
    4fe6:	9e 81       	ldd	r25, Y+6	; 0x06
    4fe8:	af 81       	ldd	r26, Y+7	; 0x07
    4fea:	b8 85       	ldd	r27, Y+8	; 0x08
    4fec:	49 a1       	ldd	r20, Y+33	; 0x21
    4fee:	5a a1       	ldd	r21, Y+34	; 0x22
    4ff0:	9e 01       	movw	r18, r28
    4ff2:	2d 5e       	subi	r18, 0xED	; 237
    4ff4:	3f 4f       	sbci	r19, 0xFF	; 255
    4ff6:	7a 01       	movw	r14, r20
    4ff8:	89 01       	movw	r16, r18
    4ffa:	2a 85       	ldd	r18, Y+10	; 0x0a
    4ffc:	ac 01       	movw	r20, r24
    4ffe:	bd 01       	movw	r22, r26
    5000:	8a e0       	ldi	r24, 0x0A	; 10
    5002:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    5006:	ff c0       	rjmp	.+510    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'u': /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, int);
    5008:	8d 89       	ldd	r24, Y+21	; 0x15
    500a:	9e 89       	ldd	r25, Y+22	; 0x16
    500c:	9c 01       	movw	r18, r24
    500e:	2e 5f       	subi	r18, 0xFE	; 254
    5010:	3f 4f       	sbci	r19, 0xFF	; 255
    5012:	3e 8b       	std	Y+22, r19	; 0x16
    5014:	2d 8b       	std	Y+21, r18	; 0x15
    5016:	fc 01       	movw	r30, r24
    5018:	80 81       	ld	r24, Z
    501a:	91 81       	ldd	r25, Z+1	; 0x01
    501c:	9c 87       	std	Y+12, r25	; 0x0c
    501e:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_u16,
    5020:	8b 85       	ldd	r24, Y+11	; 0x0b
    5022:	9c 85       	ldd	r25, Y+12	; 0x0c
    5024:	cc 01       	movw	r24, r24
    5026:	a0 e0       	ldi	r26, 0x00	; 0
    5028:	b0 e0       	ldi	r27, 0x00	; 0
    502a:	49 a1       	ldd	r20, Y+33	; 0x21
    502c:	5a a1       	ldd	r21, Y+34	; 0x22
    502e:	9e 01       	movw	r18, r28
    5030:	2d 5e       	subi	r18, 0xED	; 237
    5032:	3f 4f       	sbci	r19, 0xFF	; 255
    5034:	7a 01       	movw	r14, r20
    5036:	89 01       	movw	r16, r18
    5038:	2a 85       	ldd	r18, Y+10	; 0x0a
    503a:	ac 01       	movw	r20, r24
    503c:	bd 01       	movw	r22, r26
    503e:	8a e0       	ldi	r24, 0x0A	; 10
    5040:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    5044:	e0 c0       	rjmp	.+448    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'U': /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);
    5046:	8d 89       	ldd	r24, Y+21	; 0x15
    5048:	9e 89       	ldd	r25, Y+22	; 0x16
    504a:	9c 01       	movw	r18, r24
    504c:	2c 5f       	subi	r18, 0xFC	; 252
    504e:	3f 4f       	sbci	r19, 0xFF	; 255
    5050:	3e 8b       	std	Y+22, r19	; 0x16
    5052:	2d 8b       	std	Y+21, r18	; 0x15
    5054:	fc 01       	movw	r30, r24
    5056:	80 81       	ld	r24, Z
    5058:	91 81       	ldd	r25, Z+1	; 0x01
    505a:	a2 81       	ldd	r26, Z+2	; 0x02
    505c:	b3 81       	ldd	r27, Z+3	; 0x03
    505e:	8d 87       	std	Y+13, r24	; 0x0d
    5060:	9e 87       	std	Y+14, r25	; 0x0e
    5062:	af 87       	std	Y+15, r26	; 0x0f
    5064:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_u32,
    5066:	49 a1       	ldd	r20, Y+33	; 0x21
    5068:	5a a1       	ldd	r21, Y+34	; 0x22
    506a:	9e 01       	movw	r18, r28
    506c:	2d 5e       	subi	r18, 0xED	; 237
    506e:	3f 4f       	sbci	r19, 0xFF	; 255
    5070:	8d 85       	ldd	r24, Y+13	; 0x0d
    5072:	9e 85       	ldd	r25, Y+14	; 0x0e
    5074:	af 85       	ldd	r26, Y+15	; 0x0f
    5076:	b8 89       	ldd	r27, Y+16	; 0x10
    5078:	7a 01       	movw	r14, r20
    507a:	89 01       	movw	r16, r18
    507c:	2a 85       	ldd	r18, Y+10	; 0x0a
    507e:	ac 01       	movw	r20, r24
    5080:	bd 01       	movw	r22, r26
    5082:	8a e0       	ldi	r24, 0x0A	; 10
    5084:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    5088:	be c0       	rjmp	.+380    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'x': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, int);
    508a:	8d 89       	ldd	r24, Y+21	; 0x15
    508c:	9e 89       	ldd	r25, Y+22	; 0x16
    508e:	9c 01       	movw	r18, r24
    5090:	2e 5f       	subi	r18, 0xFE	; 254
    5092:	3f 4f       	sbci	r19, 0xFF	; 255
    5094:	3e 8b       	std	Y+22, r19	; 0x16
    5096:	2d 8b       	std	Y+21, r18	; 0x15
    5098:	fc 01       	movw	r30, r24
    509a:	80 81       	ld	r24, Z
    509c:	91 81       	ldd	r25, Z+1	; 0x01
    509e:	9c 87       	std	Y+12, r25	; 0x0c
    50a0:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumberWithAddingToBuffor(C_HEX_U8, v_num_u16,
    50a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    50a4:	9c 85       	ldd	r25, Y+12	; 0x0c
    50a6:	cc 01       	movw	r24, r24
    50a8:	a0 e0       	ldi	r26, 0x00	; 0
    50aa:	b0 e0       	ldi	r27, 0x00	; 0
    50ac:	49 a1       	ldd	r20, Y+33	; 0x21
    50ae:	5a a1       	ldd	r21, Y+34	; 0x22
    50b0:	9e 01       	movw	r18, r28
    50b2:	2d 5e       	subi	r18, 0xED	; 237
    50b4:	3f 4f       	sbci	r19, 0xFF	; 255
    50b6:	7a 01       	movw	r14, r20
    50b8:	89 01       	movw	r16, r18
    50ba:	2a 85       	ldd	r18, Y+10	; 0x0a
    50bc:	ac 01       	movw	r20, r24
    50be:	bd 01       	movw	r22, r26
    50c0:	80 e1       	ldi	r24, 0x10	; 16
    50c2:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    50c6:	9f c0       	rjmp	.+318    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'X': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);
    50c8:	8d 89       	ldd	r24, Y+21	; 0x15
    50ca:	9e 89       	ldd	r25, Y+22	; 0x16
    50cc:	9c 01       	movw	r18, r24
    50ce:	2c 5f       	subi	r18, 0xFC	; 252
    50d0:	3f 4f       	sbci	r19, 0xFF	; 255
    50d2:	3e 8b       	std	Y+22, r19	; 0x16
    50d4:	2d 8b       	std	Y+21, r18	; 0x15
    50d6:	fc 01       	movw	r30, r24
    50d8:	80 81       	ld	r24, Z
    50da:	91 81       	ldd	r25, Z+1	; 0x01
    50dc:	a2 81       	ldd	r26, Z+2	; 0x02
    50de:	b3 81       	ldd	r27, Z+3	; 0x03
    50e0:	8d 87       	std	Y+13, r24	; 0x0d
    50e2:	9e 87       	std	Y+14, r25	; 0x0e
    50e4:	af 87       	std	Y+15, r26	; 0x0f
    50e6:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumberWithAddingToBuffor(C_HEX_U8, v_num_u32,
    50e8:	49 a1       	ldd	r20, Y+33	; 0x21
    50ea:	5a a1       	ldd	r21, Y+34	; 0x22
    50ec:	9e 01       	movw	r18, r28
    50ee:	2d 5e       	subi	r18, 0xED	; 237
    50f0:	3f 4f       	sbci	r19, 0xFF	; 255
    50f2:	8d 85       	ldd	r24, Y+13	; 0x0d
    50f4:	9e 85       	ldd	r25, Y+14	; 0x0e
    50f6:	af 85       	ldd	r26, Y+15	; 0x0f
    50f8:	b8 89       	ldd	r27, Y+16	; 0x10
    50fa:	7a 01       	movw	r14, r20
    50fc:	89 01       	movw	r16, r18
    50fe:	2a 85       	ldd	r18, Y+10	; 0x0a
    5100:	ac 01       	movw	r20, r24
    5102:	bd 01       	movw	r22, r26
    5104:	80 e1       	ldi	r24, 0x10	; 16
    5106:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    510a:	7d c0       	rjmp	.+250    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'b': /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, int);
    510c:	8d 89       	ldd	r24, Y+21	; 0x15
    510e:	9e 89       	ldd	r25, Y+22	; 0x16
    5110:	9c 01       	movw	r18, r24
    5112:	2e 5f       	subi	r18, 0xFE	; 254
    5114:	3f 4f       	sbci	r19, 0xFF	; 255
    5116:	3e 8b       	std	Y+22, r19	; 0x16
    5118:	2d 8b       	std	Y+21, r18	; 0x15
    511a:	fc 01       	movw	r30, r24
    511c:	80 81       	ld	r24, Z
    511e:	91 81       	ldd	r25, Z+1	; 0x01
    5120:	9c 87       	std	Y+12, r25	; 0x0c
    5122:	8b 87       	std	Y+11, r24	; 0x0b
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    5124:	8a 85       	ldd	r24, Y+10	; 0x0a
    5126:	8f 3f       	cpi	r24, 0xFF	; 255
    5128:	11 f4       	brne	.+4      	; 0x512e <LCD_XYPrintf+0x5ec>
					v_numOfDigitsToDisp_u8 = 16;
    512a:	80 e1       	ldi	r24, 0x10	; 16
    512c:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumberWithAddingToBuffor(C_BINARY_U8, v_num_u16,
    512e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5130:	9c 85       	ldd	r25, Y+12	; 0x0c
    5132:	cc 01       	movw	r24, r24
    5134:	a0 e0       	ldi	r26, 0x00	; 0
    5136:	b0 e0       	ldi	r27, 0x00	; 0
    5138:	49 a1       	ldd	r20, Y+33	; 0x21
    513a:	5a a1       	ldd	r21, Y+34	; 0x22
    513c:	9e 01       	movw	r18, r28
    513e:	2d 5e       	subi	r18, 0xED	; 237
    5140:	3f 4f       	sbci	r19, 0xFF	; 255
    5142:	7a 01       	movw	r14, r20
    5144:	89 01       	movw	r16, r18
    5146:	2a 85       	ldd	r18, Y+10	; 0x0a
    5148:	ac 01       	movw	r20, r24
    514a:	bd 01       	movw	r22, r26
    514c:	82 e0       	ldi	r24, 0x02	; 2
    514e:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    5152:	59 c0       	rjmp	.+178    	; 0x5206 <LCD_XYPrintf+0x6c4>

			case 'B': /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);
    5154:	8d 89       	ldd	r24, Y+21	; 0x15
    5156:	9e 89       	ldd	r25, Y+22	; 0x16
    5158:	9c 01       	movw	r18, r24
    515a:	2c 5f       	subi	r18, 0xFC	; 252
    515c:	3f 4f       	sbci	r19, 0xFF	; 255
    515e:	3e 8b       	std	Y+22, r19	; 0x16
    5160:	2d 8b       	std	Y+21, r18	; 0x15
    5162:	fc 01       	movw	r30, r24
    5164:	80 81       	ld	r24, Z
    5166:	91 81       	ldd	r25, Z+1	; 0x01
    5168:	a2 81       	ldd	r26, Z+2	; 0x02
    516a:	b3 81       	ldd	r27, Z+3	; 0x03
    516c:	8d 87       	std	Y+13, r24	; 0x0d
    516e:	9e 87       	std	Y+14, r25	; 0x0e
    5170:	af 87       	std	Y+15, r26	; 0x0f
    5172:	b8 8b       	std	Y+16, r27	; 0x10
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    5174:	8a 85       	ldd	r24, Y+10	; 0x0a
    5176:	8f 3f       	cpi	r24, 0xFF	; 255
    5178:	11 f4       	brne	.+4      	; 0x517e <LCD_XYPrintf+0x63c>
					v_numOfDigitsToDisp_u8 = 16;
    517a:	80 e1       	ldi	r24, 0x10	; 16
    517c:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumberWithAddingToBuffor(C_BINARY_U8, v_num_u32,
    517e:	49 a1       	ldd	r20, Y+33	; 0x21
    5180:	5a a1       	ldd	r21, Y+34	; 0x22
    5182:	9e 01       	movw	r18, r28
    5184:	2d 5e       	subi	r18, 0xED	; 237
    5186:	3f 4f       	sbci	r19, 0xFF	; 255
    5188:	8d 85       	ldd	r24, Y+13	; 0x0d
    518a:	9e 85       	ldd	r25, Y+14	; 0x0e
    518c:	af 85       	ldd	r26, Y+15	; 0x0f
    518e:	b8 89       	ldd	r27, Y+16	; 0x10
    5190:	7a 01       	movw	r14, r20
    5192:	89 01       	movw	r16, r18
    5194:	2a 85       	ldd	r18, Y+10	; 0x0a
    5196:	ac 01       	movw	r20, r24
    5198:	bd 01       	movw	r22, r26
    519a:	82 e0       	ldi	r24, 0x02	; 2
    519c:	0e 94 28 24 	call	0x4850	; 0x4850 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    51a0:	32 c0       	rjmp	.+100    	; 0x5206 <LCD_XYPrintf+0x6c4>
#endif
				break;

			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char*);
    51a2:	8d 89       	ldd	r24, Y+21	; 0x15
    51a4:	9e 89       	ldd	r25, Y+22	; 0x16
    51a6:	9c 01       	movw	r18, r24
    51a8:	2e 5f       	subi	r18, 0xFE	; 254
    51aa:	3f 4f       	sbci	r19, 0xFF	; 255
    51ac:	3e 8b       	std	Y+22, r19	; 0x16
    51ae:	2d 8b       	std	Y+21, r18	; 0x15
    51b0:	fc 01       	movw	r30, r24
    51b2:	80 81       	ld	r24, Z
    51b4:	91 81       	ldd	r25, Z+1	; 0x01
    51b6:	9a 8b       	std	Y+18, r25	; 0x12
    51b8:	89 8b       	std	Y+17, r24	; 0x11
				LCD_DisplayStringWithAddingToBuffor(str, &tmpX, y);
    51ba:	49 a1       	ldd	r20, Y+33	; 0x21
    51bc:	5a a1       	ldd	r21, Y+34	; 0x22
    51be:	9e 01       	movw	r18, r28
    51c0:	2d 5e       	subi	r18, 0xED	; 237
    51c2:	3f 4f       	sbci	r19, 0xFF	; 255
    51c4:	89 89       	ldd	r24, Y+17	; 0x11
    51c6:	9a 89       	ldd	r25, Y+18	; 0x12
    51c8:	b9 01       	movw	r22, r18
    51ca:	0e 94 84 20 	call	0x4108	; 0x4108 <LCD_DisplayStringWithAddingToBuffor>
				break;
    51ce:	1b c0       	rjmp	.+54     	; 0x5206 <LCD_XYPrintf+0x6c4>

			case '%':
				LCD_DisplayChar('%');
    51d0:	85 e2       	ldi	r24, 0x25	; 37
    51d2:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
				LCD_BUFFOR[y][tmpX] = '%';
    51d6:	8b 89       	ldd	r24, Y+19	; 0x13
    51d8:	9c 89       	ldd	r25, Y+20	; 0x14
    51da:	29 a1       	ldd	r18, Y+33	; 0x21
    51dc:	3a a1       	ldd	r19, Y+34	; 0x22
    51de:	22 95       	swap	r18
    51e0:	32 95       	swap	r19
    51e2:	30 7f       	andi	r19, 0xF0	; 240
    51e4:	32 27       	eor	r19, r18
    51e6:	20 7f       	andi	r18, 0xF0	; 240
    51e8:	32 27       	eor	r19, r18
    51ea:	82 0f       	add	r24, r18
    51ec:	93 1f       	adc	r25, r19
    51ee:	8c 57       	subi	r24, 0x7C	; 124
    51f0:	9d 4f       	sbci	r25, 0xFD	; 253
    51f2:	25 e2       	ldi	r18, 0x25	; 37
    51f4:	fc 01       	movw	r30, r24
    51f6:	20 83       	st	Z, r18
				tmpX++;
    51f8:	8b 89       	ldd	r24, Y+19	; 0x13
    51fa:	9c 89       	ldd	r25, Y+20	; 0x14
    51fc:	01 96       	adiw	r24, 0x01	; 1
    51fe:	9c 8b       	std	Y+20, r25	; 0x14
    5200:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    5202:	01 c0       	rjmp	.+2      	; 0x5206 <LCD_XYPrintf+0x6c4>
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)  
                v_floatNum_f32 = va_arg(argp, double);              
                LCD_DisplayFloatNumber(v_floatNum_f32);
#endif
				break;
    5204:	00 00       	nop
    5206:	19 c0       	rjmp	.+50     	; 0x523a <LCD_XYPrintf+0x6f8>
				tmpX++;
				break;
			}
		} else {
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
    5208:	89 85       	ldd	r24, Y+9	; 0x09
    520a:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
			LCD_BUFFOR[y][tmpX] = ch;
    520e:	8b 89       	ldd	r24, Y+19	; 0x13
    5210:	9c 89       	ldd	r25, Y+20	; 0x14
    5212:	29 a1       	ldd	r18, Y+33	; 0x21
    5214:	3a a1       	ldd	r19, Y+34	; 0x22
    5216:	22 95       	swap	r18
    5218:	32 95       	swap	r19
    521a:	30 7f       	andi	r19, 0xF0	; 240
    521c:	32 27       	eor	r19, r18
    521e:	20 7f       	andi	r18, 0xF0	; 240
    5220:	32 27       	eor	r19, r18
    5222:	82 0f       	add	r24, r18
    5224:	93 1f       	adc	r25, r19
    5226:	8c 57       	subi	r24, 0x7C	; 124
    5228:	9d 4f       	sbci	r25, 0xFD	; 253
    522a:	29 85       	ldd	r18, Y+9	; 0x09
    522c:	fc 01       	movw	r30, r24
    522e:	20 83       	st	Z, r18
			tmpX++;
    5230:	8b 89       	ldd	r24, Y+19	; 0x13
    5232:	9c 89       	ldd	r25, Y+20	; 0x14
    5234:	01 96       	adiw	r24, 0x01	; 1
    5236:	9c 8b       	std	Y+20, r25	; 0x14
    5238:	8b 8b       	std	Y+19, r24	; 0x13
#endif

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    523a:	89 81       	ldd	r24, Y+1	; 0x01
    523c:	9a 81       	ldd	r25, Y+2	; 0x02
    523e:	01 96       	adiw	r24, 0x01	; 1
    5240:	9a 83       	std	Y+2, r25	; 0x02
    5242:	89 83       	std	Y+1, r24	; 0x01
    5244:	89 81       	ldd	r24, Y+1	; 0x01
    5246:	9a 81       	ldd	r25, Y+2	; 0x02
    5248:	fc 01       	movw	r30, r24
    524a:	80 81       	ld	r24, Z
    524c:	88 23       	and	r24, r24
    524e:	09 f0       	breq	.+2      	; 0x5252 <LCD_XYPrintf+0x710>
    5250:	98 cc       	rjmp	.-1744   	; 0x4b82 <LCD_XYPrintf+0x40>
			tmpX++;
		}
	}

	va_end(argp);
}
    5252:	66 96       	adiw	r28, 0x16	; 22
    5254:	0f b6       	in	r0, 0x3f	; 63
    5256:	f8 94       	cli
    5258:	de bf       	out	0x3e, r29	; 62
    525a:	0f be       	out	0x3f, r0	; 63
    525c:	cd bf       	out	0x3d, r28	; 61
    525e:	df 91       	pop	r29
    5260:	cf 91       	pop	r28
    5262:	1f 91       	pop	r17
    5264:	0f 91       	pop	r16
    5266:	ff 90       	pop	r15
    5268:	ef 90       	pop	r14
    526a:	08 95       	ret

0000526c <LCD_Printf>:
#endif

#if ( Enable_LCD_Printf   == 1 )
void LCD_Printf(const char *argList, ...) {
    526c:	cf 93       	push	r28
    526e:	df 93       	push	r29
    5270:	cd b7       	in	r28, 0x3d	; 61
    5272:	de b7       	in	r29, 0x3e	; 62
    5274:	64 97       	sbiw	r28, 0x14	; 20
    5276:	0f b6       	in	r0, 0x3f	; 63
    5278:	f8 94       	cli
    527a:	de bf       	out	0x3e, r29	; 62
    527c:	0f be       	out	0x3f, r0	; 63
    527e:	cd bf       	out	0x3d, r28	; 61
	uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)
    double v_floatNum_f32;
#endif

	va_start(argp, argList);
    5280:	ce 01       	movw	r24, r28
    5282:	4b 96       	adiw	r24, 0x1b	; 27
    5284:	9c 8b       	std	Y+20, r25	; 0x14
    5286:	8b 8b       	std	Y+19, r24	; 0x13

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    5288:	89 8d       	ldd	r24, Y+25	; 0x19
    528a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    528c:	9a 83       	std	Y+2, r25	; 0x02
    528e:	89 83       	std	Y+1, r24	; 0x01
    5290:	ad c1       	rjmp	.+858    	; 0x55ec <LCD_Printf+0x380>

		ch = *ptr;
    5292:	89 81       	ldd	r24, Y+1	; 0x01
    5294:	9a 81       	ldd	r25, Y+2	; 0x02
    5296:	fc 01       	movw	r30, r24
    5298:	80 81       	ld	r24, Z
    529a:	89 87       	std	Y+9, r24	; 0x09
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
    529c:	89 85       	ldd	r24, Y+9	; 0x09
    529e:	85 32       	cpi	r24, 0x25	; 37
    52a0:	09 f0       	breq	.+2      	; 0x52a4 <LCD_Printf+0x38>
    52a2:	9c c1       	rjmp	.+824    	; 0x55dc <LCD_Printf+0x370>
		{
			ptr++;
    52a4:	89 81       	ldd	r24, Y+1	; 0x01
    52a6:	9a 81       	ldd	r25, Y+2	; 0x02
    52a8:	01 96       	adiw	r24, 0x01	; 1
    52aa:	9a 83       	std	Y+2, r25	; 0x02
    52ac:	89 83       	std	Y+1, r24	; 0x01
			ch = *ptr;
    52ae:	89 81       	ldd	r24, Y+1	; 0x01
    52b0:	9a 81       	ldd	r25, Y+2	; 0x02
    52b2:	fc 01       	movw	r30, r24
    52b4:	80 81       	ld	r24, Z
    52b6:	89 87       	std	Y+9, r24	; 0x09
			if ((ch >= 0x30) && (ch <= 0x39)) {
    52b8:	89 85       	ldd	r24, Y+9	; 0x09
    52ba:	80 33       	cpi	r24, 0x30	; 48
    52bc:	00 f1       	brcs	.+64     	; 0x52fe <LCD_Printf+0x92>
    52be:	89 85       	ldd	r24, Y+9	; 0x09
    52c0:	8a 33       	cpi	r24, 0x3A	; 58
    52c2:	e8 f4       	brcc	.+58     	; 0x52fe <LCD_Printf+0x92>
				v_numOfDigitsToDisp_u8 = 0;
    52c4:	1a 86       	std	Y+10, r1	; 0x0a
				while ((ch >= 0x30) && (ch <= 0x39)) {
    52c6:	14 c0       	rjmp	.+40     	; 0x52f0 <LCD_Printf+0x84>
					v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10)
    52c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    52ca:	88 0f       	add	r24, r24
    52cc:	98 2f       	mov	r25, r24
    52ce:	99 0f       	add	r25, r25
    52d0:	99 0f       	add	r25, r25
    52d2:	98 0f       	add	r25, r24
    52d4:	89 85       	ldd	r24, Y+9	; 0x09
    52d6:	89 0f       	add	r24, r25
    52d8:	80 53       	subi	r24, 0x30	; 48
    52da:	8a 87       	std	Y+10, r24	; 0x0a
							+ (ch - 0x30);
					ptr++;
    52dc:	89 81       	ldd	r24, Y+1	; 0x01
    52de:	9a 81       	ldd	r25, Y+2	; 0x02
    52e0:	01 96       	adiw	r24, 0x01	; 1
    52e2:	9a 83       	std	Y+2, r25	; 0x02
    52e4:	89 83       	std	Y+1, r24	; 0x01
					ch = *ptr;
    52e6:	89 81       	ldd	r24, Y+1	; 0x01
    52e8:	9a 81       	ldd	r25, Y+2	; 0x02
    52ea:	fc 01       	movw	r30, r24
    52ec:	80 81       	ld	r24, Z
    52ee:	89 87       	std	Y+9, r24	; 0x09
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
				v_numOfDigitsToDisp_u8 = 0;
				while ((ch >= 0x30) && (ch <= 0x39)) {
    52f0:	89 85       	ldd	r24, Y+9	; 0x09
    52f2:	80 33       	cpi	r24, 0x30	; 48
    52f4:	18 f0       	brcs	.+6      	; 0x52fc <LCD_Printf+0x90>
    52f6:	89 85       	ldd	r24, Y+9	; 0x09
    52f8:	8a 33       	cpi	r24, 0x3A	; 58
    52fa:	30 f3       	brcs	.-52     	; 0x52c8 <LCD_Printf+0x5c>
		ch = *ptr;
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
    52fc:	02 c0       	rjmp	.+4      	; 0x5302 <LCD_Printf+0x96>
							+ (ch - 0x30);
					ptr++;
					ch = *ptr;
				}
			} else {
				v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    52fe:	8f ef       	ldi	r24, 0xFF	; 255
    5300:	8a 87       	std	Y+10, r24	; 0x0a
			}

			switch (ch) /* Decode the type of the argument */
    5302:	89 85       	ldd	r24, Y+9	; 0x09
    5304:	88 2f       	mov	r24, r24
    5306:	90 e0       	ldi	r25, 0x00	; 0
    5308:	aa 27       	eor	r26, r26
    530a:	97 fd       	sbrc	r25, 7
    530c:	a0 95       	com	r26
    530e:	ba 2f       	mov	r27, r26
    5310:	45 e2       	ldi	r20, 0x25	; 37
    5312:	50 e0       	ldi	r21, 0x00	; 0
    5314:	28 e5       	ldi	r18, 0x58	; 88
    5316:	30 e0       	ldi	r19, 0x00	; 0
    5318:	84 1b       	sub	r24, r20
    531a:	95 0b       	sbc	r25, r21
    531c:	28 17       	cp	r18, r24
    531e:	39 07       	cpc	r19, r25
    5320:	08 f4       	brcc	.+2      	; 0x5324 <LCD_Printf+0xb8>
    5322:	5f c1       	rjmp	.+702    	; 0x55e2 <LCD_Printf+0x376>
    5324:	84 52       	subi	r24, 0x24	; 36
    5326:	9f 4f       	sbci	r25, 0xFF	; 255
    5328:	fc 01       	movw	r30, r24
    532a:	0c 94 36 32 	jmp	0x646c	; 0x646c <__tablejump2__>
			{
			case '>':
				LCD_PrintSymbol(1);
    532e:	81 e0       	ldi	r24, 0x01	; 1
    5330:	90 e0       	ldi	r25, 0x00	; 0
    5332:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    5336:	51 c1       	rjmp	.+674    	; 0x55da <LCD_Printf+0x36e>
			case '<':
				LCD_PrintSymbol(2);
    5338:	82 e0       	ldi	r24, 0x02	; 2
    533a:	90 e0       	ldi	r25, 0x00	; 0
    533c:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    5340:	4c c1       	rjmp	.+664    	; 0x55da <LCD_Printf+0x36e>
			case '|':
				LCD_PrintSymbol(3);
    5342:	83 e0       	ldi	r24, 0x03	; 3
    5344:	90 e0       	ldi	r25, 0x00	; 0
    5346:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    534a:	47 c1       	rjmp	.+654    	; 0x55da <LCD_Printf+0x36e>
			case '{':
				LCD_PrintSymbol(4);
    534c:	84 e0       	ldi	r24, 0x04	; 4
    534e:	90 e0       	ldi	r25, 0x00	; 0
    5350:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    5354:	42 c1       	rjmp	.+644    	; 0x55da <LCD_Printf+0x36e>
			case '}':
				LCD_PrintSymbol(5);
    5356:	85 e0       	ldi	r24, 0x05	; 5
    5358:	90 e0       	ldi	r25, 0x00	; 0
    535a:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    535e:	3d c1       	rjmp	.+634    	; 0x55da <LCD_Printf+0x36e>
			case ',':
				LCD_PrintSymbol(6);
    5360:	86 e0       	ldi	r24, 0x06	; 6
    5362:	90 e0       	ldi	r25, 0x00	; 0
    5364:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    5368:	38 c1       	rjmp	.+624    	; 0x55da <LCD_Printf+0x36e>
			case ':':
				LCD_PrintSymbol(7);
    536a:	87 e0       	ldi	r24, 0x07	; 7
    536c:	90 e0       	ldi	r25, 0x00	; 0
    536e:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    5372:	33 c1       	rjmp	.+614    	; 0x55da <LCD_Printf+0x36e>
			case ';':
				LCD_PrintSymbol(8);
    5374:	88 e0       	ldi	r24, 0x08	; 8
    5376:	90 e0       	ldi	r25, 0x00	; 0
    5378:	0e 94 3c 2d 	call	0x5a78	; 0x5a78 <LCD_PrintSymbol>
				break;
    537c:	2e c1       	rjmp	.+604    	; 0x55da <LCD_Printf+0x36e>
			case '?':
				LCD_PrintBlock();
    537e:	0e 94 8f 2d 	call	0x5b1e	; 0x5b1e <LCD_PrintBlock>
				break;
    5382:	2b c1       	rjmp	.+598    	; 0x55da <LCD_Printf+0x36e>
			case '[':
				LCD_PrintLArrow();
    5384:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <LCD_PrintLArrow>
				break;
    5388:	28 c1       	rjmp	.+592    	; 0x55da <LCD_Printf+0x36e>
			case ']':
				LCD_PrintRArrow();
    538a:	0e 94 a3 2d 	call	0x5b46	; 0x5b46 <LCD_PrintRArrow>
				break;
    538e:	25 c1       	rjmp	.+586    	; 0x55da <LCD_Printf+0x36e>
			case '.':
				LCD_PrintDot();
    5390:	0e 94 ad 2d 	call	0x5b5a	; 0x5b5a <LCD_PrintDot>
				break;
    5394:	22 c1       	rjmp	.+580    	; 0x55da <LCD_Printf+0x36e>
			case 'C':
			case 'c': /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    5396:	8b 89       	ldd	r24, Y+19	; 0x13
    5398:	9c 89       	ldd	r25, Y+20	; 0x14
    539a:	9c 01       	movw	r18, r24
    539c:	2e 5f       	subi	r18, 0xFE	; 254
    539e:	3f 4f       	sbci	r19, 0xFF	; 255
    53a0:	3c 8b       	std	Y+20, r19	; 0x14
    53a2:	2b 8b       	std	Y+19, r18	; 0x13
    53a4:	fc 01       	movw	r30, r24
    53a6:	80 81       	ld	r24, Z
    53a8:	91 81       	ldd	r25, Z+1	; 0x01
    53aa:	89 87       	std	Y+9, r24	; 0x09
				LCD_DisplayChar(ch);
    53ac:	89 85       	ldd	r24, Y+9	; 0x09
    53ae:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
				break;
    53b2:	13 c1       	rjmp	.+550    	; 0x55da <LCD_Printf+0x36e>

			case 'd': /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, int);
    53b4:	8b 89       	ldd	r24, Y+19	; 0x13
    53b6:	9c 89       	ldd	r25, Y+20	; 0x14
    53b8:	9c 01       	movw	r18, r24
    53ba:	2e 5f       	subi	r18, 0xFE	; 254
    53bc:	3f 4f       	sbci	r19, 0xFF	; 255
    53be:	3c 8b       	std	Y+20, r19	; 0x14
    53c0:	2b 8b       	std	Y+19, r18	; 0x13
    53c2:	fc 01       	movw	r30, r24
    53c4:	80 81       	ld	r24, Z
    53c6:	91 81       	ldd	r25, Z+1	; 0x01
    53c8:	9c 83       	std	Y+4, r25	; 0x04
    53ca:	8b 83       	std	Y+3, r24	; 0x03
				if (v_num_s16 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    53cc:	8b 81       	ldd	r24, Y+3	; 0x03
    53ce:	9c 81       	ldd	r25, Y+4	; 0x04
    53d0:	99 23       	and	r25, r25
    53d2:	54 f4       	brge	.+20     	; 0x53e8 <LCD_Printf+0x17c>
					v_num_s16 = -v_num_s16;
    53d4:	8b 81       	ldd	r24, Y+3	; 0x03
    53d6:	9c 81       	ldd	r25, Y+4	; 0x04
    53d8:	91 95       	neg	r25
    53da:	81 95       	neg	r24
    53dc:	91 09       	sbc	r25, r1
    53de:	9c 83       	std	Y+4, r25	; 0x04
    53e0:	8b 83       	std	Y+3, r24	; 0x03
					LCD_DisplayChar('-');
    53e2:	8d e2       	ldi	r24, 0x2D	; 45
    53e4:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
				}
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_s16,
    53e8:	8b 81       	ldd	r24, Y+3	; 0x03
    53ea:	9c 81       	ldd	r25, Y+4	; 0x04
    53ec:	aa 27       	eor	r26, r26
    53ee:	97 fd       	sbrc	r25, 7
    53f0:	a0 95       	com	r26
    53f2:	ba 2f       	mov	r27, r26
    53f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    53f6:	ac 01       	movw	r20, r24
    53f8:	bd 01       	movw	r22, r26
    53fa:	8a e0       	ldi	r24, 0x0A	; 10
    53fc:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    5400:	ec c0       	rjmp	.+472    	; 0x55da <LCD_Printf+0x36e>

			case 'D': /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);
    5402:	8b 89       	ldd	r24, Y+19	; 0x13
    5404:	9c 89       	ldd	r25, Y+20	; 0x14
    5406:	9c 01       	movw	r18, r24
    5408:	2c 5f       	subi	r18, 0xFC	; 252
    540a:	3f 4f       	sbci	r19, 0xFF	; 255
    540c:	3c 8b       	std	Y+20, r19	; 0x14
    540e:	2b 8b       	std	Y+19, r18	; 0x13
    5410:	fc 01       	movw	r30, r24
    5412:	80 81       	ld	r24, Z
    5414:	91 81       	ldd	r25, Z+1	; 0x01
    5416:	a2 81       	ldd	r26, Z+2	; 0x02
    5418:	b3 81       	ldd	r27, Z+3	; 0x03
    541a:	8d 83       	std	Y+5, r24	; 0x05
    541c:	9e 83       	std	Y+6, r25	; 0x06
    541e:	af 83       	std	Y+7, r26	; 0x07
    5420:	b8 87       	std	Y+8, r27	; 0x08
				if (v_num_s32 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    5422:	8d 81       	ldd	r24, Y+5	; 0x05
    5424:	9e 81       	ldd	r25, Y+6	; 0x06
    5426:	af 81       	ldd	r26, Y+7	; 0x07
    5428:	b8 85       	ldd	r27, Y+8	; 0x08
    542a:	bb 23       	and	r27, r27
    542c:	94 f4       	brge	.+36     	; 0x5452 <LCD_Printf+0x1e6>
					v_num_s32 = -v_num_s32;
    542e:	8d 81       	ldd	r24, Y+5	; 0x05
    5430:	9e 81       	ldd	r25, Y+6	; 0x06
    5432:	af 81       	ldd	r26, Y+7	; 0x07
    5434:	b8 85       	ldd	r27, Y+8	; 0x08
    5436:	b0 95       	com	r27
    5438:	a0 95       	com	r26
    543a:	90 95       	com	r25
    543c:	81 95       	neg	r24
    543e:	9f 4f       	sbci	r25, 0xFF	; 255
    5440:	af 4f       	sbci	r26, 0xFF	; 255
    5442:	bf 4f       	sbci	r27, 0xFF	; 255
    5444:	8d 83       	std	Y+5, r24	; 0x05
    5446:	9e 83       	std	Y+6, r25	; 0x06
    5448:	af 83       	std	Y+7, r26	; 0x07
    544a:	b8 87       	std	Y+8, r27	; 0x08
					LCD_DisplayChar('-');
    544c:	8d e2       	ldi	r24, 0x2D	; 45
    544e:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
				}
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_s32,
    5452:	8d 81       	ldd	r24, Y+5	; 0x05
    5454:	9e 81       	ldd	r25, Y+6	; 0x06
    5456:	af 81       	ldd	r26, Y+7	; 0x07
    5458:	b8 85       	ldd	r27, Y+8	; 0x08
    545a:	2a 85       	ldd	r18, Y+10	; 0x0a
    545c:	ac 01       	movw	r20, r24
    545e:	bd 01       	movw	r22, r26
    5460:	8a e0       	ldi	r24, 0x0A	; 10
    5462:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    5466:	b9 c0       	rjmp	.+370    	; 0x55da <LCD_Printf+0x36e>

			case 'u': /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, int);
    5468:	8b 89       	ldd	r24, Y+19	; 0x13
    546a:	9c 89       	ldd	r25, Y+20	; 0x14
    546c:	9c 01       	movw	r18, r24
    546e:	2e 5f       	subi	r18, 0xFE	; 254
    5470:	3f 4f       	sbci	r19, 0xFF	; 255
    5472:	3c 8b       	std	Y+20, r19	; 0x14
    5474:	2b 8b       	std	Y+19, r18	; 0x13
    5476:	fc 01       	movw	r30, r24
    5478:	80 81       	ld	r24, Z
    547a:	91 81       	ldd	r25, Z+1	; 0x01
    547c:	9c 87       	std	Y+12, r25	; 0x0c
    547e:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_u16,
    5480:	8b 85       	ldd	r24, Y+11	; 0x0b
    5482:	9c 85       	ldd	r25, Y+12	; 0x0c
    5484:	cc 01       	movw	r24, r24
    5486:	a0 e0       	ldi	r26, 0x00	; 0
    5488:	b0 e0       	ldi	r27, 0x00	; 0
    548a:	2a 85       	ldd	r18, Y+10	; 0x0a
    548c:	ac 01       	movw	r20, r24
    548e:	bd 01       	movw	r22, r26
    5490:	8a e0       	ldi	r24, 0x0A	; 10
    5492:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    5496:	a1 c0       	rjmp	.+322    	; 0x55da <LCD_Printf+0x36e>

			case 'U': /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);
    5498:	8b 89       	ldd	r24, Y+19	; 0x13
    549a:	9c 89       	ldd	r25, Y+20	; 0x14
    549c:	9c 01       	movw	r18, r24
    549e:	2c 5f       	subi	r18, 0xFC	; 252
    54a0:	3f 4f       	sbci	r19, 0xFF	; 255
    54a2:	3c 8b       	std	Y+20, r19	; 0x14
    54a4:	2b 8b       	std	Y+19, r18	; 0x13
    54a6:	fc 01       	movw	r30, r24
    54a8:	80 81       	ld	r24, Z
    54aa:	91 81       	ldd	r25, Z+1	; 0x01
    54ac:	a2 81       	ldd	r26, Z+2	; 0x02
    54ae:	b3 81       	ldd	r27, Z+3	; 0x03
    54b0:	8d 87       	std	Y+13, r24	; 0x0d
    54b2:	9e 87       	std	Y+14, r25	; 0x0e
    54b4:	af 87       	std	Y+15, r26	; 0x0f
    54b6:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_u32,
    54b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    54ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    54bc:	af 85       	ldd	r26, Y+15	; 0x0f
    54be:	b8 89       	ldd	r27, Y+16	; 0x10
    54c0:	2a 85       	ldd	r18, Y+10	; 0x0a
    54c2:	ac 01       	movw	r20, r24
    54c4:	bd 01       	movw	r22, r26
    54c6:	8a e0       	ldi	r24, 0x0A	; 10
    54c8:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    54cc:	86 c0       	rjmp	.+268    	; 0x55da <LCD_Printf+0x36e>

			case 'x': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, int);
    54ce:	8b 89       	ldd	r24, Y+19	; 0x13
    54d0:	9c 89       	ldd	r25, Y+20	; 0x14
    54d2:	9c 01       	movw	r18, r24
    54d4:	2e 5f       	subi	r18, 0xFE	; 254
    54d6:	3f 4f       	sbci	r19, 0xFF	; 255
    54d8:	3c 8b       	std	Y+20, r19	; 0x14
    54da:	2b 8b       	std	Y+19, r18	; 0x13
    54dc:	fc 01       	movw	r30, r24
    54de:	80 81       	ld	r24, Z
    54e0:	91 81       	ldd	r25, Z+1	; 0x01
    54e2:	9c 87       	std	Y+12, r25	; 0x0c
    54e4:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumber(C_HEX_U8, v_num_u16, v_numOfDigitsToDisp_u8);
    54e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    54e8:	9c 85       	ldd	r25, Y+12	; 0x0c
    54ea:	cc 01       	movw	r24, r24
    54ec:	a0 e0       	ldi	r26, 0x00	; 0
    54ee:	b0 e0       	ldi	r27, 0x00	; 0
    54f0:	2a 85       	ldd	r18, Y+10	; 0x0a
    54f2:	ac 01       	movw	r20, r24
    54f4:	bd 01       	movw	r22, r26
    54f6:	80 e1       	ldi	r24, 0x10	; 16
    54f8:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
				break;
    54fc:	6e c0       	rjmp	.+220    	; 0x55da <LCD_Printf+0x36e>

			case 'X': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);
    54fe:	8b 89       	ldd	r24, Y+19	; 0x13
    5500:	9c 89       	ldd	r25, Y+20	; 0x14
    5502:	9c 01       	movw	r18, r24
    5504:	2c 5f       	subi	r18, 0xFC	; 252
    5506:	3f 4f       	sbci	r19, 0xFF	; 255
    5508:	3c 8b       	std	Y+20, r19	; 0x14
    550a:	2b 8b       	std	Y+19, r18	; 0x13
    550c:	fc 01       	movw	r30, r24
    550e:	80 81       	ld	r24, Z
    5510:	91 81       	ldd	r25, Z+1	; 0x01
    5512:	a2 81       	ldd	r26, Z+2	; 0x02
    5514:	b3 81       	ldd	r27, Z+3	; 0x03
    5516:	8d 87       	std	Y+13, r24	; 0x0d
    5518:	9e 87       	std	Y+14, r25	; 0x0e
    551a:	af 87       	std	Y+15, r26	; 0x0f
    551c:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumber(C_HEX_U8, v_num_u32, v_numOfDigitsToDisp_u8);
    551e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5520:	9e 85       	ldd	r25, Y+14	; 0x0e
    5522:	af 85       	ldd	r26, Y+15	; 0x0f
    5524:	b8 89       	ldd	r27, Y+16	; 0x10
    5526:	2a 85       	ldd	r18, Y+10	; 0x0a
    5528:	ac 01       	movw	r20, r24
    552a:	bd 01       	movw	r22, r26
    552c:	80 e1       	ldi	r24, 0x10	; 16
    552e:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
				break;
    5532:	53 c0       	rjmp	.+166    	; 0x55da <LCD_Printf+0x36e>

			case 'b': /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, int);
    5534:	8b 89       	ldd	r24, Y+19	; 0x13
    5536:	9c 89       	ldd	r25, Y+20	; 0x14
    5538:	9c 01       	movw	r18, r24
    553a:	2e 5f       	subi	r18, 0xFE	; 254
    553c:	3f 4f       	sbci	r19, 0xFF	; 255
    553e:	3c 8b       	std	Y+20, r19	; 0x14
    5540:	2b 8b       	std	Y+19, r18	; 0x13
    5542:	fc 01       	movw	r30, r24
    5544:	80 81       	ld	r24, Z
    5546:	91 81       	ldd	r25, Z+1	; 0x01
    5548:	9c 87       	std	Y+12, r25	; 0x0c
    554a:	8b 87       	std	Y+11, r24	; 0x0b
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    554c:	8a 85       	ldd	r24, Y+10	; 0x0a
    554e:	8f 3f       	cpi	r24, 0xFF	; 255
    5550:	11 f4       	brne	.+4      	; 0x5556 <LCD_Printf+0x2ea>
					v_numOfDigitsToDisp_u8 = 16;
    5552:	80 e1       	ldi	r24, 0x10	; 16
    5554:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumber(C_BINARY_U8, v_num_u16,
    5556:	8b 85       	ldd	r24, Y+11	; 0x0b
    5558:	9c 85       	ldd	r25, Y+12	; 0x0c
    555a:	cc 01       	movw	r24, r24
    555c:	a0 e0       	ldi	r26, 0x00	; 0
    555e:	b0 e0       	ldi	r27, 0x00	; 0
    5560:	2a 85       	ldd	r18, Y+10	; 0x0a
    5562:	ac 01       	movw	r20, r24
    5564:	bd 01       	movw	r22, r26
    5566:	82 e0       	ldi	r24, 0x02	; 2
    5568:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    556c:	36 c0       	rjmp	.+108    	; 0x55da <LCD_Printf+0x36e>

			case 'B': /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);
    556e:	8b 89       	ldd	r24, Y+19	; 0x13
    5570:	9c 89       	ldd	r25, Y+20	; 0x14
    5572:	9c 01       	movw	r18, r24
    5574:	2c 5f       	subi	r18, 0xFC	; 252
    5576:	3f 4f       	sbci	r19, 0xFF	; 255
    5578:	3c 8b       	std	Y+20, r19	; 0x14
    557a:	2b 8b       	std	Y+19, r18	; 0x13
    557c:	fc 01       	movw	r30, r24
    557e:	80 81       	ld	r24, Z
    5580:	91 81       	ldd	r25, Z+1	; 0x01
    5582:	a2 81       	ldd	r26, Z+2	; 0x02
    5584:	b3 81       	ldd	r27, Z+3	; 0x03
    5586:	8d 87       	std	Y+13, r24	; 0x0d
    5588:	9e 87       	std	Y+14, r25	; 0x0e
    558a:	af 87       	std	Y+15, r26	; 0x0f
    558c:	b8 8b       	std	Y+16, r27	; 0x10
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    558e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5590:	8f 3f       	cpi	r24, 0xFF	; 255
    5592:	11 f4       	brne	.+4      	; 0x5598 <LCD_Printf+0x32c>
					v_numOfDigitsToDisp_u8 = 16;
    5594:	80 e1       	ldi	r24, 0x10	; 16
    5596:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumber(C_BINARY_U8, v_num_u32,
    5598:	8d 85       	ldd	r24, Y+13	; 0x0d
    559a:	9e 85       	ldd	r25, Y+14	; 0x0e
    559c:	af 85       	ldd	r26, Y+15	; 0x0f
    559e:	b8 89       	ldd	r27, Y+16	; 0x10
    55a0:	2a 85       	ldd	r18, Y+10	; 0x0a
    55a2:	ac 01       	movw	r20, r24
    55a4:	bd 01       	movw	r22, r26
    55a6:	82 e0       	ldi	r24, 0x02	; 2
    55a8:	0e 94 47 23 	call	0x468e	; 0x468e <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    55ac:	16 c0       	rjmp	.+44     	; 0x55da <LCD_Printf+0x36e>
#endif
				break;

			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char*);
    55ae:	8b 89       	ldd	r24, Y+19	; 0x13
    55b0:	9c 89       	ldd	r25, Y+20	; 0x14
    55b2:	9c 01       	movw	r18, r24
    55b4:	2e 5f       	subi	r18, 0xFE	; 254
    55b6:	3f 4f       	sbci	r19, 0xFF	; 255
    55b8:	3c 8b       	std	Y+20, r19	; 0x14
    55ba:	2b 8b       	std	Y+19, r18	; 0x13
    55bc:	fc 01       	movw	r30, r24
    55be:	80 81       	ld	r24, Z
    55c0:	91 81       	ldd	r25, Z+1	; 0x01
    55c2:	9a 8b       	std	Y+18, r25	; 0x12
    55c4:	89 8b       	std	Y+17, r24	; 0x11
				LCD_DisplayString(str);
    55c6:	89 89       	ldd	r24, Y+17	; 0x11
    55c8:	9a 89       	ldd	r25, Y+18	; 0x12
    55ca:	0e 94 66 20 	call	0x40cc	; 0x40cc <LCD_DisplayString>
				break;
    55ce:	05 c0       	rjmp	.+10     	; 0x55da <LCD_Printf+0x36e>

			case '%':
				LCD_DisplayChar('%');
    55d0:	85 e2       	ldi	r24, 0x25	; 37
    55d2:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
				break;
    55d6:	01 c0       	rjmp	.+2      	; 0x55da <LCD_Printf+0x36e>
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)
                v_floatNum_f32 = va_arg(argp, double);
                LCD_DisplayFloatNumber(v_floatNum_f32);
#endif
				break;
    55d8:	00 00       	nop
    55da:	03 c0       	rjmp	.+6      	; 0x55e2 <LCD_Printf+0x376>
				LCD_DisplayChar('%');
				break;
			}
		} else {
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
    55dc:	89 85       	ldd	r24, Y+9	; 0x09
    55de:	0e 94 46 20 	call	0x408c	; 0x408c <LCD_DisplayChar>
#endif

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    55e2:	89 81       	ldd	r24, Y+1	; 0x01
    55e4:	9a 81       	ldd	r25, Y+2	; 0x02
    55e6:	01 96       	adiw	r24, 0x01	; 1
    55e8:	9a 83       	std	Y+2, r25	; 0x02
    55ea:	89 83       	std	Y+1, r24	; 0x01
    55ec:	89 81       	ldd	r24, Y+1	; 0x01
    55ee:	9a 81       	ldd	r25, Y+2	; 0x02
    55f0:	fc 01       	movw	r30, r24
    55f2:	80 81       	ld	r24, Z
    55f4:	88 23       	and	r24, r24
    55f6:	09 f0       	breq	.+2      	; 0x55fa <LCD_Printf+0x38e>
    55f8:	4c ce       	rjmp	.-872    	; 0x5292 <LCD_Printf+0x26>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
    55fa:	64 96       	adiw	r28, 0x14	; 20
    55fc:	0f b6       	in	r0, 0x3f	; 63
    55fe:	f8 94       	cli
    5600:	de bf       	out	0x3e, r29	; 62
    5602:	0f be       	out	0x3f, r0	; 63
    5604:	cd bf       	out	0x3d, r28	; 61
    5606:	df 91       	pop	r29
    5608:	cf 91       	pop	r28
    560a:	08 95       	ret

0000560c <lcd_DataWrite>:
 * I/P Arguments: uint8_t: 8-bit value to be sent to LCD.
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .    
 **************************************************************************************************/
static void lcd_DataWrite(uint8_t dataByte) {
    560c:	cf 93       	push	r28
    560e:	df 93       	push	r29
    5610:	1f 92       	push	r1
    5612:	cd b7       	in	r28, 0x3d	; 61
    5614:	de b7       	in	r29, 0x3e	; 62
    5616:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    5618:	0e 94 4a 2b 	call	0x5694	; 0x5694 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    561c:	80 91 a6 02 	lds	r24, 0x02A6
    5620:	88 30       	cpi	r24, 0x08	; 8
    5622:	21 f4       	brne	.+8      	; 0x562c <lcd_DataWrite+0x20>
		lcd_SendLowerNibble(dataByte);
    5624:	89 81       	ldd	r24, Y+1	; 0x01
    5626:	0e 94 0d 2c 	call	0x581a	; 0x581a <lcd_SendLowerNibble>
    562a:	09 c0       	rjmp	.+18     	; 0x563e <lcd_DataWrite+0x32>
	} else {
		lcd_SendHigherNibble(dataByte);
    562c:	89 81       	ldd	r24, Y+1	; 0x01
    562e:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
		lcd_SendDataSignals();
    5632:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <lcd_SendDataSignals>
		dataByte = dataByte << 4;
    5636:	89 81       	ldd	r24, Y+1	; 0x01
    5638:	82 95       	swap	r24
    563a:	80 7f       	andi	r24, 0xF0	; 240
    563c:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(dataByte);
    563e:	89 81       	ldd	r24, Y+1	; 0x01
    5640:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
	lcd_SendDataSignals();
    5644:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <lcd_SendDataSignals>
}
    5648:	0f 90       	pop	r0
    564a:	df 91       	pop	r29
    564c:	cf 91       	pop	r28
    564e:	08 95       	ret

00005650 <LCD_DataWrite>:
 * I/P Arguments: uint8_t: 8-bit value to be sent to LCD.
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .
 **************************************************************************************************/
void LCD_DataWrite(uint8_t dataByte) {
    5650:	cf 93       	push	r28
    5652:	df 93       	push	r29
    5654:	1f 92       	push	r1
    5656:	cd b7       	in	r28, 0x3d	; 61
    5658:	de b7       	in	r29, 0x3e	; 62
    565a:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    565c:	0e 94 4a 2b 	call	0x5694	; 0x5694 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    5660:	80 91 a6 02 	lds	r24, 0x02A6
    5664:	88 30       	cpi	r24, 0x08	; 8
    5666:	21 f4       	brne	.+8      	; 0x5670 <LCD_DataWrite+0x20>
		lcd_SendLowerNibble(dataByte);
    5668:	89 81       	ldd	r24, Y+1	; 0x01
    566a:	0e 94 0d 2c 	call	0x581a	; 0x581a <lcd_SendLowerNibble>
    566e:	09 c0       	rjmp	.+18     	; 0x5682 <LCD_DataWrite+0x32>
	} else {
		lcd_SendHigherNibble(dataByte);
    5670:	89 81       	ldd	r24, Y+1	; 0x01
    5672:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
		lcd_SendDataSignals();
    5676:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <lcd_SendDataSignals>
		dataByte = dataByte << 4;
    567a:	89 81       	ldd	r24, Y+1	; 0x01
    567c:	82 95       	swap	r24
    567e:	80 7f       	andi	r24, 0xF0	; 240
    5680:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(dataByte);
    5682:	89 81       	ldd	r24, Y+1	; 0x01
    5684:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
	lcd_SendDataSignals();
    5688:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <lcd_SendDataSignals>
}
    568c:	0f 90       	pop	r0
    568e:	df 91       	pop	r29
    5690:	cf 91       	pop	r28
    5692:	08 95       	ret

00005694 <lcd_BusyCheck>:

 * description : This functions is used check whether LCD is busy.
 It waits till the LCD is busy by polling the LCD busy flag.
 After completing the previous operation, LCDs clears its internal busy flag.
 **************************************************************************************************/
static void lcd_BusyCheck(void) {
    5694:	cf 93       	push	r28
    5696:	df 93       	push	r29
    5698:	1f 92       	push	r1
    569a:	cd b7       	in	r28, 0x3d	; 61
    569c:	de b7       	in	r29, 0x3e	; 62
	uint8_t busyflag;

	if (LCDConfig.RW != P_NC)             //Perform Busy check if RW pin is used
    569e:	80 91 a8 02 	lds	r24, 0x02A8
    56a2:	8f 3f       	cpi	r24, 0xFF	; 255
    56a4:	09 f4       	brne	.+2      	; 0x56a8 <lcd_BusyCheck+0x14>
    56a6:	45 c0       	rjmp	.+138    	; 0x5732 <lcd_BusyCheck+0x9e>
			{
		GPIO_PinDirection(LCDConfig.D7, INPUT); // Configure busy pin as input
    56a8:	80 91 b1 02 	lds	r24, 0x02B1
    56ac:	60 e0       	ldi	r22, 0x00	; 0
    56ae:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
		GPIO_PinWrite(LCDConfig.RS, 0); // Select the Command Register by pulling RS LOW
    56b2:	80 91 a7 02 	lds	r24, 0x02A7
    56b6:	60 e0       	ldi	r22, 0x00	; 0
    56b8:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
		GPIO_PinWrite(LCDConfig.RW, 1); // Select the Read Operation for busy flag by setting RW
    56bc:	80 91 a8 02 	lds	r24, 0x02A8
    56c0:	61 e0       	ldi	r22, 0x01	; 1
    56c2:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
		do {

			GPIO_PinWrite(LCDConfig.EN, 0);
    56c6:	80 91 a9 02 	lds	r24, 0x02A9
    56ca:	60 e0       	ldi	r22, 0x00	; 0
    56cc:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
			DELAY_us(10);
    56d0:	8a e0       	ldi	r24, 0x0A	; 10
    56d2:	90 e0       	ldi	r25, 0x00	; 0
    56d4:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
			GPIO_PinWrite(LCDConfig.EN, 1);
    56d8:	80 91 a9 02 	lds	r24, 0x02A9
    56dc:	61 e0       	ldi	r22, 0x01	; 1
    56de:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
			DELAY_us(10);
    56e2:	8a e0       	ldi	r24, 0x0A	; 10
    56e4:	90 e0       	ldi	r25, 0x00	; 0
    56e6:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
			busyflag = GPIO_PinRead(LCDConfig.D7);
    56ea:	80 91 b1 02 	lds	r24, 0x02B1
    56ee:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <GPIO_PinRead>
    56f2:	89 83       	std	Y+1, r24	; 0x01

			if (LCDConfig.v_LcdMode_U8 == 4) {
    56f4:	80 91 a6 02 	lds	r24, 0x02A6
    56f8:	84 30       	cpi	r24, 0x04	; 4
    56fa:	91 f4       	brne	.+36     	; 0x5720 <lcd_BusyCheck+0x8c>
				/* Perform extra dummy read for 4-bit */
				GPIO_PinWrite(LCDConfig.EN, 0);
    56fc:	80 91 a9 02 	lds	r24, 0x02A9
    5700:	60 e0       	ldi	r22, 0x00	; 0
    5702:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
				DELAY_us(10);
    5706:	8a e0       	ldi	r24, 0x0A	; 10
    5708:	90 e0       	ldi	r25, 0x00	; 0
    570a:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
				GPIO_PinWrite(LCDConfig.EN, 1);
    570e:	80 91 a9 02 	lds	r24, 0x02A9
    5712:	61 e0       	ldi	r22, 0x01	; 1
    5714:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
				DELAY_us(10);
    5718:	8a e0       	ldi	r24, 0x0A	; 10
    571a:	90 e0       	ldi	r25, 0x00	; 0
    571c:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
			}
		} while (busyflag != 0);
    5720:	89 81       	ldd	r24, Y+1	; 0x01
    5722:	88 23       	and	r24, r24
    5724:	81 f6       	brne	.-96     	; 0x56c6 <lcd_BusyCheck+0x32>

		GPIO_PinDirection(LCDConfig.D7, OUTPUT); // Configure busy pin as Output
    5726:	80 91 b1 02 	lds	r24, 0x02B1
    572a:	61 e0       	ldi	r22, 0x01	; 1
    572c:	0e 94 99 1c 	call	0x3932	; 0x3932 <GPIO_PinDirection>
    5730:	04 c0       	rjmp	.+8      	; 0x573a <lcd_BusyCheck+0xa6>
	} else {
		/* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added
		 to ensure the LCD completes previous operation and ready to receive new commands/data */
		DELAY_ms(1);
    5732:	81 e0       	ldi	r24, 0x01	; 1
    5734:	90 e0       	ldi	r25, 0x00	; 0
    5736:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	}
}
    573a:	0f 90       	pop	r0
    573c:	df 91       	pop	r29
    573e:	cf 91       	pop	r28
    5740:	08 95       	ret

00005742 <lcd_Reset>:
 * Return value    : none

 * description : This functions is used to reset the LCD. 
 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
 ----------------------------------------------------------------------------------*/
static void lcd_Reset(void) {
    5742:	cf 93       	push	r28
    5744:	df 93       	push	r29
    5746:	cd b7       	in	r28, 0x3d	; 61
    5748:	de b7       	in	r29, 0x3e	; 62
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendHigherNibble(0x30);
    574a:	80 e3       	ldi	r24, 0x30	; 48
    574c:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    5750:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <lcd_SendCmdSignals>
	DELAY_ms(100);
    5754:	84 e6       	ldi	r24, 0x64	; 100
    5756:	90 e0       	ldi	r25, 0x00	; 0
    5758:	0e 94 ce 1a 	call	0x359c	; 0x359c <DELAY_ms>
	lcd_SendHigherNibble(0x30);
    575c:	80 e3       	ldi	r24, 0x30	; 48
    575e:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    5762:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <lcd_SendCmdSignals>
	DELAY_us(200);
    5766:	88 ec       	ldi	r24, 0xC8	; 200
    5768:	90 e0       	ldi	r25, 0x00	; 0
    576a:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
	lcd_SendHigherNibble(0x30);
    576e:	80 e3       	ldi	r24, 0x30	; 48
    5770:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    5774:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <lcd_SendCmdSignals>
	DELAY_us(200);
    5778:	88 ec       	ldi	r24, 0xC8	; 200
    577a:	90 e0       	ldi	r25, 0x00	; 0
    577c:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
	lcd_SendHigherNibble(0x20);
    5780:	80 e2       	ldi	r24, 0x20	; 32
    5782:	0e 94 cc 2b 	call	0x5798	; 0x5798 <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    5786:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <lcd_SendCmdSignals>
	DELAY_us(200);
    578a:	88 ec       	ldi	r24, 0xC8	; 200
    578c:	90 e0       	ldi	r25, 0x00	; 0
    578e:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
}
    5792:	df 91       	pop	r29
    5794:	cf 91       	pop	r28
    5796:	08 95       	ret

00005798 <lcd_SendHigherNibble>:
 * I/P Arguments: uint8_t: Higher nibble of the data to be send on LCD4-LCD7 data lines
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 **************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte) {
    5798:	cf 93       	push	r28
    579a:	df 93       	push	r29
    579c:	1f 92       	push	r1
    579e:	cd b7       	in	r28, 0x3d	; 61
    57a0:	de b7       	in	r29, 0x3e	; 62
    57a2:	89 83       	std	Y+1, r24	; 0x01
	GPIO_PinWrite(LCDConfig.D4, util_IsBitSet(dataByte, 4));
    57a4:	89 81       	ldd	r24, Y+1	; 0x01
    57a6:	88 2f       	mov	r24, r24
    57a8:	90 e0       	ldi	r25, 0x00	; 0
    57aa:	80 71       	andi	r24, 0x10	; 16
    57ac:	99 27       	eor	r25, r25
    57ae:	21 e0       	ldi	r18, 0x01	; 1
    57b0:	00 97       	sbiw	r24, 0x00	; 0
    57b2:	09 f4       	brne	.+2      	; 0x57b6 <lcd_SendHigherNibble+0x1e>
    57b4:	20 e0       	ldi	r18, 0x00	; 0
    57b6:	92 2f       	mov	r25, r18
    57b8:	80 91 ae 02 	lds	r24, 0x02AE
    57bc:	69 2f       	mov	r22, r25
    57be:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D5, util_IsBitSet(dataByte, 5));
    57c2:	89 81       	ldd	r24, Y+1	; 0x01
    57c4:	88 2f       	mov	r24, r24
    57c6:	90 e0       	ldi	r25, 0x00	; 0
    57c8:	80 72       	andi	r24, 0x20	; 32
    57ca:	99 27       	eor	r25, r25
    57cc:	21 e0       	ldi	r18, 0x01	; 1
    57ce:	00 97       	sbiw	r24, 0x00	; 0
    57d0:	09 f4       	brne	.+2      	; 0x57d4 <lcd_SendHigherNibble+0x3c>
    57d2:	20 e0       	ldi	r18, 0x00	; 0
    57d4:	92 2f       	mov	r25, r18
    57d6:	80 91 af 02 	lds	r24, 0x02AF
    57da:	69 2f       	mov	r22, r25
    57dc:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D6, util_IsBitSet(dataByte, 6));
    57e0:	89 81       	ldd	r24, Y+1	; 0x01
    57e2:	88 2f       	mov	r24, r24
    57e4:	90 e0       	ldi	r25, 0x00	; 0
    57e6:	80 74       	andi	r24, 0x40	; 64
    57e8:	99 27       	eor	r25, r25
    57ea:	21 e0       	ldi	r18, 0x01	; 1
    57ec:	00 97       	sbiw	r24, 0x00	; 0
    57ee:	09 f4       	brne	.+2      	; 0x57f2 <lcd_SendHigherNibble+0x5a>
    57f0:	20 e0       	ldi	r18, 0x00	; 0
    57f2:	92 2f       	mov	r25, r18
    57f4:	80 91 b0 02 	lds	r24, 0x02B0
    57f8:	69 2f       	mov	r22, r25
    57fa:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D7, util_IsBitSet(dataByte, 7));
    57fe:	89 81       	ldd	r24, Y+1	; 0x01
    5800:	88 1f       	adc	r24, r24
    5802:	88 27       	eor	r24, r24
    5804:	88 1f       	adc	r24, r24
    5806:	98 2f       	mov	r25, r24
    5808:	80 91 b1 02 	lds	r24, 0x02B1
    580c:	69 2f       	mov	r22, r25
    580e:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
}
    5812:	0f 90       	pop	r0
    5814:	df 91       	pop	r29
    5816:	cf 91       	pop	r28
    5818:	08 95       	ret

0000581a <lcd_SendLowerNibble>:
 * I/P Arguments: uint8_t: Lower nibble of the data to be send on LCD4-LCD7 data lines
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
 **************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte) {
    581a:	cf 93       	push	r28
    581c:	df 93       	push	r29
    581e:	1f 92       	push	r1
    5820:	cd b7       	in	r28, 0x3d	; 61
    5822:	de b7       	in	r29, 0x3e	; 62
    5824:	89 83       	std	Y+1, r24	; 0x01
	GPIO_PinWrite(LCDConfig.D0, util_IsBitSet(dataByte, 0));
    5826:	89 81       	ldd	r24, Y+1	; 0x01
    5828:	88 2f       	mov	r24, r24
    582a:	90 e0       	ldi	r25, 0x00	; 0
    582c:	81 70       	andi	r24, 0x01	; 1
    582e:	99 27       	eor	r25, r25
    5830:	21 e0       	ldi	r18, 0x01	; 1
    5832:	00 97       	sbiw	r24, 0x00	; 0
    5834:	09 f4       	brne	.+2      	; 0x5838 <lcd_SendLowerNibble+0x1e>
    5836:	20 e0       	ldi	r18, 0x00	; 0
    5838:	92 2f       	mov	r25, r18
    583a:	80 91 aa 02 	lds	r24, 0x02AA
    583e:	69 2f       	mov	r22, r25
    5840:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D1, util_IsBitSet(dataByte, 1));
    5844:	89 81       	ldd	r24, Y+1	; 0x01
    5846:	88 2f       	mov	r24, r24
    5848:	90 e0       	ldi	r25, 0x00	; 0
    584a:	82 70       	andi	r24, 0x02	; 2
    584c:	99 27       	eor	r25, r25
    584e:	21 e0       	ldi	r18, 0x01	; 1
    5850:	00 97       	sbiw	r24, 0x00	; 0
    5852:	09 f4       	brne	.+2      	; 0x5856 <lcd_SendLowerNibble+0x3c>
    5854:	20 e0       	ldi	r18, 0x00	; 0
    5856:	92 2f       	mov	r25, r18
    5858:	80 91 ab 02 	lds	r24, 0x02AB
    585c:	69 2f       	mov	r22, r25
    585e:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D2, util_IsBitSet(dataByte, 2));
    5862:	89 81       	ldd	r24, Y+1	; 0x01
    5864:	88 2f       	mov	r24, r24
    5866:	90 e0       	ldi	r25, 0x00	; 0
    5868:	84 70       	andi	r24, 0x04	; 4
    586a:	99 27       	eor	r25, r25
    586c:	21 e0       	ldi	r18, 0x01	; 1
    586e:	00 97       	sbiw	r24, 0x00	; 0
    5870:	09 f4       	brne	.+2      	; 0x5874 <lcd_SendLowerNibble+0x5a>
    5872:	20 e0       	ldi	r18, 0x00	; 0
    5874:	92 2f       	mov	r25, r18
    5876:	80 91 ac 02 	lds	r24, 0x02AC
    587a:	69 2f       	mov	r22, r25
    587c:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D3, util_IsBitSet(dataByte, 3));
    5880:	89 81       	ldd	r24, Y+1	; 0x01
    5882:	88 2f       	mov	r24, r24
    5884:	90 e0       	ldi	r25, 0x00	; 0
    5886:	88 70       	andi	r24, 0x08	; 8
    5888:	99 27       	eor	r25, r25
    588a:	21 e0       	ldi	r18, 0x01	; 1
    588c:	00 97       	sbiw	r24, 0x00	; 0
    588e:	09 f4       	brne	.+2      	; 0x5892 <lcd_SendLowerNibble+0x78>
    5890:	20 e0       	ldi	r18, 0x00	; 0
    5892:	92 2f       	mov	r25, r18
    5894:	80 91 ad 02 	lds	r24, 0x02AD
    5898:	69 2f       	mov	r22, r25
    589a:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
}
    589e:	0f 90       	pop	r0
    58a0:	df 91       	pop	r29
    58a2:	cf 91       	pop	r28
    58a4:	08 95       	ret

000058a6 <lcd_SendCmdSignals>:
 * I/P Arguments: none
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
 **************************************************************************************************/
static void lcd_SendCmdSignals(void) {
    58a6:	cf 93       	push	r28
    58a8:	df 93       	push	r29
    58aa:	cd b7       	in	r28, 0x3d	; 61
    58ac:	de b7       	in	r29, 0x3e	; 62
	GPIO_PinWrite(LCDConfig.RS, 0);
    58ae:	80 91 a7 02 	lds	r24, 0x02A7
    58b2:	60 e0       	ldi	r22, 0x00	; 0
    58b4:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.RW, 0);
    58b8:	80 91 a8 02 	lds	r24, 0x02A8
    58bc:	60 e0       	ldi	r22, 0x00	; 0
    58be:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.EN, 1);
    58c2:	80 91 a9 02 	lds	r24, 0x02A9
    58c6:	61 e0       	ldi	r22, 0x01	; 1
    58c8:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	DELAY_us(10);
    58cc:	8a e0       	ldi	r24, 0x0A	; 10
    58ce:	90 e0       	ldi	r25, 0x00	; 0
    58d0:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
	GPIO_PinWrite(LCDConfig.EN, 0);
    58d4:	80 91 a9 02 	lds	r24, 0x02A9
    58d8:	60 e0       	ldi	r22, 0x00	; 0
    58da:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>

}
    58de:	df 91       	pop	r29
    58e0:	cf 91       	pop	r28
    58e2:	08 95       	ret

000058e4 <lcd_SendDataSignals>:
 * I/P Arguments: none
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
 **************************************************************************************************/
static void lcd_SendDataSignals(void) {
    58e4:	cf 93       	push	r28
    58e6:	df 93       	push	r29
    58e8:	cd b7       	in	r28, 0x3d	; 61
    58ea:	de b7       	in	r29, 0x3e	; 62
	GPIO_PinWrite(LCDConfig.RS, 1);
    58ec:	80 91 a7 02 	lds	r24, 0x02A7
    58f0:	61 e0       	ldi	r22, 0x01	; 1
    58f2:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.RW, 0);
    58f6:	80 91 a8 02 	lds	r24, 0x02A8
    58fa:	60 e0       	ldi	r22, 0x00	; 0
    58fc:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.EN, 1);
    5900:	80 91 a9 02 	lds	r24, 0x02A9
    5904:	61 e0       	ldi	r22, 0x01	; 1
    5906:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
	DELAY_us(10);
    590a:	8a e0       	ldi	r24, 0x0A	; 10
    590c:	90 e0       	ldi	r25, 0x00	; 0
    590e:	0e 94 bb 19 	call	0x3376	; 0x3376 <DELAY_us>
	GPIO_PinWrite(LCDConfig.EN, 0);
    5912:	80 91 a9 02 	lds	r24, 0x02A9
    5916:	60 e0       	ldi	r22, 0x00	; 0
    5918:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <GPIO_PinWrite>
}
    591c:	df 91       	pop	r29
    591e:	cf 91       	pop	r28
    5920:	08 95       	ret

00005922 <LCD_RefreshScreen>:

void LCD_RefreshScreen(int *clock, int valueToRefresh) {
    5922:	cf 93       	push	r28
    5924:	df 93       	push	r29
    5926:	00 d0       	rcall	.+0      	; 0x5928 <LCD_RefreshScreen+0x6>
    5928:	00 d0       	rcall	.+0      	; 0x592a <LCD_RefreshScreen+0x8>
    592a:	cd b7       	in	r28, 0x3d	; 61
    592c:	de b7       	in	r29, 0x3e	; 62
    592e:	9a 83       	std	Y+2, r25	; 0x02
    5930:	89 83       	std	Y+1, r24	; 0x01
    5932:	7c 83       	std	Y+4, r23	; 0x04
    5934:	6b 83       	std	Y+3, r22	; 0x03
	clock++;
    5936:	89 81       	ldd	r24, Y+1	; 0x01
    5938:	9a 81       	ldd	r25, Y+2	; 0x02
    593a:	02 96       	adiw	r24, 0x02	; 2
    593c:	9a 83       	std	Y+2, r25	; 0x02
    593e:	89 83       	std	Y+1, r24	; 0x01
	if ((*clock) >= valueToRefresh) {
    5940:	89 81       	ldd	r24, Y+1	; 0x01
    5942:	9a 81       	ldd	r25, Y+2	; 0x02
    5944:	fc 01       	movw	r30, r24
    5946:	20 81       	ld	r18, Z
    5948:	31 81       	ldd	r19, Z+1	; 0x01
    594a:	8b 81       	ldd	r24, Y+3	; 0x03
    594c:	9c 81       	ldd	r25, Y+4	; 0x04
    594e:	28 17       	cp	r18, r24
    5950:	39 07       	cpc	r19, r25
    5952:	4c f1       	brlt	.+82     	; 0x59a6 <LCD_RefreshScreen+0x84>
		LCD_XYPrintf(0, 0, LCD_BUFFOR[0]);
    5954:	84 e8       	ldi	r24, 0x84	; 132
    5956:	92 e0       	ldi	r25, 0x02	; 2
    5958:	89 2f       	mov	r24, r25
    595a:	8f 93       	push	r24
    595c:	84 e8       	ldi	r24, 0x84	; 132
    595e:	92 e0       	ldi	r25, 0x02	; 2
    5960:	8f 93       	push	r24
    5962:	1f 92       	push	r1
    5964:	1f 92       	push	r1
    5966:	1f 92       	push	r1
    5968:	1f 92       	push	r1
    596a:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    596e:	0f 90       	pop	r0
    5970:	0f 90       	pop	r0
    5972:	0f 90       	pop	r0
    5974:	0f 90       	pop	r0
    5976:	0f 90       	pop	r0
    5978:	0f 90       	pop	r0
		LCD_XYPrintf(1, 0, LCD_BUFFOR[1]);
    597a:	84 e9       	ldi	r24, 0x94	; 148
    597c:	92 e0       	ldi	r25, 0x02	; 2
    597e:	89 2f       	mov	r24, r25
    5980:	8f 93       	push	r24
    5982:	84 e9       	ldi	r24, 0x94	; 148
    5984:	92 e0       	ldi	r25, 0x02	; 2
    5986:	8f 93       	push	r24
    5988:	1f 92       	push	r1
    598a:	1f 92       	push	r1
    598c:	1f 92       	push	r1
    598e:	81 e0       	ldi	r24, 0x01	; 1
    5990:	8f 93       	push	r24
    5992:	0e 94 a1 25 	call	0x4b42	; 0x4b42 <LCD_XYPrintf>
    5996:	0f 90       	pop	r0
    5998:	0f 90       	pop	r0
    599a:	0f 90       	pop	r0
    599c:	0f 90       	pop	r0
    599e:	0f 90       	pop	r0
    59a0:	0f 90       	pop	r0
		clock = 0;
    59a2:	1a 82       	std	Y+2, r1	; 0x02
    59a4:	19 82       	std	Y+1, r1	; 0x01
	}
}
    59a6:	0f 90       	pop	r0
    59a8:	0f 90       	pop	r0
    59aa:	0f 90       	pop	r0
    59ac:	0f 90       	pop	r0
    59ae:	df 91       	pop	r29
    59b0:	cf 91       	pop	r28
    59b2:	08 95       	ret

000059b4 <LCD_InitializeSymbols>:

void LCD_InitializeSymbols() {
    59b4:	cf 93       	push	r28
    59b6:	df 93       	push	r29
    59b8:	cd b7       	in	r28, 0x3d	; 61
    59ba:	de b7       	in	r29, 0x3e	; 62
    59bc:	cc 54       	subi	r28, 0x4C	; 76
    59be:	d1 09       	sbc	r29, r1
    59c0:	0f b6       	in	r0, 0x3f	; 63
    59c2:	f8 94       	cli
    59c4:	de bf       	out	0x3e, r29	; 62
    59c6:	0f be       	out	0x3f, r0	; 63
    59c8:	cd bf       	out	0x3d, r28	; 61
	/*
	 *  To generate new hex code of characters use page "https://maxpromer.github.io/LCD-Character-Creator/"
	 */
	uint8_t addresses[8] = { 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78 };
    59ca:	88 e0       	ldi	r24, 0x08	; 8
    59cc:	eb e3       	ldi	r30, 0x3B	; 59
    59ce:	f2 e0       	ldi	r31, 0x02	; 2
    59d0:	de 01       	movw	r26, r28
    59d2:	15 96       	adiw	r26, 0x05	; 5
    59d4:	01 90       	ld	r0, Z+
    59d6:	0d 92       	st	X+, r0
    59d8:	8a 95       	dec	r24
    59da:	e1 f7       	brne	.-8      	; 0x59d4 <LCD_InitializeSymbols+0x20>

	uint8_t symbols[8][8] = {
    59dc:	80 e4       	ldi	r24, 0x40	; 64
    59de:	e3 e4       	ldi	r30, 0x43	; 67
    59e0:	f2 e0       	ldi	r31, 0x02	; 2
    59e2:	de 01       	movw	r26, r28
    59e4:	1d 96       	adiw	r26, 0x0d	; 13
    59e6:	01 90       	ld	r0, Z+
    59e8:	0d 92       	st	X+, r0
    59ea:	8a 95       	dec	r24
    59ec:	e1 f7       	brne	.-8      	; 0x59e6 <LCD_InitializeSymbols+0x32>
			//7 character (padlock) ':'
			{ 0x0E, 0x11, 0x11, 0x11, 0x1F, 0x1B, 0x1B, 0x1F },
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
    59ee:	1a 82       	std	Y+2, r1	; 0x02
    59f0:	19 82       	std	Y+1, r1	; 0x01
    59f2:	33 c0       	rjmp	.+102    	; 0x5a5a <LCD_InitializeSymbols+0xa6>
		LCD_CmdWrite(addresses[clkAddress]);
    59f4:	9e 01       	movw	r18, r28
    59f6:	2b 5f       	subi	r18, 0xFB	; 251
    59f8:	3f 4f       	sbci	r19, 0xFF	; 255
    59fa:	89 81       	ldd	r24, Y+1	; 0x01
    59fc:	9a 81       	ldd	r25, Y+2	; 0x02
    59fe:	82 0f       	add	r24, r18
    5a00:	93 1f       	adc	r25, r19
    5a02:	fc 01       	movw	r30, r24
    5a04:	80 81       	ld	r24, Z
    5a06:	0e 94 24 20 	call	0x4048	; 0x4048 <LCD_CmdWrite>
		for (int clkData = 0; clkData < 8; clkData++) {
    5a0a:	1c 82       	std	Y+4, r1	; 0x04
    5a0c:	1b 82       	std	Y+3, r1	; 0x03
    5a0e:	1b c0       	rjmp	.+54     	; 0x5a46 <LCD_InitializeSymbols+0x92>
			LCD_DataWrite(symbols[clkAddress][clkData]);
    5a10:	89 81       	ldd	r24, Y+1	; 0x01
    5a12:	9a 81       	ldd	r25, Y+2	; 0x02
    5a14:	88 0f       	add	r24, r24
    5a16:	99 1f       	adc	r25, r25
    5a18:	88 0f       	add	r24, r24
    5a1a:	99 1f       	adc	r25, r25
    5a1c:	88 0f       	add	r24, r24
    5a1e:	99 1f       	adc	r25, r25
    5a20:	9e 01       	movw	r18, r28
    5a22:	2f 5f       	subi	r18, 0xFF	; 255
    5a24:	3f 4f       	sbci	r19, 0xFF	; 255
    5a26:	28 0f       	add	r18, r24
    5a28:	39 1f       	adc	r19, r25
    5a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    5a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    5a2e:	82 0f       	add	r24, r18
    5a30:	93 1f       	adc	r25, r19
    5a32:	0c 96       	adiw	r24, 0x0c	; 12
    5a34:	fc 01       	movw	r30, r24
    5a36:	80 81       	ld	r24, Z
    5a38:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
		LCD_CmdWrite(addresses[clkAddress]);
		for (int clkData = 0; clkData < 8; clkData++) {
    5a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a40:	01 96       	adiw	r24, 0x01	; 1
    5a42:	9c 83       	std	Y+4, r25	; 0x04
    5a44:	8b 83       	std	Y+3, r24	; 0x03
    5a46:	8b 81       	ldd	r24, Y+3	; 0x03
    5a48:	9c 81       	ldd	r25, Y+4	; 0x04
    5a4a:	88 30       	cpi	r24, 0x08	; 8
    5a4c:	91 05       	cpc	r25, r1
    5a4e:	04 f3       	brlt	.-64     	; 0x5a10 <LCD_InitializeSymbols+0x5c>
			//7 character (padlock) ':'
			{ 0x0E, 0x11, 0x11, 0x11, 0x1F, 0x1B, 0x1B, 0x1F },
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
    5a50:	89 81       	ldd	r24, Y+1	; 0x01
    5a52:	9a 81       	ldd	r25, Y+2	; 0x02
    5a54:	01 96       	adiw	r24, 0x01	; 1
    5a56:	9a 83       	std	Y+2, r25	; 0x02
    5a58:	89 83       	std	Y+1, r24	; 0x01
    5a5a:	89 81       	ldd	r24, Y+1	; 0x01
    5a5c:	9a 81       	ldd	r25, Y+2	; 0x02
    5a5e:	88 30       	cpi	r24, 0x08	; 8
    5a60:	91 05       	cpc	r25, r1
    5a62:	44 f2       	brlt	.-112    	; 0x59f4 <LCD_InitializeSymbols+0x40>
		LCD_CmdWrite(addresses[clkAddress]);
		for (int clkData = 0; clkData < 8; clkData++) {
			LCD_DataWrite(symbols[clkAddress][clkData]);
		}
	}
}
    5a64:	c4 5b       	subi	r28, 0xB4	; 180
    5a66:	df 4f       	sbci	r29, 0xFF	; 255
    5a68:	0f b6       	in	r0, 0x3f	; 63
    5a6a:	f8 94       	cli
    5a6c:	de bf       	out	0x3e, r29	; 62
    5a6e:	0f be       	out	0x3f, r0	; 63
    5a70:	cd bf       	out	0x3d, r28	; 61
    5a72:	df 91       	pop	r29
    5a74:	cf 91       	pop	r28
    5a76:	08 95       	ret

00005a78 <LCD_PrintSymbol>:

void LCD_PrintSymbol(int number) {
    5a78:	cf 93       	push	r28
    5a7a:	df 93       	push	r29
    5a7c:	00 d0       	rcall	.+0      	; 0x5a7e <LCD_PrintSymbol+0x6>
    5a7e:	cd b7       	in	r28, 0x3d	; 61
    5a80:	de b7       	in	r29, 0x3e	; 62
    5a82:	9a 83       	std	Y+2, r25	; 0x02
    5a84:	89 83       	std	Y+1, r24	; 0x01
	if (number == 1)
    5a86:	89 81       	ldd	r24, Y+1	; 0x01
    5a88:	9a 81       	ldd	r25, Y+2	; 0x02
    5a8a:	81 30       	cpi	r24, 0x01	; 1
    5a8c:	91 05       	cpc	r25, r1
    5a8e:	21 f4       	brne	.+8      	; 0x5a98 <LCD_PrintSymbol+0x20>
		LCD_DataWrite(0x00);
    5a90:	80 e0       	ldi	r24, 0x00	; 0
    5a92:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
    5a96:	3e c0       	rjmp	.+124    	; 0x5b14 <LCD_PrintSymbol+0x9c>
	else if (number == 2)
    5a98:	89 81       	ldd	r24, Y+1	; 0x01
    5a9a:	9a 81       	ldd	r25, Y+2	; 0x02
    5a9c:	82 30       	cpi	r24, 0x02	; 2
    5a9e:	91 05       	cpc	r25, r1
    5aa0:	21 f4       	brne	.+8      	; 0x5aaa <LCD_PrintSymbol+0x32>
		LCD_DataWrite(0x01);
    5aa2:	81 e0       	ldi	r24, 0x01	; 1
    5aa4:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
    5aa8:	35 c0       	rjmp	.+106    	; 0x5b14 <LCD_PrintSymbol+0x9c>
	else if (number == 3)
    5aaa:	89 81       	ldd	r24, Y+1	; 0x01
    5aac:	9a 81       	ldd	r25, Y+2	; 0x02
    5aae:	83 30       	cpi	r24, 0x03	; 3
    5ab0:	91 05       	cpc	r25, r1
    5ab2:	21 f4       	brne	.+8      	; 0x5abc <LCD_PrintSymbol+0x44>
		LCD_DataWrite(0x02);
    5ab4:	82 e0       	ldi	r24, 0x02	; 2
    5ab6:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
    5aba:	2c c0       	rjmp	.+88     	; 0x5b14 <LCD_PrintSymbol+0x9c>
	else if (number == 4)
    5abc:	89 81       	ldd	r24, Y+1	; 0x01
    5abe:	9a 81       	ldd	r25, Y+2	; 0x02
    5ac0:	84 30       	cpi	r24, 0x04	; 4
    5ac2:	91 05       	cpc	r25, r1
    5ac4:	21 f4       	brne	.+8      	; 0x5ace <LCD_PrintSymbol+0x56>
		LCD_DataWrite(0x03);
    5ac6:	83 e0       	ldi	r24, 0x03	; 3
    5ac8:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
    5acc:	23 c0       	rjmp	.+70     	; 0x5b14 <LCD_PrintSymbol+0x9c>
	else if (number == 5)
    5ace:	89 81       	ldd	r24, Y+1	; 0x01
    5ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    5ad2:	85 30       	cpi	r24, 0x05	; 5
    5ad4:	91 05       	cpc	r25, r1
    5ad6:	21 f4       	brne	.+8      	; 0x5ae0 <LCD_PrintSymbol+0x68>
		LCD_DataWrite(0x04);
    5ad8:	84 e0       	ldi	r24, 0x04	; 4
    5ada:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
    5ade:	1a c0       	rjmp	.+52     	; 0x5b14 <LCD_PrintSymbol+0x9c>
	else if (number == 6)
    5ae0:	89 81       	ldd	r24, Y+1	; 0x01
    5ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    5ae4:	86 30       	cpi	r24, 0x06	; 6
    5ae6:	91 05       	cpc	r25, r1
    5ae8:	21 f4       	brne	.+8      	; 0x5af2 <LCD_PrintSymbol+0x7a>
		LCD_DataWrite(0x05);
    5aea:	85 e0       	ldi	r24, 0x05	; 5
    5aec:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
    5af0:	11 c0       	rjmp	.+34     	; 0x5b14 <LCD_PrintSymbol+0x9c>
	else if (number == 7)
    5af2:	89 81       	ldd	r24, Y+1	; 0x01
    5af4:	9a 81       	ldd	r25, Y+2	; 0x02
    5af6:	87 30       	cpi	r24, 0x07	; 7
    5af8:	91 05       	cpc	r25, r1
    5afa:	21 f4       	brne	.+8      	; 0x5b04 <LCD_PrintSymbol+0x8c>
		LCD_DataWrite(0x06);
    5afc:	86 e0       	ldi	r24, 0x06	; 6
    5afe:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
    5b02:	08 c0       	rjmp	.+16     	; 0x5b14 <LCD_PrintSymbol+0x9c>
	else if (number == 8)
    5b04:	89 81       	ldd	r24, Y+1	; 0x01
    5b06:	9a 81       	ldd	r25, Y+2	; 0x02
    5b08:	88 30       	cpi	r24, 0x08	; 8
    5b0a:	91 05       	cpc	r25, r1
    5b0c:	19 f4       	brne	.+6      	; 0x5b14 <LCD_PrintSymbol+0x9c>
		LCD_DataWrite(0x07);
    5b0e:	87 e0       	ldi	r24, 0x07	; 7
    5b10:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
}
    5b14:	0f 90       	pop	r0
    5b16:	0f 90       	pop	r0
    5b18:	df 91       	pop	r29
    5b1a:	cf 91       	pop	r28
    5b1c:	08 95       	ret

00005b1e <LCD_PrintBlock>:

void LCD_PrintBlock() {
    5b1e:	cf 93       	push	r28
    5b20:	df 93       	push	r29
    5b22:	cd b7       	in	r28, 0x3d	; 61
    5b24:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0xFF);
    5b26:	8f ef       	ldi	r24, 0xFF	; 255
    5b28:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
}
    5b2c:	df 91       	pop	r29
    5b2e:	cf 91       	pop	r28
    5b30:	08 95       	ret

00005b32 <LCD_PrintLArrow>:

void LCD_PrintLArrow() {
    5b32:	cf 93       	push	r28
    5b34:	df 93       	push	r29
    5b36:	cd b7       	in	r28, 0x3d	; 61
    5b38:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0x7F);
    5b3a:	8f e7       	ldi	r24, 0x7F	; 127
    5b3c:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
}
    5b40:	df 91       	pop	r29
    5b42:	cf 91       	pop	r28
    5b44:	08 95       	ret

00005b46 <LCD_PrintRArrow>:

void LCD_PrintRArrow() {
    5b46:	cf 93       	push	r28
    5b48:	df 93       	push	r29
    5b4a:	cd b7       	in	r28, 0x3d	; 61
    5b4c:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0x7E);
    5b4e:	8e e7       	ldi	r24, 0x7E	; 126
    5b50:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
}
    5b54:	df 91       	pop	r29
    5b56:	cf 91       	pop	r28
    5b58:	08 95       	ret

00005b5a <LCD_PrintDot>:

void LCD_PrintDot() {
    5b5a:	cf 93       	push	r28
    5b5c:	df 93       	push	r29
    5b5e:	cd b7       	in	r28, 0x3d	; 61
    5b60:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0xA5);
    5b62:	85 ea       	ldi	r24, 0xA5	; 165
    5b64:	0e 94 28 2b 	call	0x5650	; 0x5650 <LCD_DataWrite>
}
    5b68:	df 91       	pop	r29
    5b6a:	cf 91       	pop	r28
    5b6c:	08 95       	ret

00005b6e <UART_Init>:


		    Refer uart.h file for Supported(range) baud rates.		
***************************************************************************************************/
void UART_Init(uint32_t v_baudRate_u32)
{
    5b6e:	cf 93       	push	r28
    5b70:	df 93       	push	r29
    5b72:	00 d0       	rcall	.+0      	; 0x5b74 <UART_Init+0x6>
    5b74:	00 d0       	rcall	.+0      	; 0x5b76 <UART_Init+0x8>
    5b76:	cd b7       	in	r28, 0x3d	; 61
    5b78:	de b7       	in	r29, 0x3e	; 62
    5b7a:	69 83       	std	Y+1, r22	; 0x01
    5b7c:	7a 83       	std	Y+2, r23	; 0x02
    5b7e:	8b 83       	std	Y+3, r24	; 0x03
    5b80:	9c 83       	std	Y+4, r25	; 0x04
	UCSRB= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
    5b82:	8a e2       	ldi	r24, 0x2A	; 42
    5b84:	90 e0       	ldi	r25, 0x00	; 0
    5b86:	28 e1       	ldi	r18, 0x18	; 24
    5b88:	fc 01       	movw	r30, r24
    5b8a:	20 83       	st	Z, r18
	UCSRC= (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);   // Asynchronous mode 8-bit data and 1-stop bit
    5b8c:	80 e4       	ldi	r24, 0x40	; 64
    5b8e:	90 e0       	ldi	r25, 0x00	; 0
    5b90:	26 e8       	ldi	r18, 0x86	; 134
    5b92:	fc 01       	movw	r30, r24
    5b94:	20 83       	st	Z, r18
	UCSRA= 0x00;                                   // Clear the UASRT status register
    5b96:	8b e2       	ldi	r24, 0x2B	; 43
    5b98:	90 e0       	ldi	r25, 0x00	; 0
    5b9a:	fc 01       	movw	r30, r24
    5b9c:	10 82       	st	Z, r1
	UART_SetBaudRate(v_baudRate_u32);
    5b9e:	89 81       	ldd	r24, Y+1	; 0x01
    5ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    5ba2:	ab 81       	ldd	r26, Y+3	; 0x03
    5ba4:	bc 81       	ldd	r27, Y+4	; 0x04
    5ba6:	bc 01       	movw	r22, r24
    5ba8:	cd 01       	movw	r24, r26
    5baa:	0e 94 de 2d 	call	0x5bbc	; 0x5bbc <UART_SetBaudRate>
}
    5bae:	0f 90       	pop	r0
    5bb0:	0f 90       	pop	r0
    5bb2:	0f 90       	pop	r0
    5bb4:	0f 90       	pop	r0
    5bb6:	df 91       	pop	r29
    5bb8:	cf 91       	pop	r28
    5bba:	08 95       	ret

00005bbc <UART_SetBaudRate>:
                 the default baudrate of 9600 is set.

		    Refer uart.h file for Supported range of baud rates.
***************************************************************************************************/
void UART_SetBaudRate(uint32_t v_baudRate_u32)
{
    5bbc:	ef 92       	push	r14
    5bbe:	ff 92       	push	r15
    5bc0:	0f 93       	push	r16
    5bc2:	1f 93       	push	r17
    5bc4:	cf 93       	push	r28
    5bc6:	df 93       	push	r29
    5bc8:	cd b7       	in	r28, 0x3d	; 61
    5bca:	de b7       	in	r29, 0x3e	; 62
    5bcc:	2a 97       	sbiw	r28, 0x0a	; 10
    5bce:	0f b6       	in	r0, 0x3f	; 63
    5bd0:	f8 94       	cli
    5bd2:	de bf       	out	0x3e, r29	; 62
    5bd4:	0f be       	out	0x3f, r0	; 63
    5bd6:	cd bf       	out	0x3d, r28	; 61
    5bd8:	6b 83       	std	Y+3, r22	; 0x03
    5bda:	7c 83       	std	Y+4, r23	; 0x04
    5bdc:	8d 83       	std	Y+5, r24	; 0x05
    5bde:	9e 83       	std	Y+6, r25	; 0x06
	uint16_t RegValue;

	if((v_baudRate_u32 >= C_MinBaudRate_U32) && (v_baudRate_u32<=C_MaxBaudRate_U32))
    5be0:	8b 81       	ldd	r24, Y+3	; 0x03
    5be2:	9c 81       	ldd	r25, Y+4	; 0x04
    5be4:	ad 81       	ldd	r26, Y+5	; 0x05
    5be6:	be 81       	ldd	r27, Y+6	; 0x06
    5be8:	80 36       	cpi	r24, 0x60	; 96
    5bea:	29 e0       	ldi	r18, 0x09	; 9
    5bec:	92 07       	cpc	r25, r18
    5bee:	a1 05       	cpc	r26, r1
    5bf0:	b1 05       	cpc	r27, r1
    5bf2:	08 f4       	brcc	.+2      	; 0x5bf6 <UART_SetBaudRate+0x3a>
    5bf4:	49 c0       	rjmp	.+146    	; 0x5c88 <UART_SetBaudRate+0xcc>
    5bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    5bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    5bfa:	ad 81       	ldd	r26, Y+5	; 0x05
    5bfc:	be 81       	ldd	r27, Y+6	; 0x06
    5bfe:	81 30       	cpi	r24, 0x01	; 1
    5c00:	e2 ec       	ldi	r30, 0xC2	; 194
    5c02:	9e 07       	cpc	r25, r30
    5c04:	e1 e0       	ldi	r30, 0x01	; 1
    5c06:	ae 07       	cpc	r26, r30
    5c08:	b1 05       	cpc	r27, r1
    5c0a:	f0 f5       	brcc	.+124    	; 0x5c88 <UART_SetBaudRate+0xcc>
	{
		/* Check if the requested baudate is within range,
	     If yes then calculate the value to be loaded into baud rate generator. */
		RegValue = M_GetBaudRateGeneratorValue(v_baudRate_u32);
    5c0c:	2b 81       	ldd	r18, Y+3	; 0x03
    5c0e:	3c 81       	ldd	r19, Y+4	; 0x04
    5c10:	4d 81       	ldd	r20, Y+5	; 0x05
    5c12:	5e 81       	ldd	r21, Y+6	; 0x06
    5c14:	80 e0       	ldi	r24, 0x00	; 0
    5c16:	90 e0       	ldi	r25, 0x00	; 0
    5c18:	dc 01       	movw	r26, r24
    5c1a:	82 1b       	sub	r24, r18
    5c1c:	93 0b       	sbc	r25, r19
    5c1e:	a4 0b       	sbc	r26, r20
    5c20:	b5 0b       	sbc	r27, r21
    5c22:	88 0f       	add	r24, r24
    5c24:	99 1f       	adc	r25, r25
    5c26:	aa 1f       	adc	r26, r26
    5c28:	bb 1f       	adc	r27, r27
    5c2a:	88 0f       	add	r24, r24
    5c2c:	99 1f       	adc	r25, r25
    5c2e:	aa 1f       	adc	r26, r26
    5c30:	bb 1f       	adc	r27, r27
    5c32:	88 0f       	add	r24, r24
    5c34:	99 1f       	adc	r25, r25
    5c36:	aa 1f       	adc	r26, r26
    5c38:	bb 1f       	adc	r27, r27
    5c3a:	7c 01       	movw	r14, r24
    5c3c:	8d 01       	movw	r16, r26
    5c3e:	f0 ec       	ldi	r31, 0xC0	; 192
    5c40:	ef 1a       	sub	r14, r31
    5c42:	fd eb       	ldi	r31, 0xBD	; 189
    5c44:	ff 0a       	sbc	r15, r31
    5c46:	00 4f       	sbci	r16, 0xF0	; 240
    5c48:	1f 4f       	sbci	r17, 0xFF	; 255
    5c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    5c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    5c4e:	ad 81       	ldd	r26, Y+5	; 0x05
    5c50:	be 81       	ldd	r27, Y+6	; 0x06
    5c52:	88 0f       	add	r24, r24
    5c54:	99 1f       	adc	r25, r25
    5c56:	aa 1f       	adc	r26, r26
    5c58:	bb 1f       	adc	r27, r27
    5c5a:	88 0f       	add	r24, r24
    5c5c:	99 1f       	adc	r25, r25
    5c5e:	aa 1f       	adc	r26, r26
    5c60:	bb 1f       	adc	r27, r27
    5c62:	88 0f       	add	r24, r24
    5c64:	99 1f       	adc	r25, r25
    5c66:	aa 1f       	adc	r26, r26
    5c68:	bb 1f       	adc	r27, r27
    5c6a:	88 0f       	add	r24, r24
    5c6c:	99 1f       	adc	r25, r25
    5c6e:	aa 1f       	adc	r26, r26
    5c70:	bb 1f       	adc	r27, r27
    5c72:	9c 01       	movw	r18, r24
    5c74:	ad 01       	movw	r20, r26
    5c76:	c8 01       	movw	r24, r16
    5c78:	b7 01       	movw	r22, r14
    5c7a:	0e 94 14 32 	call	0x6428	; 0x6428 <__udivmodsi4>
    5c7e:	da 01       	movw	r26, r20
    5c80:	c9 01       	movw	r24, r18
    5c82:	9a 83       	std	Y+2, r25	; 0x02
    5c84:	89 83       	std	Y+1, r24	; 0x01
    5c86:	04 c0       	rjmp	.+8      	; 0x5c90 <UART_SetBaudRate+0xd4>
	}
	else
	{
		/*	 Invalid baudrate requested, hence set it to default baudrate of 9600 */
		RegValue = M_GetBaudRateGeneratorValue(9600);
    5c88:	86 e0       	ldi	r24, 0x06	; 6
    5c8a:	90 e0       	ldi	r25, 0x00	; 0
    5c8c:	9a 83       	std	Y+2, r25	; 0x02
    5c8e:	89 83       	std	Y+1, r24	; 0x01
	}

	UBRRL = util_ExtractByte0to8(RegValue);
    5c90:	89 e2       	ldi	r24, 0x29	; 41
    5c92:	90 e0       	ldi	r25, 0x00	; 0
    5c94:	29 81       	ldd	r18, Y+1	; 0x01
    5c96:	fc 01       	movw	r30, r24
    5c98:	20 83       	st	Z, r18
	UBRRH = util_ExtractByte8to16(RegValue);
    5c9a:	80 e4       	ldi	r24, 0x40	; 64
    5c9c:	90 e0       	ldi	r25, 0x00	; 0
    5c9e:	29 81       	ldd	r18, Y+1	; 0x01
    5ca0:	3a 81       	ldd	r19, Y+2	; 0x02
    5ca2:	23 2f       	mov	r18, r19
    5ca4:	33 27       	eor	r19, r19
    5ca6:	fc 01       	movw	r30, r24
    5ca8:	20 83       	st	Z, r18
}
    5caa:	2a 96       	adiw	r28, 0x0a	; 10
    5cac:	0f b6       	in	r0, 0x3f	; 63
    5cae:	f8 94       	cli
    5cb0:	de bf       	out	0x3e, r29	; 62
    5cb2:	0f be       	out	0x3f, r0	; 63
    5cb4:	cd bf       	out	0x3d, r28	; 61
    5cb6:	df 91       	pop	r29
    5cb8:	cf 91       	pop	r28
    5cba:	1f 91       	pop	r17
    5cbc:	0f 91       	pop	r16
    5cbe:	ff 90       	pop	r15
    5cc0:	ef 90       	pop	r14
    5cc2:	08 95       	ret

00005cc4 <UART_RxChar>:

 * description :This function is used to receive a char from UART module.
                It waits till a char is received and returns it after reception.
***************************************************************************************************/
char UART_RxChar(void)
{
    5cc4:	cf 93       	push	r28
    5cc6:	df 93       	push	r29
    5cc8:	cd b7       	in	r28, 0x3d	; 61
    5cca:	de b7       	in	r29, 0x3e	; 62
	while(util_IsBitCleared(UCSRA,RXC));  // Wait till the data is received
    5ccc:	00 00       	nop
    5cce:	8b e2       	ldi	r24, 0x2B	; 43
    5cd0:	90 e0       	ldi	r25, 0x00	; 0
    5cd2:	fc 01       	movw	r30, r24
    5cd4:	80 81       	ld	r24, Z
    5cd6:	88 23       	and	r24, r24
    5cd8:	d4 f7       	brge	.-12     	; 0x5cce <UART_RxChar+0xa>
	return(UDR);                          // return the received char
    5cda:	8c e2       	ldi	r24, 0x2C	; 44
    5cdc:	90 e0       	ldi	r25, 0x00	; 0
    5cde:	fc 01       	movw	r30, r24
    5ce0:	80 81       	ld	r24, Z
}
    5ce2:	df 91       	pop	r29
    5ce4:	cf 91       	pop	r28
    5ce6:	08 95       	ret

00005ce8 <UART_TxChar>:
 * Return value	: none.

 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char v_uartData_u8)
{
    5ce8:	cf 93       	push	r28
    5cea:	df 93       	push	r29
    5cec:	1f 92       	push	r1
    5cee:	cd b7       	in	r28, 0x3d	; 61
    5cf0:	de b7       	in	r29, 0x3e	; 62
    5cf2:	89 83       	std	Y+1, r24	; 0x01
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
    5cf4:	00 00       	nop
    5cf6:	8b e2       	ldi	r24, 0x2B	; 43
    5cf8:	90 e0       	ldi	r25, 0x00	; 0
    5cfa:	fc 01       	movw	r30, r24
    5cfc:	80 81       	ld	r24, Z
    5cfe:	88 2f       	mov	r24, r24
    5d00:	90 e0       	ldi	r25, 0x00	; 0
    5d02:	80 72       	andi	r24, 0x20	; 32
    5d04:	99 27       	eor	r25, r25
    5d06:	00 97       	sbiw	r24, 0x00	; 0
    5d08:	b1 f3       	breq	.-20     	; 0x5cf6 <UART_TxChar+0xe>
	UDR =v_uartData_u8;                              // Load the data to be transmitted
    5d0a:	8c e2       	ldi	r24, 0x2C	; 44
    5d0c:	90 e0       	ldi	r25, 0x00	; 0
    5d0e:	29 81       	ldd	r18, Y+1	; 0x01
    5d10:	fc 01       	movw	r30, r24
    5d12:	20 83       	st	Z, r18
}
    5d14:	0f 90       	pop	r0
    5d16:	df 91       	pop	r29
    5d18:	cf 91       	pop	r28
    5d1a:	08 95       	ret

00005d1c <UART_TxString>:
               1.The ptr_string points to the first char of the string
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(char *ptr_string)
{
    5d1c:	cf 93       	push	r28
    5d1e:	df 93       	push	r29
    5d20:	00 d0       	rcall	.+0      	; 0x5d22 <UART_TxString+0x6>
    5d22:	cd b7       	in	r28, 0x3d	; 61
    5d24:	de b7       	in	r29, 0x3e	; 62
    5d26:	9a 83       	std	Y+2, r25	; 0x02
    5d28:	89 83       	std	Y+1, r24	; 0x01
	while(*ptr_string)
    5d2a:	0b c0       	rjmp	.+22     	; 0x5d42 <UART_TxString+0x26>
		UART_TxChar(*ptr_string++);// Loop through the string and transmit char by char
    5d2c:	89 81       	ldd	r24, Y+1	; 0x01
    5d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    5d30:	9c 01       	movw	r18, r24
    5d32:	2f 5f       	subi	r18, 0xFF	; 255
    5d34:	3f 4f       	sbci	r19, 0xFF	; 255
    5d36:	3a 83       	std	Y+2, r19	; 0x02
    5d38:	29 83       	std	Y+1, r18	; 0x01
    5d3a:	fc 01       	movw	r30, r24
    5d3c:	80 81       	ld	r24, Z
    5d3e:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(char *ptr_string)
{
	while(*ptr_string)
    5d42:	89 81       	ldd	r24, Y+1	; 0x01
    5d44:	9a 81       	ldd	r25, Y+2	; 0x02
    5d46:	fc 01       	movw	r30, r24
    5d48:	80 81       	ld	r24, Z
    5d4a:	88 23       	and	r24, r24
    5d4c:	79 f7       	brne	.-34     	; 0x5d2c <UART_TxString+0x10>
		UART_TxChar(*ptr_string++);// Loop through the string and transmit char by char
}
    5d4e:	0f 90       	pop	r0
    5d50:	0f 90       	pop	r0
    5d52:	df 91       	pop	r29
    5d54:	cf 91       	pop	r28
    5d56:	08 95       	ret

00005d58 <UART_RxString>:
    if not required then comment UART_TxChar(ch) in the code.
  2.BackSlash is not taken care.
***************************************************************************************************/
#if (Enable_UART_RxString==1)
uint8_t UART_RxString(char *ptr_string)
{
    5d58:	cf 93       	push	r28
    5d5a:	df 93       	push	r29
    5d5c:	00 d0       	rcall	.+0      	; 0x5d5e <UART_RxString+0x6>
    5d5e:	00 d0       	rcall	.+0      	; 0x5d60 <UART_RxString+0x8>
    5d60:	00 d0       	rcall	.+0      	; 0x5d62 <UART_RxString+0xa>
    5d62:	cd b7       	in	r28, 0x3d	; 61
    5d64:	de b7       	in	r29, 0x3e	; 62
    5d66:	9e 83       	std	Y+6, r25	; 0x06
    5d68:	8d 83       	std	Y+5, r24	; 0x05
	char ch;
    uint8_t len = 0;
    5d6a:	19 82       	std	Y+1, r1	; 0x01
	for(int clk=0;clk<1000;clk++)
    5d6c:	1b 82       	std	Y+3, r1	; 0x03
    5d6e:	1a 82       	std	Y+2, r1	; 0x02
    5d70:	2f c0       	rjmp	.+94     	; 0x5dd0 <UART_RxString+0x78>
	{
		ch=UART_RxChar();    //Receive a char
    5d72:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <UART_RxChar>
    5d76:	8c 83       	std	Y+4, r24	; 0x04
		//UART_TxChar(ch);     //Echo back the received char

		if((ch=='\r') || (ch=='\n')) //read till enter key is pressed
    5d78:	8c 81       	ldd	r24, Y+4	; 0x04
    5d7a:	8d 30       	cpi	r24, 0x0D	; 13
    5d7c:	19 f0       	breq	.+6      	; 0x5d84 <UART_RxString+0x2c>
    5d7e:	8c 81       	ldd	r24, Y+4	; 0x04
    5d80:	8a 30       	cpi	r24, 0x0A	; 10
    5d82:	51 f4       	brne	.+20     	; 0x5d98 <UART_RxString+0x40>
		{						     //once enter key is pressed null terminate the string
			ptr_string[len]=0;           //and break the loop
    5d84:	89 81       	ldd	r24, Y+1	; 0x01
    5d86:	88 2f       	mov	r24, r24
    5d88:	90 e0       	ldi	r25, 0x00	; 0
    5d8a:	2d 81       	ldd	r18, Y+5	; 0x05
    5d8c:	3e 81       	ldd	r19, Y+6	; 0x06
    5d8e:	82 0f       	add	r24, r18
    5d90:	93 1f       	adc	r25, r19
    5d92:	fc 01       	movw	r30, r24
    5d94:	10 82       	st	Z, r1
			break;				  
    5d96:	22 c0       	rjmp	.+68     	; 0x5ddc <UART_RxString+0x84>
		}
        else if((ch=='\b') && (len!=0))
    5d98:	8c 81       	ldd	r24, Y+4	; 0x04
    5d9a:	88 30       	cpi	r24, 0x08	; 8
    5d9c:	39 f4       	brne	.+14     	; 0x5dac <UART_RxString+0x54>
    5d9e:	89 81       	ldd	r24, Y+1	; 0x01
    5da0:	88 23       	and	r24, r24
    5da2:	21 f0       	breq	.+8      	; 0x5dac <UART_RxString+0x54>
        {
		    len--;    //If backspace is pressed then decrement the index to remove the old char
    5da4:	89 81       	ldd	r24, Y+1	; 0x01
    5da6:	81 50       	subi	r24, 0x01	; 1
    5da8:	89 83       	std	Y+1, r24	; 0x01
    5daa:	0d c0       	rjmp	.+26     	; 0x5dc6 <UART_RxString+0x6e>
        }
        else
        {
            ptr_string[len]=ch; //copy the char into string and increment the index
    5dac:	89 81       	ldd	r24, Y+1	; 0x01
    5dae:	88 2f       	mov	r24, r24
    5db0:	90 e0       	ldi	r25, 0x00	; 0
    5db2:	2d 81       	ldd	r18, Y+5	; 0x05
    5db4:	3e 81       	ldd	r19, Y+6	; 0x06
    5db6:	82 0f       	add	r24, r18
    5db8:	93 1f       	adc	r25, r19
    5dba:	2c 81       	ldd	r18, Y+4	; 0x04
    5dbc:	fc 01       	movw	r30, r24
    5dbe:	20 83       	st	Z, r18
            len++;
    5dc0:	89 81       	ldd	r24, Y+1	; 0x01
    5dc2:	8f 5f       	subi	r24, 0xFF	; 255
    5dc4:	89 83       	std	Y+1, r24	; 0x01
#if (Enable_UART_RxString==1)
uint8_t UART_RxString(char *ptr_string)
{
	char ch;
    uint8_t len = 0;
	for(int clk=0;clk<1000;clk++)
    5dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    5dc8:	9b 81       	ldd	r25, Y+3	; 0x03
    5dca:	01 96       	adiw	r24, 0x01	; 1
    5dcc:	9b 83       	std	Y+3, r25	; 0x03
    5dce:	8a 83       	std	Y+2, r24	; 0x02
    5dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    5dd2:	9b 81       	ldd	r25, Y+3	; 0x03
    5dd4:	88 3e       	cpi	r24, 0xE8	; 232
    5dd6:	f3 e0       	ldi	r31, 0x03	; 3
    5dd8:	9f 07       	cpc	r25, r31
    5dda:	5c f2       	brlt	.-106    	; 0x5d72 <UART_RxString+0x1a>
        {
            ptr_string[len]=ch; //copy the char into string and increment the index
            len++;
        }
	}
  return len;   
    5ddc:	89 81       	ldd	r24, Y+1	; 0x01
}
    5dde:	26 96       	adiw	r28, 0x06	; 6
    5de0:	0f b6       	in	r0, 0x3f	; 63
    5de2:	f8 94       	cli
    5de4:	de bf       	out	0x3e, r29	; 62
    5de6:	0f be       	out	0x3f, r0	; 63
    5de8:	cd bf       	out	0x3d, r28	; 61
    5dea:	df 91       	pop	r29
    5dec:	cf 91       	pop	r28
    5dee:	08 95       	ret

00005df0 <UART_TxNumber>:
                8.(0x12AB,6) then 6-digits ie. 0012AB will be transmitted
                9.(0x12AB,C_DefaultDigitsToTransmit_U8) then 12AB will be transmitted.    
 ***************************************************************************************************/
#if ((Enable_UART_TxNumber==1) || (Enable_UART_TxFloatNumber==1) || (Enable_UART_Printf == 1))
void UART_TxNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToTransmit_u8)
{
    5df0:	ff 92       	push	r15
    5df2:	0f 93       	push	r16
    5df4:	1f 93       	push	r17
    5df6:	cf 93       	push	r28
    5df8:	df 93       	push	r29
    5dfa:	cd b7       	in	r28, 0x3d	; 61
    5dfc:	de b7       	in	r29, 0x3e	; 62
    5dfe:	69 97       	sbiw	r28, 0x19	; 25
    5e00:	0f b6       	in	r0, 0x3f	; 63
    5e02:	f8 94       	cli
    5e04:	de bf       	out	0x3e, r29	; 62
    5e06:	0f be       	out	0x3f, r0	; 63
    5e08:	cd bf       	out	0x3d, r28	; 61
    5e0a:	8c 87       	std	Y+12, r24	; 0x0c
    5e0c:	4d 87       	std	Y+13, r20	; 0x0d
    5e0e:	5e 87       	std	Y+14, r21	; 0x0e
    5e10:	6f 87       	std	Y+15, r22	; 0x0f
    5e12:	78 8b       	std	Y+16, r23	; 0x10
    5e14:	29 8b       	std	Y+17, r18	; 0x11
    uint8_t i=0,a[10];
    5e16:	19 82       	std	Y+1, r1	; 0x01

    if(C_BINARY_U8 == v_numericSystem_u8)
    5e18:	8c 85       	ldd	r24, Y+12	; 0x0c
    5e1a:	82 30       	cpi	r24, 0x02	; 2
    5e1c:	69 f5       	brne	.+90     	; 0x5e78 <UART_TxNumber+0x88>
    {
        while(v_numOfDigitsToTransmit_u8!=0)
    5e1e:	28 c0       	rjmp	.+80     	; 0x5e70 <UART_TxNumber+0x80>
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and transmit */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
    5e20:	89 89       	ldd	r24, Y+17	; 0x11
    5e22:	88 2f       	mov	r24, r24
    5e24:	90 e0       	ldi	r25, 0x00	; 0
    5e26:	9c 01       	movw	r18, r24
    5e28:	21 50       	subi	r18, 0x01	; 1
    5e2a:	31 09       	sbc	r19, r1
    5e2c:	81 e0       	ldi	r24, 0x01	; 1
    5e2e:	90 e0       	ldi	r25, 0x00	; 0
    5e30:	02 c0       	rjmp	.+4      	; 0x5e36 <UART_TxNumber+0x46>
    5e32:	88 0f       	add	r24, r24
    5e34:	99 1f       	adc	r25, r25
    5e36:	2a 95       	dec	r18
    5e38:	e2 f7       	brpl	.-8      	; 0x5e32 <UART_TxNumber+0x42>
    5e3a:	9c 01       	movw	r18, r24
    5e3c:	44 27       	eor	r20, r20
    5e3e:	37 fd       	sbrc	r19, 7
    5e40:	40 95       	com	r20
    5e42:	54 2f       	mov	r21, r20
    5e44:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e46:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e48:	af 85       	ldd	r26, Y+15	; 0x0f
    5e4a:	b8 89       	ldd	r27, Y+16	; 0x10
    5e4c:	82 23       	and	r24, r18
    5e4e:	93 23       	and	r25, r19
    5e50:	a4 23       	and	r26, r20
    5e52:	b5 23       	and	r27, r21
    5e54:	21 e0       	ldi	r18, 0x01	; 1
    5e56:	00 97       	sbiw	r24, 0x00	; 0
    5e58:	a1 05       	cpc	r26, r1
    5e5a:	b1 05       	cpc	r27, r1
    5e5c:	09 f4       	brne	.+2      	; 0x5e60 <UART_TxNumber+0x70>
    5e5e:	20 e0       	ldi	r18, 0x00	; 0
    5e60:	29 83       	std	Y+1, r18	; 0x01
            UART_TxChar(util_Dec2Ascii(i));
    5e62:	89 81       	ldd	r24, Y+1	; 0x01
    5e64:	80 5d       	subi	r24, 0xD0	; 208
    5e66:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
            v_numOfDigitsToTransmit_u8--;
    5e6a:	89 89       	ldd	r24, Y+17	; 0x11
    5e6c:	81 50       	subi	r24, 0x01	; 1
    5e6e:	89 8b       	std	Y+17, r24	; 0x11
{
    uint8_t i=0,a[10];

    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToTransmit_u8!=0)
    5e70:	89 89       	ldd	r24, Y+17	; 0x11
    5e72:	88 23       	and	r24, r24
    5e74:	a9 f6       	brne	.-86     	; 0x5e20 <UART_TxNumber+0x30>
    5e76:	9e c0       	rjmp	.+316    	; 0x5fb4 <UART_TxNumber+0x1c4>
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
            UART_TxChar(util_Dec2Ascii(i));
            v_numOfDigitsToTransmit_u8--;
        }    
    }     
    else if(v_number_u32==0)
    5e78:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e7a:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e7c:	af 85       	ldd	r26, Y+15	; 0x0f
    5e7e:	b8 89       	ldd	r27, Y+16	; 0x10
    5e80:	00 97       	sbiw	r24, 0x00	; 0
    5e82:	a1 05       	cpc	r26, r1
    5e84:	b1 05       	cpc	r27, r1
    5e86:	89 f4       	brne	.+34     	; 0x5eaa <UART_TxNumber+0xba>
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
    5e88:	19 82       	std	Y+1, r1	; 0x01
    5e8a:	06 c0       	rjmp	.+12     	; 0x5e98 <UART_TxNumber+0xa8>
            UART_TxChar('0');
    5e8c:	80 e3       	ldi	r24, 0x30	; 48
    5e8e:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
        }    
    }     
    else if(v_number_u32==0)
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
    5e92:	89 81       	ldd	r24, Y+1	; 0x01
    5e94:	8f 5f       	subi	r24, 0xFF	; 255
    5e96:	89 83       	std	Y+1, r24	; 0x01
    5e98:	99 81       	ldd	r25, Y+1	; 0x01
    5e9a:	89 89       	ldd	r24, Y+17	; 0x11
    5e9c:	98 17       	cp	r25, r24
    5e9e:	08 f0       	brcs	.+2      	; 0x5ea2 <UART_TxNumber+0xb2>
    5ea0:	89 c0       	rjmp	.+274    	; 0x5fb4 <UART_TxNumber+0x1c4>
    5ea2:	89 81       	ldd	r24, Y+1	; 0x01
    5ea4:	8a 30       	cpi	r24, 0x0A	; 10
    5ea6:	90 f3       	brcs	.-28     	; 0x5e8c <UART_TxNumber+0x9c>
    5ea8:	85 c0       	rjmp	.+266    	; 0x5fb4 <UART_TxNumber+0x1c4>
            UART_TxChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
    5eaa:	19 82       	std	Y+1, r1	; 0x01
    5eac:	4f c0       	rjmp	.+158    	; 0x5f4c <UART_TxNumber+0x15c>
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToTransmit_u8 */
            if(v_number_u32!=0)
    5eae:	8d 85       	ldd	r24, Y+13	; 0x0d
    5eb0:	9e 85       	ldd	r25, Y+14	; 0x0e
    5eb2:	af 85       	ldd	r26, Y+15	; 0x0f
    5eb4:	b8 89       	ldd	r27, Y+16	; 0x10
    5eb6:	00 97       	sbiw	r24, 0x00	; 0
    5eb8:	a1 05       	cpc	r26, r1
    5eba:	b1 05       	cpc	r27, r1
    5ebc:	a1 f1       	breq	.+104    	; 0x5f26 <UART_TxNumber+0x136>
                First get the remainder and divide the number by 10 each time.

                example for Decimal number:
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
    5ebe:	89 81       	ldd	r24, Y+1	; 0x01
    5ec0:	08 2f       	mov	r16, r24
    5ec2:	10 e0       	ldi	r17, 0x00	; 0
    5ec4:	fd 84       	ldd	r15, Y+13	; 0x0d
    5ec6:	8c 85       	ldd	r24, Y+12	; 0x0c
    5ec8:	28 2f       	mov	r18, r24
    5eca:	30 e0       	ldi	r19, 0x00	; 0
    5ecc:	40 e0       	ldi	r20, 0x00	; 0
    5ece:	50 e0       	ldi	r21, 0x00	; 0
    5ed0:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ed2:	9e 85       	ldd	r25, Y+14	; 0x0e
    5ed4:	af 85       	ldd	r26, Y+15	; 0x0f
    5ed6:	b8 89       	ldd	r27, Y+16	; 0x10
    5ed8:	bc 01       	movw	r22, r24
    5eda:	cd 01       	movw	r24, r26
    5edc:	0e 94 14 32 	call	0x6428	; 0x6428 <__udivmodsi4>
    5ee0:	da 01       	movw	r26, r20
    5ee2:	c9 01       	movw	r24, r18
    5ee4:	98 2f       	mov	r25, r24
    5ee6:	8c 85       	ldd	r24, Y+12	; 0x0c
    5ee8:	98 9f       	mul	r25, r24
    5eea:	80 2d       	mov	r24, r0
    5eec:	11 24       	eor	r1, r1
    5eee:	2f 2d       	mov	r18, r15
    5ef0:	28 1b       	sub	r18, r24
    5ef2:	ce 01       	movw	r24, r28
    5ef4:	02 96       	adiw	r24, 0x02	; 2
    5ef6:	80 0f       	add	r24, r16
    5ef8:	91 1f       	adc	r25, r17
    5efa:	fc 01       	movw	r30, r24
    5efc:	20 83       	st	Z, r18
                v_number_u32=v_number_u32/v_numericSystem_u8;
    5efe:	8c 85       	ldd	r24, Y+12	; 0x0c
    5f00:	28 2f       	mov	r18, r24
    5f02:	30 e0       	ldi	r19, 0x00	; 0
    5f04:	40 e0       	ldi	r20, 0x00	; 0
    5f06:	50 e0       	ldi	r21, 0x00	; 0
    5f08:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f0a:	9e 85       	ldd	r25, Y+14	; 0x0e
    5f0c:	af 85       	ldd	r26, Y+15	; 0x0f
    5f0e:	b8 89       	ldd	r27, Y+16	; 0x10
    5f10:	bc 01       	movw	r22, r24
    5f12:	cd 01       	movw	r24, r26
    5f14:	0e 94 14 32 	call	0x6428	; 0x6428 <__udivmodsi4>
    5f18:	da 01       	movw	r26, r20
    5f1a:	c9 01       	movw	r24, r18
    5f1c:	8d 87       	std	Y+13, r24	; 0x0d
    5f1e:	9e 87       	std	Y+14, r25	; 0x0e
    5f20:	af 87       	std	Y+15, r26	; 0x0f
    5f22:	b8 8b       	std	Y+16, r27	; 0x10
    5f24:	10 c0       	rjmp	.+32     	; 0x5f46 <UART_TxNumber+0x156>
            }
            else if( (v_numOfDigitsToTransmit_u8 == C_DefaultDigitsToTransmit_U8) ||
    5f26:	89 89       	ldd	r24, Y+17	; 0x11
    5f28:	8f 3f       	cpi	r24, 0xFF	; 255
    5f2a:	a9 f0       	breq	.+42     	; 0x5f56 <UART_TxNumber+0x166>
    5f2c:	89 89       	ldd	r24, Y+17	; 0x11
    5f2e:	8b 30       	cpi	r24, 0x0B	; 11
    5f30:	90 f4       	brcc	.+36     	; 0x5f56 <UART_TxNumber+0x166>
            else
            {
                /*In case user expects more digits to be transmitted than the actual digits in number,
                  then update the remaining digits with zero.
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
    5f32:	89 81       	ldd	r24, Y+1	; 0x01
    5f34:	88 2f       	mov	r24, r24
    5f36:	90 e0       	ldi	r25, 0x00	; 0
    5f38:	9e 01       	movw	r18, r28
    5f3a:	2e 5f       	subi	r18, 0xFE	; 254
    5f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    5f3e:	82 0f       	add	r24, r18
    5f40:	93 1f       	adc	r25, r19
    5f42:	fc 01       	movw	r30, r24
    5f44:	10 82       	st	Z, r1
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
            UART_TxChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
    5f46:	89 81       	ldd	r24, Y+1	; 0x01
    5f48:	8f 5f       	subi	r24, 0xFF	; 255
    5f4a:	89 83       	std	Y+1, r24	; 0x01
    5f4c:	99 81       	ldd	r25, Y+1	; 0x01
    5f4e:	89 89       	ldd	r24, Y+17	; 0x11
    5f50:	98 17       	cp	r25, r24
    5f52:	08 f4       	brcc	.+2      	; 0x5f56 <UART_TxNumber+0x166>
    5f54:	ac cf       	rjmp	.-168    	; 0x5eae <UART_TxNumber+0xbe>
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
    5f56:	2b c0       	rjmp	.+86     	; 0x5fae <UART_TxNumber+0x1be>
        { 
            /* Finally get the ascii values of the digits and transmit*/
            UART_TxChar(util_Hex2Ascii(a[i-1]));
    5f58:	89 81       	ldd	r24, Y+1	; 0x01
    5f5a:	88 2f       	mov	r24, r24
    5f5c:	90 e0       	ldi	r25, 0x00	; 0
    5f5e:	01 97       	sbiw	r24, 0x01	; 1
    5f60:	9e 01       	movw	r18, r28
    5f62:	2e 5f       	subi	r18, 0xFE	; 254
    5f64:	3f 4f       	sbci	r19, 0xFF	; 255
    5f66:	82 0f       	add	r24, r18
    5f68:	93 1f       	adc	r25, r19
    5f6a:	fc 01       	movw	r30, r24
    5f6c:	80 81       	ld	r24, Z
    5f6e:	8a 30       	cpi	r24, 0x0A	; 10
    5f70:	68 f0       	brcs	.+26     	; 0x5f8c <UART_TxNumber+0x19c>
    5f72:	89 81       	ldd	r24, Y+1	; 0x01
    5f74:	88 2f       	mov	r24, r24
    5f76:	90 e0       	ldi	r25, 0x00	; 0
    5f78:	01 97       	sbiw	r24, 0x01	; 1
    5f7a:	9e 01       	movw	r18, r28
    5f7c:	2e 5f       	subi	r18, 0xFE	; 254
    5f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    5f80:	82 0f       	add	r24, r18
    5f82:	93 1f       	adc	r25, r19
    5f84:	fc 01       	movw	r30, r24
    5f86:	80 81       	ld	r24, Z
    5f88:	89 5c       	subi	r24, 0xC9	; 201
    5f8a:	0c c0       	rjmp	.+24     	; 0x5fa4 <UART_TxNumber+0x1b4>
    5f8c:	89 81       	ldd	r24, Y+1	; 0x01
    5f8e:	88 2f       	mov	r24, r24
    5f90:	90 e0       	ldi	r25, 0x00	; 0
    5f92:	01 97       	sbiw	r24, 0x01	; 1
    5f94:	9e 01       	movw	r18, r28
    5f96:	2e 5f       	subi	r18, 0xFE	; 254
    5f98:	3f 4f       	sbci	r19, 0xFF	; 255
    5f9a:	82 0f       	add	r24, r18
    5f9c:	93 1f       	adc	r25, r19
    5f9e:	fc 01       	movw	r30, r24
    5fa0:	80 81       	ld	r24, Z
    5fa2:	80 5d       	subi	r24, 0xD0	; 208
    5fa4:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
            i--;
    5fa8:	89 81       	ldd	r24, Y+1	; 0x01
    5faa:	81 50       	subi	r24, 0x01	; 1
    5fac:	89 83       	std	Y+1, r24	; 0x01
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
    5fae:	89 81       	ldd	r24, Y+1	; 0x01
    5fb0:	88 23       	and	r24, r24
    5fb2:	91 f6       	brne	.-92     	; 0x5f58 <UART_TxNumber+0x168>
            i--;
        }
    }


}
    5fb4:	69 96       	adiw	r28, 0x19	; 25
    5fb6:	0f b6       	in	r0, 0x3f	; 63
    5fb8:	f8 94       	cli
    5fba:	de bf       	out	0x3e, r29	; 62
    5fbc:	0f be       	out	0x3f, r0	; 63
    5fbe:	cd bf       	out	0x3d, r28	; 61
    5fc0:	df 91       	pop	r29
    5fc2:	cf 91       	pop	r28
    5fc4:	1f 91       	pop	r17
    5fc6:	0f 91       	pop	r16
    5fc8:	ff 90       	pop	r15
    5fca:	08 95       	ret

00005fcc <UART_TxFloatNumber>:
         Float will be disabled by default as it takes huge controller resources
	     It can be enabled by changing value of Enable_UART_TxFloatNumber to 1 in uart.h	 
 ***************************************************************************************************/
#if (Enable_UART_TxFloatNumber==1)
void UART_TxFloatNumber(float v_floatNumber_f32)
{
    5fcc:	cf 93       	push	r28
    5fce:	df 93       	push	r29
    5fd0:	cd b7       	in	r28, 0x3d	; 61
    5fd2:	de b7       	in	r29, 0x3e	; 62
    5fd4:	28 97       	sbiw	r28, 0x08	; 8
    5fd6:	0f b6       	in	r0, 0x3f	; 63
    5fd8:	f8 94       	cli
    5fda:	de bf       	out	0x3e, r29	; 62
    5fdc:	0f be       	out	0x3f, r0	; 63
    5fde:	cd bf       	out	0x3d, r28	; 61
    5fe0:	6d 83       	std	Y+5, r22	; 0x05
    5fe2:	7e 83       	std	Y+6, r23	; 0x06
    5fe4:	8f 83       	std	Y+7, r24	; 0x07
    5fe6:	98 87       	std	Y+8, r25	; 0x08
      1.Type cast the number to int to get the integer part.
	  2.transmit the extracted integer part followed by a decimal point(.).
	  3.Later the integer part is made zero by subtracting with the extracted integer value.
	  4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

	v_tempNumber_u32 = (uint32_t) v_floatNumber_f32;
    5fe8:	6d 81       	ldd	r22, Y+5	; 0x05
    5fea:	7e 81       	ldd	r23, Y+6	; 0x06
    5fec:	8f 81       	ldd	r24, Y+7	; 0x07
    5fee:	98 85       	ldd	r25, Y+8	; 0x08
    5ff0:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    5ff4:	dc 01       	movw	r26, r24
    5ff6:	cb 01       	movw	r24, r22
    5ff8:	89 83       	std	Y+1, r24	; 0x01
    5ffa:	9a 83       	std	Y+2, r25	; 0x02
    5ffc:	ab 83       	std	Y+3, r26	; 0x03
    5ffe:	bc 83       	std	Y+4, r27	; 0x04
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
    6000:	89 81       	ldd	r24, Y+1	; 0x01
    6002:	9a 81       	ldd	r25, Y+2	; 0x02
    6004:	ab 81       	ldd	r26, Y+3	; 0x03
    6006:	bc 81       	ldd	r27, Y+4	; 0x04
    6008:	2f ef       	ldi	r18, 0xFF	; 255
    600a:	ac 01       	movw	r20, r24
    600c:	bd 01       	movw	r22, r26
    600e:	8a e0       	ldi	r24, 0x0A	; 10
    6010:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>

	UART_TxChar('.');
    6014:	8e e2       	ldi	r24, 0x2E	; 46
    6016:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>

	v_floatNumber_f32 = v_floatNumber_f32 - v_tempNumber_u32;
    601a:	69 81       	ldd	r22, Y+1	; 0x01
    601c:	7a 81       	ldd	r23, Y+2	; 0x02
    601e:	8b 81       	ldd	r24, Y+3	; 0x03
    6020:	9c 81       	ldd	r25, Y+4	; 0x04
    6022:	0e 94 4d 33 	call	0x669a	; 0x669a <__floatunsisf>
    6026:	dc 01       	movw	r26, r24
    6028:	cb 01       	movw	r24, r22
    602a:	9c 01       	movw	r18, r24
    602c:	ad 01       	movw	r20, r26
    602e:	6d 81       	ldd	r22, Y+5	; 0x05
    6030:	7e 81       	ldd	r23, Y+6	; 0x06
    6032:	8f 81       	ldd	r24, Y+7	; 0x07
    6034:	98 85       	ldd	r25, Y+8	; 0x08
    6036:	0e 94 50 32 	call	0x64a0	; 0x64a0 <__subsf3>
    603a:	dc 01       	movw	r26, r24
    603c:	cb 01       	movw	r24, r22
    603e:	8d 83       	std	Y+5, r24	; 0x05
    6040:	9e 83       	std	Y+6, r25	; 0x06
    6042:	af 83       	std	Y+7, r26	; 0x07
    6044:	b8 87       	std	Y+8, r27	; 0x08
	v_tempNumber_u32 = v_floatNumber_f32 * 1000000;
    6046:	20 e0       	ldi	r18, 0x00	; 0
    6048:	34 e2       	ldi	r19, 0x24	; 36
    604a:	44 e7       	ldi	r20, 0x74	; 116
    604c:	59 e4       	ldi	r21, 0x49	; 73
    604e:	6d 81       	ldd	r22, Y+5	; 0x05
    6050:	7e 81       	ldd	r23, Y+6	; 0x06
    6052:	8f 81       	ldd	r24, Y+7	; 0x07
    6054:	98 85       	ldd	r25, Y+8	; 0x08
    6056:	0e 94 03 34 	call	0x6806	; 0x6806 <__mulsf3>
    605a:	dc 01       	movw	r26, r24
    605c:	cb 01       	movw	r24, r22
    605e:	bc 01       	movw	r22, r24
    6060:	cd 01       	movw	r24, r26
    6062:	0e 94 21 33 	call	0x6642	; 0x6642 <__fixunssfsi>
    6066:	dc 01       	movw	r26, r24
    6068:	cb 01       	movw	r24, r22
    606a:	89 83       	std	Y+1, r24	; 0x01
    606c:	9a 83       	std	Y+2, r25	; 0x02
    606e:	ab 83       	std	Y+3, r26	; 0x03
    6070:	bc 83       	std	Y+4, r27	; 0x04
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
    6072:	89 81       	ldd	r24, Y+1	; 0x01
    6074:	9a 81       	ldd	r25, Y+2	; 0x02
    6076:	ab 81       	ldd	r26, Y+3	; 0x03
    6078:	bc 81       	ldd	r27, Y+4	; 0x04
    607a:	2f ef       	ldi	r18, 0xFF	; 255
    607c:	ac 01       	movw	r20, r24
    607e:	bd 01       	movw	r22, r26
    6080:	8a e0       	ldi	r24, 0x0A	; 10
    6082:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
}
    6086:	28 96       	adiw	r28, 0x08	; 8
    6088:	0f b6       	in	r0, 0x3f	; 63
    608a:	f8 94       	cli
    608c:	de bf       	out	0x3e, r29	; 62
    608e:	0f be       	out	0x3f, r0	; 63
    6090:	cd bf       	out	0x3d, r28	; 61
    6092:	df 91       	pop	r29
    6094:	cf 91       	pop	r28
    6096:	08 95       	ret

00006098 <UART_Printf>:
        uint8_t v_Num_u8;
		UART_Printf("num1:%u",(uint16_t)v_Num_u8); 		 
***************************************************************************************************/
#if ( Enable_UART_Printf   == 1 ) 
void UART_Printf(const char *argList, ...)
{
    6098:	cf 93       	push	r28
    609a:	df 93       	push	r29
    609c:	cd b7       	in	r28, 0x3d	; 61
    609e:	de b7       	in	r29, 0x3e	; 62
    60a0:	68 97       	sbiw	r28, 0x18	; 24
    60a2:	0f b6       	in	r0, 0x3f	; 63
    60a4:	f8 94       	cli
    60a6:	de bf       	out	0x3e, r29	; 62
    60a8:	0f be       	out	0x3f, r0	; 63
    60aa:	cd bf       	out	0x3d, r28	; 61
#if (Enable_UART_TxFloatNumber==1)
	double v_floatNum_f32;
#endif	


	va_start(argp, argList);
    60ac:	ce 01       	movw	r24, r28
    60ae:	4f 96       	adiw	r24, 0x1f	; 31
    60b0:	98 8f       	std	Y+24, r25	; 0x18
    60b2:	8f 8b       	std	Y+23, r24	; 0x17

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    60b4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    60b6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    60b8:	9a 83       	std	Y+2, r25	; 0x02
    60ba:	89 83       	std	Y+1, r24	; 0x01
    60bc:	91 c1       	rjmp	.+802    	; 0x63e0 <UART_Printf+0x348>
	{

		ch= *ptr;
    60be:	89 81       	ldd	r24, Y+1	; 0x01
    60c0:	9a 81       	ldd	r25, Y+2	; 0x02
    60c2:	fc 01       	movw	r30, r24
    60c4:	80 81       	ld	r24, Z
    60c6:	89 87       	std	Y+9, r24	; 0x09
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
    60c8:	89 85       	ldd	r24, Y+9	; 0x09
    60ca:	85 32       	cpi	r24, 0x25	; 37
    60cc:	09 f0       	breq	.+2      	; 0x60d0 <UART_Printf+0x38>
    60ce:	80 c1       	rjmp	.+768    	; 0x63d0 <UART_Printf+0x338>
		{
		    ptr++;
    60d0:	89 81       	ldd	r24, Y+1	; 0x01
    60d2:	9a 81       	ldd	r25, Y+2	; 0x02
    60d4:	01 96       	adiw	r24, 0x01	; 1
    60d6:	9a 83       	std	Y+2, r25	; 0x02
    60d8:	89 83       	std	Y+1, r24	; 0x01
		    ch = *ptr;
    60da:	89 81       	ldd	r24, Y+1	; 0x01
    60dc:	9a 81       	ldd	r25, Y+2	; 0x02
    60de:	fc 01       	movw	r30, r24
    60e0:	80 81       	ld	r24, Z
    60e2:	89 87       	std	Y+9, r24	; 0x09
		   if((ch>=0x30) && (ch<=0x39))
    60e4:	89 85       	ldd	r24, Y+9	; 0x09
    60e6:	80 33       	cpi	r24, 0x30	; 48
    60e8:	00 f1       	brcs	.+64     	; 0x612a <UART_Printf+0x92>
    60ea:	89 85       	ldd	r24, Y+9	; 0x09
    60ec:	8a 33       	cpi	r24, 0x3A	; 58
    60ee:	e8 f4       	brcc	.+58     	; 0x612a <UART_Printf+0x92>
			{
			   v_numOfDigitsToTransmit_u8 = 0;
    60f0:	1a 86       	std	Y+10, r1	; 0x0a
			   while((ch>=0x30) && (ch<=0x39))
    60f2:	14 c0       	rjmp	.+40     	; 0x611c <UART_Printf+0x84>
			    {
				   v_numOfDigitsToTransmit_u8 = (v_numOfDigitsToTransmit_u8 * 10) + (ch-0x30);
    60f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    60f6:	88 0f       	add	r24, r24
    60f8:	98 2f       	mov	r25, r24
    60fa:	99 0f       	add	r25, r25
    60fc:	99 0f       	add	r25, r25
    60fe:	98 0f       	add	r25, r24
    6100:	89 85       	ldd	r24, Y+9	; 0x09
    6102:	89 0f       	add	r24, r25
    6104:	80 53       	subi	r24, 0x30	; 48
    6106:	8a 87       	std	Y+10, r24	; 0x0a
				   ptr++;
    6108:	89 81       	ldd	r24, Y+1	; 0x01
    610a:	9a 81       	ldd	r25, Y+2	; 0x02
    610c:	01 96       	adiw	r24, 0x01	; 1
    610e:	9a 83       	std	Y+2, r25	; 0x02
    6110:	89 83       	std	Y+1, r24	; 0x01
				   ch = *ptr;
    6112:	89 81       	ldd	r24, Y+1	; 0x01
    6114:	9a 81       	ldd	r25, Y+2	; 0x02
    6116:	fc 01       	movw	r30, r24
    6118:	80 81       	ld	r24, Z
    611a:	89 87       	std	Y+9, r24	; 0x09
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   v_numOfDigitsToTransmit_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
    611c:	89 85       	ldd	r24, Y+9	; 0x09
    611e:	80 33       	cpi	r24, 0x30	; 48
    6120:	18 f0       	brcs	.+6      	; 0x6128 <UART_Printf+0x90>
    6122:	89 85       	ldd	r24, Y+9	; 0x09
    6124:	8a 33       	cpi	r24, 0x3A	; 58
    6126:	30 f3       	brcs	.-52     	; 0x60f4 <UART_Printf+0x5c>
		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
		{
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
    6128:	02 c0       	rjmp	.+4      	; 0x612e <UART_Printf+0x96>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    612a:	8f ef       	ldi	r24, 0xFF	; 255
    612c:	8a 87       	std	Y+10, r24	; 0x0a
			}				


			switch(ch)       /* Decode the type of the argument */
    612e:	89 85       	ldd	r24, Y+9	; 0x09
    6130:	88 2f       	mov	r24, r24
    6132:	90 e0       	ldi	r25, 0x00	; 0
    6134:	aa 27       	eor	r26, r26
    6136:	97 fd       	sbrc	r25, 7
    6138:	a0 95       	com	r26
    613a:	ba 2f       	mov	r27, r26
    613c:	45 e2       	ldi	r20, 0x25	; 37
    613e:	50 e0       	ldi	r21, 0x00	; 0
    6140:	23 e5       	ldi	r18, 0x53	; 83
    6142:	30 e0       	ldi	r19, 0x00	; 0
    6144:	84 1b       	sub	r24, r20
    6146:	95 0b       	sbc	r25, r21
    6148:	28 17       	cp	r18, r24
    614a:	39 07       	cpc	r19, r25
    614c:	08 f4       	brcc	.+2      	; 0x6150 <UART_Printf+0xb8>
    614e:	43 c1       	rjmp	.+646    	; 0x63d6 <UART_Printf+0x33e>
    6150:	8b 5c       	subi	r24, 0xCB	; 203
    6152:	9e 4f       	sbci	r25, 0xFE	; 254
    6154:	fc 01       	movw	r30, r24
    6156:	0c 94 36 32 	jmp	0x646c	; 0x646c <__tablejump2__>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    615a:	8f 89       	ldd	r24, Y+23	; 0x17
    615c:	98 8d       	ldd	r25, Y+24	; 0x18
    615e:	9c 01       	movw	r18, r24
    6160:	2e 5f       	subi	r18, 0xFE	; 254
    6162:	3f 4f       	sbci	r19, 0xFF	; 255
    6164:	38 8f       	std	Y+24, r19	; 0x18
    6166:	2f 8b       	std	Y+23, r18	; 0x17
    6168:	fc 01       	movw	r30, r24
    616a:	80 81       	ld	r24, Z
    616c:	91 81       	ldd	r25, Z+1	; 0x01
    616e:	89 87       	std	Y+9, r24	; 0x09
				UART_TxChar(ch);
    6170:	89 85       	ldd	r24, Y+9	; 0x09
    6172:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
				break;
    6176:	2b c1       	rjmp	.+598    	; 0x63ce <UART_Printf+0x336>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, sint16_t);
    6178:	8f 89       	ldd	r24, Y+23	; 0x17
    617a:	98 8d       	ldd	r25, Y+24	; 0x18
    617c:	9c 01       	movw	r18, r24
    617e:	2e 5f       	subi	r18, 0xFE	; 254
    6180:	3f 4f       	sbci	r19, 0xFF	; 255
    6182:	38 8f       	std	Y+24, r19	; 0x18
    6184:	2f 8b       	std	Y+23, r18	; 0x17
    6186:	fc 01       	movw	r30, r24
    6188:	80 81       	ld	r24, Z
    618a:	91 81       	ldd	r25, Z+1	; 0x01
    618c:	9c 83       	std	Y+4, r25	; 0x04
    618e:	8b 83       	std	Y+3, r24	; 0x03
				if(v_num_s16<0)
    6190:	8b 81       	ldd	r24, Y+3	; 0x03
    6192:	9c 81       	ldd	r25, Y+4	; 0x04
    6194:	99 23       	and	r25, r25
    6196:	54 f4       	brge	.+20     	; 0x61ac <UART_Printf+0x114>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   v_num_s16 = -v_num_s16;
    6198:	8b 81       	ldd	r24, Y+3	; 0x03
    619a:	9c 81       	ldd	r25, Y+4	; 0x04
    619c:	91 95       	neg	r25
    619e:	81 95       	neg	r24
    61a0:	91 09       	sbc	r25, r1
    61a2:	9c 83       	std	Y+4, r25	; 0x04
    61a4:	8b 83       	std	Y+3, r24	; 0x03
				   UART_TxChar('-');
    61a6:	8d e2       	ldi	r24, 0x2D	; 45
    61a8:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToTransmit_u8);
    61ac:	8b 81       	ldd	r24, Y+3	; 0x03
    61ae:	9c 81       	ldd	r25, Y+4	; 0x04
    61b0:	aa 27       	eor	r26, r26
    61b2:	97 fd       	sbrc	r25, 7
    61b4:	a0 95       	com	r26
    61b6:	ba 2f       	mov	r27, r26
    61b8:	2a 85       	ldd	r18, Y+10	; 0x0a
    61ba:	ac 01       	movw	r20, r24
    61bc:	bd 01       	movw	r22, r26
    61be:	8a e0       	ldi	r24, 0x0A	; 10
    61c0:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;
    61c4:	04 c1       	rjmp	.+520    	; 0x63ce <UART_Printf+0x336>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);				
    61c6:	8f 89       	ldd	r24, Y+23	; 0x17
    61c8:	98 8d       	ldd	r25, Y+24	; 0x18
    61ca:	9c 01       	movw	r18, r24
    61cc:	2c 5f       	subi	r18, 0xFC	; 252
    61ce:	3f 4f       	sbci	r19, 0xFF	; 255
    61d0:	38 8f       	std	Y+24, r19	; 0x18
    61d2:	2f 8b       	std	Y+23, r18	; 0x17
    61d4:	fc 01       	movw	r30, r24
    61d6:	80 81       	ld	r24, Z
    61d8:	91 81       	ldd	r25, Z+1	; 0x01
    61da:	a2 81       	ldd	r26, Z+2	; 0x02
    61dc:	b3 81       	ldd	r27, Z+3	; 0x03
    61de:	8d 83       	std	Y+5, r24	; 0x05
    61e0:	9e 83       	std	Y+6, r25	; 0x06
    61e2:	af 83       	std	Y+7, r26	; 0x07
    61e4:	b8 87       	std	Y+8, r27	; 0x08
				if(v_num_s32<0)
    61e6:	8d 81       	ldd	r24, Y+5	; 0x05
    61e8:	9e 81       	ldd	r25, Y+6	; 0x06
    61ea:	af 81       	ldd	r26, Y+7	; 0x07
    61ec:	b8 85       	ldd	r27, Y+8	; 0x08
    61ee:	bb 23       	and	r27, r27
    61f0:	94 f4       	brge	.+36     	; 0x6216 <UART_Printf+0x17e>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   v_num_s32 = -v_num_s32;
    61f2:	8d 81       	ldd	r24, Y+5	; 0x05
    61f4:	9e 81       	ldd	r25, Y+6	; 0x06
    61f6:	af 81       	ldd	r26, Y+7	; 0x07
    61f8:	b8 85       	ldd	r27, Y+8	; 0x08
    61fa:	b0 95       	com	r27
    61fc:	a0 95       	com	r26
    61fe:	90 95       	com	r25
    6200:	81 95       	neg	r24
    6202:	9f 4f       	sbci	r25, 0xFF	; 255
    6204:	af 4f       	sbci	r26, 0xFF	; 255
    6206:	bf 4f       	sbci	r27, 0xFF	; 255
    6208:	8d 83       	std	Y+5, r24	; 0x05
    620a:	9e 83       	std	Y+6, r25	; 0x06
    620c:	af 83       	std	Y+7, r26	; 0x07
    620e:	b8 87       	std	Y+8, r27	; 0x08
				   UART_TxChar('-');
    6210:	8d e2       	ldi	r24, 0x2D	; 45
    6212:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToTransmit_u8);			
    6216:	8d 81       	ldd	r24, Y+5	; 0x05
    6218:	9e 81       	ldd	r25, Y+6	; 0x06
    621a:	af 81       	ldd	r26, Y+7	; 0x07
    621c:	b8 85       	ldd	r27, Y+8	; 0x08
    621e:	2a 85       	ldd	r18, Y+10	; 0x0a
    6220:	ac 01       	movw	r20, r24
    6222:	bd 01       	movw	r22, r26
    6224:	8a e0       	ldi	r24, 0x0A	; 10
    6226:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;	
    622a:	d1 c0       	rjmp	.+418    	; 0x63ce <UART_Printf+0x336>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, uint16_t);			
    622c:	8f 89       	ldd	r24, Y+23	; 0x17
    622e:	98 8d       	ldd	r25, Y+24	; 0x18
    6230:	9c 01       	movw	r18, r24
    6232:	2e 5f       	subi	r18, 0xFE	; 254
    6234:	3f 4f       	sbci	r19, 0xFF	; 255
    6236:	38 8f       	std	Y+24, r19	; 0x18
    6238:	2f 8b       	std	Y+23, r18	; 0x17
    623a:	fc 01       	movw	r30, r24
    623c:	80 81       	ld	r24, Z
    623e:	91 81       	ldd	r25, Z+1	; 0x01
    6240:	9c 87       	std	Y+12, r25	; 0x0c
    6242:	8b 87       	std	Y+11, r24	; 0x0b
				UART_TxNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToTransmit_u8);				
    6244:	8b 85       	ldd	r24, Y+11	; 0x0b
    6246:	9c 85       	ldd	r25, Y+12	; 0x0c
    6248:	cc 01       	movw	r24, r24
    624a:	a0 e0       	ldi	r26, 0x00	; 0
    624c:	b0 e0       	ldi	r27, 0x00	; 0
    624e:	2a 85       	ldd	r18, Y+10	; 0x0a
    6250:	ac 01       	movw	r20, r24
    6252:	bd 01       	movw	r22, r26
    6254:	8a e0       	ldi	r24, 0x0A	; 10
    6256:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;
    625a:	b9 c0       	rjmp	.+370    	; 0x63ce <UART_Printf+0x336>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);			
    625c:	8f 89       	ldd	r24, Y+23	; 0x17
    625e:	98 8d       	ldd	r25, Y+24	; 0x18
    6260:	9c 01       	movw	r18, r24
    6262:	2c 5f       	subi	r18, 0xFC	; 252
    6264:	3f 4f       	sbci	r19, 0xFF	; 255
    6266:	38 8f       	std	Y+24, r19	; 0x18
    6268:	2f 8b       	std	Y+23, r18	; 0x17
    626a:	fc 01       	movw	r30, r24
    626c:	80 81       	ld	r24, Z
    626e:	91 81       	ldd	r25, Z+1	; 0x01
    6270:	a2 81       	ldd	r26, Z+2	; 0x02
    6272:	b3 81       	ldd	r27, Z+3	; 0x03
    6274:	8d 87       	std	Y+13, r24	; 0x0d
    6276:	9e 87       	std	Y+14, r25	; 0x0e
    6278:	af 87       	std	Y+15, r26	; 0x0f
    627a:	b8 8b       	std	Y+16, r27	; 0x10
				UART_TxNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    627c:	8d 85       	ldd	r24, Y+13	; 0x0d
    627e:	9e 85       	ldd	r25, Y+14	; 0x0e
    6280:	af 85       	ldd	r26, Y+15	; 0x0f
    6282:	b8 89       	ldd	r27, Y+16	; 0x10
    6284:	2a 85       	ldd	r18, Y+10	; 0x0a
    6286:	ac 01       	movw	r20, r24
    6288:	bd 01       	movw	r22, r26
    628a:	8a e0       	ldi	r24, 0x0A	; 10
    628c:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;			
    6290:	9e c0       	rjmp	.+316    	; 0x63ce <UART_Printf+0x336>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, uint16_t);				
    6292:	8f 89       	ldd	r24, Y+23	; 0x17
    6294:	98 8d       	ldd	r25, Y+24	; 0x18
    6296:	9c 01       	movw	r18, r24
    6298:	2e 5f       	subi	r18, 0xFE	; 254
    629a:	3f 4f       	sbci	r19, 0xFF	; 255
    629c:	38 8f       	std	Y+24, r19	; 0x18
    629e:	2f 8b       	std	Y+23, r18	; 0x17
    62a0:	fc 01       	movw	r30, r24
    62a2:	80 81       	ld	r24, Z
    62a4:	91 81       	ldd	r25, Z+1	; 0x01
    62a6:	9c 87       	std	Y+12, r25	; 0x0c
    62a8:	8b 87       	std	Y+11, r24	; 0x0b
				UART_TxNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
    62aa:	8b 85       	ldd	r24, Y+11	; 0x0b
    62ac:	9c 85       	ldd	r25, Y+12	; 0x0c
    62ae:	cc 01       	movw	r24, r24
    62b0:	a0 e0       	ldi	r26, 0x00	; 0
    62b2:	b0 e0       	ldi	r27, 0x00	; 0
    62b4:	2a 85       	ldd	r18, Y+10	; 0x0a
    62b6:	ac 01       	movw	r20, r24
    62b8:	bd 01       	movw	r22, r26
    62ba:	80 e1       	ldi	r24, 0x10	; 16
    62bc:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;
    62c0:	86 c0       	rjmp	.+268    	; 0x63ce <UART_Printf+0x336>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);						
    62c2:	8f 89       	ldd	r24, Y+23	; 0x17
    62c4:	98 8d       	ldd	r25, Y+24	; 0x18
    62c6:	9c 01       	movw	r18, r24
    62c8:	2c 5f       	subi	r18, 0xFC	; 252
    62ca:	3f 4f       	sbci	r19, 0xFF	; 255
    62cc:	38 8f       	std	Y+24, r19	; 0x18
    62ce:	2f 8b       	std	Y+23, r18	; 0x17
    62d0:	fc 01       	movw	r30, r24
    62d2:	80 81       	ld	r24, Z
    62d4:	91 81       	ldd	r25, Z+1	; 0x01
    62d6:	a2 81       	ldd	r26, Z+2	; 0x02
    62d8:	b3 81       	ldd	r27, Z+3	; 0x03
    62da:	8d 87       	std	Y+13, r24	; 0x0d
    62dc:	9e 87       	std	Y+14, r25	; 0x0e
    62de:	af 87       	std	Y+15, r26	; 0x0f
    62e0:	b8 8b       	std	Y+16, r27	; 0x10
				UART_TxNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    62e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    62e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    62e6:	af 85       	ldd	r26, Y+15	; 0x0f
    62e8:	b8 89       	ldd	r27, Y+16	; 0x10
    62ea:	2a 85       	ldd	r18, Y+10	; 0x0a
    62ec:	ac 01       	movw	r20, r24
    62ee:	bd 01       	movw	r22, r26
    62f0:	80 e1       	ldi	r24, 0x10	; 16
    62f2:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;
    62f6:	6b c0       	rjmp	.+214    	; 0x63ce <UART_Printf+0x336>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, uint16_t);		
    62f8:	8f 89       	ldd	r24, Y+23	; 0x17
    62fa:	98 8d       	ldd	r25, Y+24	; 0x18
    62fc:	9c 01       	movw	r18, r24
    62fe:	2e 5f       	subi	r18, 0xFE	; 254
    6300:	3f 4f       	sbci	r19, 0xFF	; 255
    6302:	38 8f       	std	Y+24, r19	; 0x18
    6304:	2f 8b       	std	Y+23, r18	; 0x17
    6306:	fc 01       	movw	r30, r24
    6308:	80 81       	ld	r24, Z
    630a:	91 81       	ldd	r25, Z+1	; 0x01
    630c:	9c 87       	std	Y+12, r25	; 0x0c
    630e:	8b 87       	std	Y+11, r24	; 0x0b
				
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    6310:	8a 85       	ldd	r24, Y+10	; 0x0a
    6312:	8f 3f       	cpi	r24, 0xFF	; 255
    6314:	11 f4       	brne	.+4      	; 0x631a <UART_Printf+0x282>
				   v_numOfDigitsToTransmit_u8 = 16;
    6316:	80 e1       	ldi	r24, 0x10	; 16
    6318:	8a 87       	std	Y+10, r24	; 0x0a
               
				UART_TxNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
    631a:	8b 85       	ldd	r24, Y+11	; 0x0b
    631c:	9c 85       	ldd	r25, Y+12	; 0x0c
    631e:	cc 01       	movw	r24, r24
    6320:	a0 e0       	ldi	r26, 0x00	; 0
    6322:	b0 e0       	ldi	r27, 0x00	; 0
    6324:	2a 85       	ldd	r18, Y+10	; 0x0a
    6326:	ac 01       	movw	r20, r24
    6328:	bd 01       	movw	r22, r26
    632a:	82 e0       	ldi	r24, 0x02	; 2
    632c:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;
    6330:	4e c0       	rjmp	.+156    	; 0x63ce <UART_Printf+0x336>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);			
    6332:	8f 89       	ldd	r24, Y+23	; 0x17
    6334:	98 8d       	ldd	r25, Y+24	; 0x18
    6336:	9c 01       	movw	r18, r24
    6338:	2c 5f       	subi	r18, 0xFC	; 252
    633a:	3f 4f       	sbci	r19, 0xFF	; 255
    633c:	38 8f       	std	Y+24, r19	; 0x18
    633e:	2f 8b       	std	Y+23, r18	; 0x17
    6340:	fc 01       	movw	r30, r24
    6342:	80 81       	ld	r24, Z
    6344:	91 81       	ldd	r25, Z+1	; 0x01
    6346:	a2 81       	ldd	r26, Z+2	; 0x02
    6348:	b3 81       	ldd	r27, Z+3	; 0x03
    634a:	8d 87       	std	Y+13, r24	; 0x0d
    634c:	9e 87       	std	Y+14, r25	; 0x0e
    634e:	af 87       	std	Y+15, r26	; 0x0f
    6350:	b8 8b       	std	Y+16, r27	; 0x10
                
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    6352:	8a 85       	ldd	r24, Y+10	; 0x0a
    6354:	8f 3f       	cpi	r24, 0xFF	; 255
    6356:	11 f4       	brne	.+4      	; 0x635c <UART_Printf+0x2c4>
				   v_numOfDigitsToTransmit_u8 = 32;		
    6358:	80 e2       	ldi	r24, 0x20	; 32
    635a:	8a 87       	std	Y+10, r24	; 0x0a
               
				UART_TxNumber(C_BINARY_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    635c:	8d 85       	ldd	r24, Y+13	; 0x0d
    635e:	9e 85       	ldd	r25, Y+14	; 0x0e
    6360:	af 85       	ldd	r26, Y+15	; 0x0f
    6362:	b8 89       	ldd	r27, Y+16	; 0x10
    6364:	2a 85       	ldd	r18, Y+10	; 0x0a
    6366:	ac 01       	movw	r20, r24
    6368:	bd 01       	movw	r22, r26
    636a:	82 e0       	ldi	r24, 0x02	; 2
    636c:	0e 94 f8 2e 	call	0x5df0	; 0x5df0 <UART_TxNumber>
				break;
    6370:	2e c0       	rjmp	.+92     	; 0x63ce <UART_Printf+0x336>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_UART_TxFloatNumber==1)				
				v_floatNum_f32 = va_arg(argp, double);				
    6372:	8f 89       	ldd	r24, Y+23	; 0x17
    6374:	98 8d       	ldd	r25, Y+24	; 0x18
    6376:	9c 01       	movw	r18, r24
    6378:	2c 5f       	subi	r18, 0xFC	; 252
    637a:	3f 4f       	sbci	r19, 0xFF	; 255
    637c:	38 8f       	std	Y+24, r19	; 0x18
    637e:	2f 8b       	std	Y+23, r18	; 0x17
    6380:	fc 01       	movw	r30, r24
    6382:	80 81       	ld	r24, Z
    6384:	91 81       	ldd	r25, Z+1	; 0x01
    6386:	a2 81       	ldd	r26, Z+2	; 0x02
    6388:	b3 81       	ldd	r27, Z+3	; 0x03
    638a:	89 8b       	std	Y+17, r24	; 0x11
    638c:	9a 8b       	std	Y+18, r25	; 0x12
    638e:	ab 8b       	std	Y+19, r26	; 0x13
    6390:	bc 8b       	std	Y+20, r27	; 0x14
				UART_TxFloatNumber(v_floatNum_f32);
    6392:	89 89       	ldd	r24, Y+17	; 0x11
    6394:	9a 89       	ldd	r25, Y+18	; 0x12
    6396:	ab 89       	ldd	r26, Y+19	; 0x13
    6398:	bc 89       	ldd	r27, Y+20	; 0x14
    639a:	bc 01       	movw	r22, r24
    639c:	cd 01       	movw	r24, r26
    639e:	0e 94 e6 2f 	call	0x5fcc	; 0x5fcc <UART_TxFloatNumber>
#endif            
				break;                
    63a2:	15 c0       	rjmp	.+42     	; 0x63ce <UART_Printf+0x336>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
    63a4:	8f 89       	ldd	r24, Y+23	; 0x17
    63a6:	98 8d       	ldd	r25, Y+24	; 0x18
    63a8:	9c 01       	movw	r18, r24
    63aa:	2e 5f       	subi	r18, 0xFE	; 254
    63ac:	3f 4f       	sbci	r19, 0xFF	; 255
    63ae:	38 8f       	std	Y+24, r19	; 0x18
    63b0:	2f 8b       	std	Y+23, r18	; 0x17
    63b2:	fc 01       	movw	r30, r24
    63b4:	80 81       	ld	r24, Z
    63b6:	91 81       	ldd	r25, Z+1	; 0x01
    63b8:	9e 8b       	std	Y+22, r25	; 0x16
    63ba:	8d 8b       	std	Y+21, r24	; 0x15
				UART_TxString(str);			
    63bc:	8d 89       	ldd	r24, Y+21	; 0x15
    63be:	9e 89       	ldd	r25, Y+22	; 0x16
    63c0:	0e 94 8e 2e 	call	0x5d1c	; 0x5d1c <UART_TxString>
				break;
    63c4:	04 c0       	rjmp	.+8      	; 0x63ce <UART_Printf+0x336>

			case '%':
				UART_TxChar('%');
    63c6:	85 e2       	ldi	r24, 0x25	; 37
    63c8:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>
				break;
    63cc:	00 00       	nop
    63ce:	03 c0       	rjmp	.+6      	; 0x63d6 <UART_Printf+0x33e>
			}
		}
		else
		{
			/* As '%' is not detected transmit the char passed */
			UART_TxChar(ch);
    63d0:	89 85       	ldd	r24, Y+9	; 0x09
    63d2:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <UART_TxChar>


	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    63d6:	89 81       	ldd	r24, Y+1	; 0x01
    63d8:	9a 81       	ldd	r25, Y+2	; 0x02
    63da:	01 96       	adiw	r24, 0x01	; 1
    63dc:	9a 83       	std	Y+2, r25	; 0x02
    63de:	89 83       	std	Y+1, r24	; 0x01
    63e0:	89 81       	ldd	r24, Y+1	; 0x01
    63e2:	9a 81       	ldd	r25, Y+2	; 0x02
    63e4:	fc 01       	movw	r30, r24
    63e6:	80 81       	ld	r24, Z
    63e8:	88 23       	and	r24, r24
    63ea:	09 f0       	breq	.+2      	; 0x63ee <UART_Printf+0x356>
    63ec:	68 ce       	rjmp	.-816    	; 0x60be <UART_Printf+0x26>
			UART_TxChar(ch);
		}
	}

	va_end(argp);
}
    63ee:	68 96       	adiw	r28, 0x18	; 24
    63f0:	0f b6       	in	r0, 0x3f	; 63
    63f2:	f8 94       	cli
    63f4:	de bf       	out	0x3e, r29	; 62
    63f6:	0f be       	out	0x3f, r0	; 63
    63f8:	cd bf       	out	0x3d, r28	; 61
    63fa:	df 91       	pop	r29
    63fc:	cf 91       	pop	r28
    63fe:	08 95       	ret

00006400 <__divmodhi4>:
    6400:	97 fb       	bst	r25, 7
    6402:	07 2e       	mov	r0, r23
    6404:	16 f4       	brtc	.+4      	; 0x640a <__divmodhi4+0xa>
    6406:	00 94       	com	r0
    6408:	07 d0       	rcall	.+14     	; 0x6418 <__divmodhi4_neg1>
    640a:	77 fd       	sbrc	r23, 7
    640c:	09 d0       	rcall	.+18     	; 0x6420 <__divmodhi4_neg2>
    640e:	0e 94 3c 32 	call	0x6478	; 0x6478 <__udivmodhi4>
    6412:	07 fc       	sbrc	r0, 7
    6414:	05 d0       	rcall	.+10     	; 0x6420 <__divmodhi4_neg2>
    6416:	3e f4       	brtc	.+14     	; 0x6426 <__divmodhi4_exit>

00006418 <__divmodhi4_neg1>:
    6418:	90 95       	com	r25
    641a:	81 95       	neg	r24
    641c:	9f 4f       	sbci	r25, 0xFF	; 255
    641e:	08 95       	ret

00006420 <__divmodhi4_neg2>:
    6420:	70 95       	com	r23
    6422:	61 95       	neg	r22
    6424:	7f 4f       	sbci	r23, 0xFF	; 255

00006426 <__divmodhi4_exit>:
    6426:	08 95       	ret

00006428 <__udivmodsi4>:
    6428:	a1 e2       	ldi	r26, 0x21	; 33
    642a:	1a 2e       	mov	r1, r26
    642c:	aa 1b       	sub	r26, r26
    642e:	bb 1b       	sub	r27, r27
    6430:	fd 01       	movw	r30, r26
    6432:	0d c0       	rjmp	.+26     	; 0x644e <__udivmodsi4_ep>

00006434 <__udivmodsi4_loop>:
    6434:	aa 1f       	adc	r26, r26
    6436:	bb 1f       	adc	r27, r27
    6438:	ee 1f       	adc	r30, r30
    643a:	ff 1f       	adc	r31, r31
    643c:	a2 17       	cp	r26, r18
    643e:	b3 07       	cpc	r27, r19
    6440:	e4 07       	cpc	r30, r20
    6442:	f5 07       	cpc	r31, r21
    6444:	20 f0       	brcs	.+8      	; 0x644e <__udivmodsi4_ep>
    6446:	a2 1b       	sub	r26, r18
    6448:	b3 0b       	sbc	r27, r19
    644a:	e4 0b       	sbc	r30, r20
    644c:	f5 0b       	sbc	r31, r21

0000644e <__udivmodsi4_ep>:
    644e:	66 1f       	adc	r22, r22
    6450:	77 1f       	adc	r23, r23
    6452:	88 1f       	adc	r24, r24
    6454:	99 1f       	adc	r25, r25
    6456:	1a 94       	dec	r1
    6458:	69 f7       	brne	.-38     	; 0x6434 <__udivmodsi4_loop>
    645a:	60 95       	com	r22
    645c:	70 95       	com	r23
    645e:	80 95       	com	r24
    6460:	90 95       	com	r25
    6462:	9b 01       	movw	r18, r22
    6464:	ac 01       	movw	r20, r24
    6466:	bd 01       	movw	r22, r26
    6468:	cf 01       	movw	r24, r30
    646a:	08 95       	ret

0000646c <__tablejump2__>:
    646c:	ee 0f       	add	r30, r30
    646e:	ff 1f       	adc	r31, r31

00006470 <__tablejump__>:
    6470:	05 90       	lpm	r0, Z+
    6472:	f4 91       	lpm	r31, Z
    6474:	e0 2d       	mov	r30, r0
    6476:	09 94       	ijmp

00006478 <__udivmodhi4>:
    6478:	aa 1b       	sub	r26, r26
    647a:	bb 1b       	sub	r27, r27
    647c:	51 e1       	ldi	r21, 0x11	; 17
    647e:	07 c0       	rjmp	.+14     	; 0x648e <__udivmodhi4_ep>

00006480 <__udivmodhi4_loop>:
    6480:	aa 1f       	adc	r26, r26
    6482:	bb 1f       	adc	r27, r27
    6484:	a6 17       	cp	r26, r22
    6486:	b7 07       	cpc	r27, r23
    6488:	10 f0       	brcs	.+4      	; 0x648e <__udivmodhi4_ep>
    648a:	a6 1b       	sub	r26, r22
    648c:	b7 0b       	sbc	r27, r23

0000648e <__udivmodhi4_ep>:
    648e:	88 1f       	adc	r24, r24
    6490:	99 1f       	adc	r25, r25
    6492:	5a 95       	dec	r21
    6494:	a9 f7       	brne	.-22     	; 0x6480 <__udivmodhi4_loop>
    6496:	80 95       	com	r24
    6498:	90 95       	com	r25
    649a:	bc 01       	movw	r22, r24
    649c:	cd 01       	movw	r24, r26
    649e:	08 95       	ret

000064a0 <__subsf3>:
    64a0:	50 58       	subi	r21, 0x80	; 128

000064a2 <__addsf3>:
    64a2:	bb 27       	eor	r27, r27
    64a4:	aa 27       	eor	r26, r26
    64a6:	0e d0       	rcall	.+28     	; 0x64c4 <__addsf3x>
    64a8:	70 c1       	rjmp	.+736    	; 0x678a <__fp_round>
    64aa:	61 d1       	rcall	.+706    	; 0x676e <__fp_pscA>
    64ac:	30 f0       	brcs	.+12     	; 0x64ba <__addsf3+0x18>
    64ae:	66 d1       	rcall	.+716    	; 0x677c <__fp_pscB>
    64b0:	20 f0       	brcs	.+8      	; 0x64ba <__addsf3+0x18>
    64b2:	31 f4       	brne	.+12     	; 0x64c0 <__addsf3+0x1e>
    64b4:	9f 3f       	cpi	r25, 0xFF	; 255
    64b6:	11 f4       	brne	.+4      	; 0x64bc <__addsf3+0x1a>
    64b8:	1e f4       	brtc	.+6      	; 0x64c0 <__addsf3+0x1e>
    64ba:	56 c1       	rjmp	.+684    	; 0x6768 <__fp_nan>
    64bc:	0e f4       	brtc	.+2      	; 0x64c0 <__addsf3+0x1e>
    64be:	e0 95       	com	r30
    64c0:	e7 fb       	bst	r30, 7
    64c2:	4c c1       	rjmp	.+664    	; 0x675c <__fp_inf>

000064c4 <__addsf3x>:
    64c4:	e9 2f       	mov	r30, r25
    64c6:	72 d1       	rcall	.+740    	; 0x67ac <__fp_split3>
    64c8:	80 f3       	brcs	.-32     	; 0x64aa <__addsf3+0x8>
    64ca:	ba 17       	cp	r27, r26
    64cc:	62 07       	cpc	r22, r18
    64ce:	73 07       	cpc	r23, r19
    64d0:	84 07       	cpc	r24, r20
    64d2:	95 07       	cpc	r25, r21
    64d4:	18 f0       	brcs	.+6      	; 0x64dc <__addsf3x+0x18>
    64d6:	71 f4       	brne	.+28     	; 0x64f4 <__addsf3x+0x30>
    64d8:	9e f5       	brtc	.+102    	; 0x6540 <__addsf3x+0x7c>
    64da:	8a c1       	rjmp	.+788    	; 0x67f0 <__fp_zero>
    64dc:	0e f4       	brtc	.+2      	; 0x64e0 <__addsf3x+0x1c>
    64de:	e0 95       	com	r30
    64e0:	0b 2e       	mov	r0, r27
    64e2:	ba 2f       	mov	r27, r26
    64e4:	a0 2d       	mov	r26, r0
    64e6:	0b 01       	movw	r0, r22
    64e8:	b9 01       	movw	r22, r18
    64ea:	90 01       	movw	r18, r0
    64ec:	0c 01       	movw	r0, r24
    64ee:	ca 01       	movw	r24, r20
    64f0:	a0 01       	movw	r20, r0
    64f2:	11 24       	eor	r1, r1
    64f4:	ff 27       	eor	r31, r31
    64f6:	59 1b       	sub	r21, r25
    64f8:	99 f0       	breq	.+38     	; 0x6520 <__addsf3x+0x5c>
    64fa:	59 3f       	cpi	r21, 0xF9	; 249
    64fc:	50 f4       	brcc	.+20     	; 0x6512 <__addsf3x+0x4e>
    64fe:	50 3e       	cpi	r21, 0xE0	; 224
    6500:	68 f1       	brcs	.+90     	; 0x655c <__addsf3x+0x98>
    6502:	1a 16       	cp	r1, r26
    6504:	f0 40       	sbci	r31, 0x00	; 0
    6506:	a2 2f       	mov	r26, r18
    6508:	23 2f       	mov	r18, r19
    650a:	34 2f       	mov	r19, r20
    650c:	44 27       	eor	r20, r20
    650e:	58 5f       	subi	r21, 0xF8	; 248
    6510:	f3 cf       	rjmp	.-26     	; 0x64f8 <__addsf3x+0x34>
    6512:	46 95       	lsr	r20
    6514:	37 95       	ror	r19
    6516:	27 95       	ror	r18
    6518:	a7 95       	ror	r26
    651a:	f0 40       	sbci	r31, 0x00	; 0
    651c:	53 95       	inc	r21
    651e:	c9 f7       	brne	.-14     	; 0x6512 <__addsf3x+0x4e>
    6520:	7e f4       	brtc	.+30     	; 0x6540 <__addsf3x+0x7c>
    6522:	1f 16       	cp	r1, r31
    6524:	ba 0b       	sbc	r27, r26
    6526:	62 0b       	sbc	r22, r18
    6528:	73 0b       	sbc	r23, r19
    652a:	84 0b       	sbc	r24, r20
    652c:	ba f0       	brmi	.+46     	; 0x655c <__addsf3x+0x98>
    652e:	91 50       	subi	r25, 0x01	; 1
    6530:	a1 f0       	breq	.+40     	; 0x655a <__addsf3x+0x96>
    6532:	ff 0f       	add	r31, r31
    6534:	bb 1f       	adc	r27, r27
    6536:	66 1f       	adc	r22, r22
    6538:	77 1f       	adc	r23, r23
    653a:	88 1f       	adc	r24, r24
    653c:	c2 f7       	brpl	.-16     	; 0x652e <__addsf3x+0x6a>
    653e:	0e c0       	rjmp	.+28     	; 0x655c <__addsf3x+0x98>
    6540:	ba 0f       	add	r27, r26
    6542:	62 1f       	adc	r22, r18
    6544:	73 1f       	adc	r23, r19
    6546:	84 1f       	adc	r24, r20
    6548:	48 f4       	brcc	.+18     	; 0x655c <__addsf3x+0x98>
    654a:	87 95       	ror	r24
    654c:	77 95       	ror	r23
    654e:	67 95       	ror	r22
    6550:	b7 95       	ror	r27
    6552:	f7 95       	ror	r31
    6554:	9e 3f       	cpi	r25, 0xFE	; 254
    6556:	08 f0       	brcs	.+2      	; 0x655a <__addsf3x+0x96>
    6558:	b3 cf       	rjmp	.-154    	; 0x64c0 <__addsf3+0x1e>
    655a:	93 95       	inc	r25
    655c:	88 0f       	add	r24, r24
    655e:	08 f0       	brcs	.+2      	; 0x6562 <__addsf3x+0x9e>
    6560:	99 27       	eor	r25, r25
    6562:	ee 0f       	add	r30, r30
    6564:	97 95       	ror	r25
    6566:	87 95       	ror	r24
    6568:	08 95       	ret

0000656a <__cmpsf2>:
    656a:	d4 d0       	rcall	.+424    	; 0x6714 <__fp_cmp>
    656c:	08 f4       	brcc	.+2      	; 0x6570 <__cmpsf2+0x6>
    656e:	81 e0       	ldi	r24, 0x01	; 1
    6570:	08 95       	ret

00006572 <__divsf3>:
    6572:	0c d0       	rcall	.+24     	; 0x658c <__divsf3x>
    6574:	0a c1       	rjmp	.+532    	; 0x678a <__fp_round>
    6576:	02 d1       	rcall	.+516    	; 0x677c <__fp_pscB>
    6578:	40 f0       	brcs	.+16     	; 0x658a <__divsf3+0x18>
    657a:	f9 d0       	rcall	.+498    	; 0x676e <__fp_pscA>
    657c:	30 f0       	brcs	.+12     	; 0x658a <__divsf3+0x18>
    657e:	21 f4       	brne	.+8      	; 0x6588 <__divsf3+0x16>
    6580:	5f 3f       	cpi	r21, 0xFF	; 255
    6582:	19 f0       	breq	.+6      	; 0x658a <__divsf3+0x18>
    6584:	eb c0       	rjmp	.+470    	; 0x675c <__fp_inf>
    6586:	51 11       	cpse	r21, r1
    6588:	34 c1       	rjmp	.+616    	; 0x67f2 <__fp_szero>
    658a:	ee c0       	rjmp	.+476    	; 0x6768 <__fp_nan>

0000658c <__divsf3x>:
    658c:	0f d1       	rcall	.+542    	; 0x67ac <__fp_split3>
    658e:	98 f3       	brcs	.-26     	; 0x6576 <__divsf3+0x4>

00006590 <__divsf3_pse>:
    6590:	99 23       	and	r25, r25
    6592:	c9 f3       	breq	.-14     	; 0x6586 <__divsf3+0x14>
    6594:	55 23       	and	r21, r21
    6596:	b1 f3       	breq	.-20     	; 0x6584 <__divsf3+0x12>
    6598:	95 1b       	sub	r25, r21
    659a:	55 0b       	sbc	r21, r21
    659c:	bb 27       	eor	r27, r27
    659e:	aa 27       	eor	r26, r26
    65a0:	62 17       	cp	r22, r18
    65a2:	73 07       	cpc	r23, r19
    65a4:	84 07       	cpc	r24, r20
    65a6:	38 f0       	brcs	.+14     	; 0x65b6 <__divsf3_pse+0x26>
    65a8:	9f 5f       	subi	r25, 0xFF	; 255
    65aa:	5f 4f       	sbci	r21, 0xFF	; 255
    65ac:	22 0f       	add	r18, r18
    65ae:	33 1f       	adc	r19, r19
    65b0:	44 1f       	adc	r20, r20
    65b2:	aa 1f       	adc	r26, r26
    65b4:	a9 f3       	breq	.-22     	; 0x65a0 <__divsf3_pse+0x10>
    65b6:	33 d0       	rcall	.+102    	; 0x661e <__divsf3_pse+0x8e>
    65b8:	0e 2e       	mov	r0, r30
    65ba:	3a f0       	brmi	.+14     	; 0x65ca <__divsf3_pse+0x3a>
    65bc:	e0 e8       	ldi	r30, 0x80	; 128
    65be:	30 d0       	rcall	.+96     	; 0x6620 <__divsf3_pse+0x90>
    65c0:	91 50       	subi	r25, 0x01	; 1
    65c2:	50 40       	sbci	r21, 0x00	; 0
    65c4:	e6 95       	lsr	r30
    65c6:	00 1c       	adc	r0, r0
    65c8:	ca f7       	brpl	.-14     	; 0x65bc <__divsf3_pse+0x2c>
    65ca:	29 d0       	rcall	.+82     	; 0x661e <__divsf3_pse+0x8e>
    65cc:	fe 2f       	mov	r31, r30
    65ce:	27 d0       	rcall	.+78     	; 0x661e <__divsf3_pse+0x8e>
    65d0:	66 0f       	add	r22, r22
    65d2:	77 1f       	adc	r23, r23
    65d4:	88 1f       	adc	r24, r24
    65d6:	bb 1f       	adc	r27, r27
    65d8:	26 17       	cp	r18, r22
    65da:	37 07       	cpc	r19, r23
    65dc:	48 07       	cpc	r20, r24
    65de:	ab 07       	cpc	r26, r27
    65e0:	b0 e8       	ldi	r27, 0x80	; 128
    65e2:	09 f0       	breq	.+2      	; 0x65e6 <__divsf3_pse+0x56>
    65e4:	bb 0b       	sbc	r27, r27
    65e6:	80 2d       	mov	r24, r0
    65e8:	bf 01       	movw	r22, r30
    65ea:	ff 27       	eor	r31, r31
    65ec:	93 58       	subi	r25, 0x83	; 131
    65ee:	5f 4f       	sbci	r21, 0xFF	; 255
    65f0:	2a f0       	brmi	.+10     	; 0x65fc <__divsf3_pse+0x6c>
    65f2:	9e 3f       	cpi	r25, 0xFE	; 254
    65f4:	51 05       	cpc	r21, r1
    65f6:	68 f0       	brcs	.+26     	; 0x6612 <__divsf3_pse+0x82>
    65f8:	b1 c0       	rjmp	.+354    	; 0x675c <__fp_inf>
    65fa:	fb c0       	rjmp	.+502    	; 0x67f2 <__fp_szero>
    65fc:	5f 3f       	cpi	r21, 0xFF	; 255
    65fe:	ec f3       	brlt	.-6      	; 0x65fa <__divsf3_pse+0x6a>
    6600:	98 3e       	cpi	r25, 0xE8	; 232
    6602:	dc f3       	brlt	.-10     	; 0x65fa <__divsf3_pse+0x6a>
    6604:	86 95       	lsr	r24
    6606:	77 95       	ror	r23
    6608:	67 95       	ror	r22
    660a:	b7 95       	ror	r27
    660c:	f7 95       	ror	r31
    660e:	9f 5f       	subi	r25, 0xFF	; 255
    6610:	c9 f7       	brne	.-14     	; 0x6604 <__divsf3_pse+0x74>
    6612:	88 0f       	add	r24, r24
    6614:	91 1d       	adc	r25, r1
    6616:	96 95       	lsr	r25
    6618:	87 95       	ror	r24
    661a:	97 f9       	bld	r25, 7
    661c:	08 95       	ret
    661e:	e1 e0       	ldi	r30, 0x01	; 1
    6620:	66 0f       	add	r22, r22
    6622:	77 1f       	adc	r23, r23
    6624:	88 1f       	adc	r24, r24
    6626:	bb 1f       	adc	r27, r27
    6628:	62 17       	cp	r22, r18
    662a:	73 07       	cpc	r23, r19
    662c:	84 07       	cpc	r24, r20
    662e:	ba 07       	cpc	r27, r26
    6630:	20 f0       	brcs	.+8      	; 0x663a <__divsf3_pse+0xaa>
    6632:	62 1b       	sub	r22, r18
    6634:	73 0b       	sbc	r23, r19
    6636:	84 0b       	sbc	r24, r20
    6638:	ba 0b       	sbc	r27, r26
    663a:	ee 1f       	adc	r30, r30
    663c:	88 f7       	brcc	.-30     	; 0x6620 <__divsf3_pse+0x90>
    663e:	e0 95       	com	r30
    6640:	08 95       	ret

00006642 <__fixunssfsi>:
    6642:	bc d0       	rcall	.+376    	; 0x67bc <__fp_splitA>
    6644:	88 f0       	brcs	.+34     	; 0x6668 <__fixunssfsi+0x26>
    6646:	9f 57       	subi	r25, 0x7F	; 127
    6648:	90 f0       	brcs	.+36     	; 0x666e <__fixunssfsi+0x2c>
    664a:	b9 2f       	mov	r27, r25
    664c:	99 27       	eor	r25, r25
    664e:	b7 51       	subi	r27, 0x17	; 23
    6650:	a0 f0       	brcs	.+40     	; 0x667a <__fixunssfsi+0x38>
    6652:	d1 f0       	breq	.+52     	; 0x6688 <__fixunssfsi+0x46>
    6654:	66 0f       	add	r22, r22
    6656:	77 1f       	adc	r23, r23
    6658:	88 1f       	adc	r24, r24
    665a:	99 1f       	adc	r25, r25
    665c:	1a f0       	brmi	.+6      	; 0x6664 <__fixunssfsi+0x22>
    665e:	ba 95       	dec	r27
    6660:	c9 f7       	brne	.-14     	; 0x6654 <__fixunssfsi+0x12>
    6662:	12 c0       	rjmp	.+36     	; 0x6688 <__fixunssfsi+0x46>
    6664:	b1 30       	cpi	r27, 0x01	; 1
    6666:	81 f0       	breq	.+32     	; 0x6688 <__fixunssfsi+0x46>
    6668:	c3 d0       	rcall	.+390    	; 0x67f0 <__fp_zero>
    666a:	b1 e0       	ldi	r27, 0x01	; 1
    666c:	08 95       	ret
    666e:	c0 c0       	rjmp	.+384    	; 0x67f0 <__fp_zero>
    6670:	67 2f       	mov	r22, r23
    6672:	78 2f       	mov	r23, r24
    6674:	88 27       	eor	r24, r24
    6676:	b8 5f       	subi	r27, 0xF8	; 248
    6678:	39 f0       	breq	.+14     	; 0x6688 <__fixunssfsi+0x46>
    667a:	b9 3f       	cpi	r27, 0xF9	; 249
    667c:	cc f3       	brlt	.-14     	; 0x6670 <__fixunssfsi+0x2e>
    667e:	86 95       	lsr	r24
    6680:	77 95       	ror	r23
    6682:	67 95       	ror	r22
    6684:	b3 95       	inc	r27
    6686:	d9 f7       	brne	.-10     	; 0x667e <__fixunssfsi+0x3c>
    6688:	3e f4       	brtc	.+14     	; 0x6698 <__fixunssfsi+0x56>
    668a:	90 95       	com	r25
    668c:	80 95       	com	r24
    668e:	70 95       	com	r23
    6690:	61 95       	neg	r22
    6692:	7f 4f       	sbci	r23, 0xFF	; 255
    6694:	8f 4f       	sbci	r24, 0xFF	; 255
    6696:	9f 4f       	sbci	r25, 0xFF	; 255
    6698:	08 95       	ret

0000669a <__floatunsisf>:
    669a:	e8 94       	clt
    669c:	09 c0       	rjmp	.+18     	; 0x66b0 <__floatsisf+0x12>

0000669e <__floatsisf>:
    669e:	97 fb       	bst	r25, 7
    66a0:	3e f4       	brtc	.+14     	; 0x66b0 <__floatsisf+0x12>
    66a2:	90 95       	com	r25
    66a4:	80 95       	com	r24
    66a6:	70 95       	com	r23
    66a8:	61 95       	neg	r22
    66aa:	7f 4f       	sbci	r23, 0xFF	; 255
    66ac:	8f 4f       	sbci	r24, 0xFF	; 255
    66ae:	9f 4f       	sbci	r25, 0xFF	; 255
    66b0:	99 23       	and	r25, r25
    66b2:	a9 f0       	breq	.+42     	; 0x66de <__floatsisf+0x40>
    66b4:	f9 2f       	mov	r31, r25
    66b6:	96 e9       	ldi	r25, 0x96	; 150
    66b8:	bb 27       	eor	r27, r27
    66ba:	93 95       	inc	r25
    66bc:	f6 95       	lsr	r31
    66be:	87 95       	ror	r24
    66c0:	77 95       	ror	r23
    66c2:	67 95       	ror	r22
    66c4:	b7 95       	ror	r27
    66c6:	f1 11       	cpse	r31, r1
    66c8:	f8 cf       	rjmp	.-16     	; 0x66ba <__floatsisf+0x1c>
    66ca:	fa f4       	brpl	.+62     	; 0x670a <__floatsisf+0x6c>
    66cc:	bb 0f       	add	r27, r27
    66ce:	11 f4       	brne	.+4      	; 0x66d4 <__floatsisf+0x36>
    66d0:	60 ff       	sbrs	r22, 0
    66d2:	1b c0       	rjmp	.+54     	; 0x670a <__floatsisf+0x6c>
    66d4:	6f 5f       	subi	r22, 0xFF	; 255
    66d6:	7f 4f       	sbci	r23, 0xFF	; 255
    66d8:	8f 4f       	sbci	r24, 0xFF	; 255
    66da:	9f 4f       	sbci	r25, 0xFF	; 255
    66dc:	16 c0       	rjmp	.+44     	; 0x670a <__floatsisf+0x6c>
    66de:	88 23       	and	r24, r24
    66e0:	11 f0       	breq	.+4      	; 0x66e6 <__floatsisf+0x48>
    66e2:	96 e9       	ldi	r25, 0x96	; 150
    66e4:	11 c0       	rjmp	.+34     	; 0x6708 <__floatsisf+0x6a>
    66e6:	77 23       	and	r23, r23
    66e8:	21 f0       	breq	.+8      	; 0x66f2 <__floatsisf+0x54>
    66ea:	9e e8       	ldi	r25, 0x8E	; 142
    66ec:	87 2f       	mov	r24, r23
    66ee:	76 2f       	mov	r23, r22
    66f0:	05 c0       	rjmp	.+10     	; 0x66fc <__floatsisf+0x5e>
    66f2:	66 23       	and	r22, r22
    66f4:	71 f0       	breq	.+28     	; 0x6712 <__floatsisf+0x74>
    66f6:	96 e8       	ldi	r25, 0x86	; 134
    66f8:	86 2f       	mov	r24, r22
    66fa:	70 e0       	ldi	r23, 0x00	; 0
    66fc:	60 e0       	ldi	r22, 0x00	; 0
    66fe:	2a f0       	brmi	.+10     	; 0x670a <__floatsisf+0x6c>
    6700:	9a 95       	dec	r25
    6702:	66 0f       	add	r22, r22
    6704:	77 1f       	adc	r23, r23
    6706:	88 1f       	adc	r24, r24
    6708:	da f7       	brpl	.-10     	; 0x6700 <__floatsisf+0x62>
    670a:	88 0f       	add	r24, r24
    670c:	96 95       	lsr	r25
    670e:	87 95       	ror	r24
    6710:	97 f9       	bld	r25, 7
    6712:	08 95       	ret

00006714 <__fp_cmp>:
    6714:	99 0f       	add	r25, r25
    6716:	00 08       	sbc	r0, r0
    6718:	55 0f       	add	r21, r21
    671a:	aa 0b       	sbc	r26, r26
    671c:	e0 e8       	ldi	r30, 0x80	; 128
    671e:	fe ef       	ldi	r31, 0xFE	; 254
    6720:	16 16       	cp	r1, r22
    6722:	17 06       	cpc	r1, r23
    6724:	e8 07       	cpc	r30, r24
    6726:	f9 07       	cpc	r31, r25
    6728:	c0 f0       	brcs	.+48     	; 0x675a <__fp_cmp+0x46>
    672a:	12 16       	cp	r1, r18
    672c:	13 06       	cpc	r1, r19
    672e:	e4 07       	cpc	r30, r20
    6730:	f5 07       	cpc	r31, r21
    6732:	98 f0       	brcs	.+38     	; 0x675a <__fp_cmp+0x46>
    6734:	62 1b       	sub	r22, r18
    6736:	73 0b       	sbc	r23, r19
    6738:	84 0b       	sbc	r24, r20
    673a:	95 0b       	sbc	r25, r21
    673c:	39 f4       	brne	.+14     	; 0x674c <__fp_cmp+0x38>
    673e:	0a 26       	eor	r0, r26
    6740:	61 f0       	breq	.+24     	; 0x675a <__fp_cmp+0x46>
    6742:	23 2b       	or	r18, r19
    6744:	24 2b       	or	r18, r20
    6746:	25 2b       	or	r18, r21
    6748:	21 f4       	brne	.+8      	; 0x6752 <__fp_cmp+0x3e>
    674a:	08 95       	ret
    674c:	0a 26       	eor	r0, r26
    674e:	09 f4       	brne	.+2      	; 0x6752 <__fp_cmp+0x3e>
    6750:	a1 40       	sbci	r26, 0x01	; 1
    6752:	a6 95       	lsr	r26
    6754:	8f ef       	ldi	r24, 0xFF	; 255
    6756:	81 1d       	adc	r24, r1
    6758:	81 1d       	adc	r24, r1
    675a:	08 95       	ret

0000675c <__fp_inf>:
    675c:	97 f9       	bld	r25, 7
    675e:	9f 67       	ori	r25, 0x7F	; 127
    6760:	80 e8       	ldi	r24, 0x80	; 128
    6762:	70 e0       	ldi	r23, 0x00	; 0
    6764:	60 e0       	ldi	r22, 0x00	; 0
    6766:	08 95       	ret

00006768 <__fp_nan>:
    6768:	9f ef       	ldi	r25, 0xFF	; 255
    676a:	80 ec       	ldi	r24, 0xC0	; 192
    676c:	08 95       	ret

0000676e <__fp_pscA>:
    676e:	00 24       	eor	r0, r0
    6770:	0a 94       	dec	r0
    6772:	16 16       	cp	r1, r22
    6774:	17 06       	cpc	r1, r23
    6776:	18 06       	cpc	r1, r24
    6778:	09 06       	cpc	r0, r25
    677a:	08 95       	ret

0000677c <__fp_pscB>:
    677c:	00 24       	eor	r0, r0
    677e:	0a 94       	dec	r0
    6780:	12 16       	cp	r1, r18
    6782:	13 06       	cpc	r1, r19
    6784:	14 06       	cpc	r1, r20
    6786:	05 06       	cpc	r0, r21
    6788:	08 95       	ret

0000678a <__fp_round>:
    678a:	09 2e       	mov	r0, r25
    678c:	03 94       	inc	r0
    678e:	00 0c       	add	r0, r0
    6790:	11 f4       	brne	.+4      	; 0x6796 <__fp_round+0xc>
    6792:	88 23       	and	r24, r24
    6794:	52 f0       	brmi	.+20     	; 0x67aa <__fp_round+0x20>
    6796:	bb 0f       	add	r27, r27
    6798:	40 f4       	brcc	.+16     	; 0x67aa <__fp_round+0x20>
    679a:	bf 2b       	or	r27, r31
    679c:	11 f4       	brne	.+4      	; 0x67a2 <__fp_round+0x18>
    679e:	60 ff       	sbrs	r22, 0
    67a0:	04 c0       	rjmp	.+8      	; 0x67aa <__fp_round+0x20>
    67a2:	6f 5f       	subi	r22, 0xFF	; 255
    67a4:	7f 4f       	sbci	r23, 0xFF	; 255
    67a6:	8f 4f       	sbci	r24, 0xFF	; 255
    67a8:	9f 4f       	sbci	r25, 0xFF	; 255
    67aa:	08 95       	ret

000067ac <__fp_split3>:
    67ac:	57 fd       	sbrc	r21, 7
    67ae:	90 58       	subi	r25, 0x80	; 128
    67b0:	44 0f       	add	r20, r20
    67b2:	55 1f       	adc	r21, r21
    67b4:	59 f0       	breq	.+22     	; 0x67cc <__fp_splitA+0x10>
    67b6:	5f 3f       	cpi	r21, 0xFF	; 255
    67b8:	71 f0       	breq	.+28     	; 0x67d6 <__fp_splitA+0x1a>
    67ba:	47 95       	ror	r20

000067bc <__fp_splitA>:
    67bc:	88 0f       	add	r24, r24
    67be:	97 fb       	bst	r25, 7
    67c0:	99 1f       	adc	r25, r25
    67c2:	61 f0       	breq	.+24     	; 0x67dc <__fp_splitA+0x20>
    67c4:	9f 3f       	cpi	r25, 0xFF	; 255
    67c6:	79 f0       	breq	.+30     	; 0x67e6 <__fp_splitA+0x2a>
    67c8:	87 95       	ror	r24
    67ca:	08 95       	ret
    67cc:	12 16       	cp	r1, r18
    67ce:	13 06       	cpc	r1, r19
    67d0:	14 06       	cpc	r1, r20
    67d2:	55 1f       	adc	r21, r21
    67d4:	f2 cf       	rjmp	.-28     	; 0x67ba <__fp_split3+0xe>
    67d6:	46 95       	lsr	r20
    67d8:	f1 df       	rcall	.-30     	; 0x67bc <__fp_splitA>
    67da:	08 c0       	rjmp	.+16     	; 0x67ec <__fp_splitA+0x30>
    67dc:	16 16       	cp	r1, r22
    67de:	17 06       	cpc	r1, r23
    67e0:	18 06       	cpc	r1, r24
    67e2:	99 1f       	adc	r25, r25
    67e4:	f1 cf       	rjmp	.-30     	; 0x67c8 <__fp_splitA+0xc>
    67e6:	86 95       	lsr	r24
    67e8:	71 05       	cpc	r23, r1
    67ea:	61 05       	cpc	r22, r1
    67ec:	08 94       	sec
    67ee:	08 95       	ret

000067f0 <__fp_zero>:
    67f0:	e8 94       	clt

000067f2 <__fp_szero>:
    67f2:	bb 27       	eor	r27, r27
    67f4:	66 27       	eor	r22, r22
    67f6:	77 27       	eor	r23, r23
    67f8:	cb 01       	movw	r24, r22
    67fa:	97 f9       	bld	r25, 7
    67fc:	08 95       	ret

000067fe <__gesf2>:
    67fe:	8a df       	rcall	.-236    	; 0x6714 <__fp_cmp>
    6800:	08 f4       	brcc	.+2      	; 0x6804 <__gesf2+0x6>
    6802:	8f ef       	ldi	r24, 0xFF	; 255
    6804:	08 95       	ret

00006806 <__mulsf3>:
    6806:	0b d0       	rcall	.+22     	; 0x681e <__mulsf3x>
    6808:	c0 cf       	rjmp	.-128    	; 0x678a <__fp_round>
    680a:	b1 df       	rcall	.-158    	; 0x676e <__fp_pscA>
    680c:	28 f0       	brcs	.+10     	; 0x6818 <__mulsf3+0x12>
    680e:	b6 df       	rcall	.-148    	; 0x677c <__fp_pscB>
    6810:	18 f0       	brcs	.+6      	; 0x6818 <__mulsf3+0x12>
    6812:	95 23       	and	r25, r21
    6814:	09 f0       	breq	.+2      	; 0x6818 <__mulsf3+0x12>
    6816:	a2 cf       	rjmp	.-188    	; 0x675c <__fp_inf>
    6818:	a7 cf       	rjmp	.-178    	; 0x6768 <__fp_nan>
    681a:	11 24       	eor	r1, r1
    681c:	ea cf       	rjmp	.-44     	; 0x67f2 <__fp_szero>

0000681e <__mulsf3x>:
    681e:	c6 df       	rcall	.-116    	; 0x67ac <__fp_split3>
    6820:	a0 f3       	brcs	.-24     	; 0x680a <__mulsf3+0x4>

00006822 <__mulsf3_pse>:
    6822:	95 9f       	mul	r25, r21
    6824:	d1 f3       	breq	.-12     	; 0x681a <__mulsf3+0x14>
    6826:	95 0f       	add	r25, r21
    6828:	50 e0       	ldi	r21, 0x00	; 0
    682a:	55 1f       	adc	r21, r21
    682c:	62 9f       	mul	r22, r18
    682e:	f0 01       	movw	r30, r0
    6830:	72 9f       	mul	r23, r18
    6832:	bb 27       	eor	r27, r27
    6834:	f0 0d       	add	r31, r0
    6836:	b1 1d       	adc	r27, r1
    6838:	63 9f       	mul	r22, r19
    683a:	aa 27       	eor	r26, r26
    683c:	f0 0d       	add	r31, r0
    683e:	b1 1d       	adc	r27, r1
    6840:	aa 1f       	adc	r26, r26
    6842:	64 9f       	mul	r22, r20
    6844:	66 27       	eor	r22, r22
    6846:	b0 0d       	add	r27, r0
    6848:	a1 1d       	adc	r26, r1
    684a:	66 1f       	adc	r22, r22
    684c:	82 9f       	mul	r24, r18
    684e:	22 27       	eor	r18, r18
    6850:	b0 0d       	add	r27, r0
    6852:	a1 1d       	adc	r26, r1
    6854:	62 1f       	adc	r22, r18
    6856:	73 9f       	mul	r23, r19
    6858:	b0 0d       	add	r27, r0
    685a:	a1 1d       	adc	r26, r1
    685c:	62 1f       	adc	r22, r18
    685e:	83 9f       	mul	r24, r19
    6860:	a0 0d       	add	r26, r0
    6862:	61 1d       	adc	r22, r1
    6864:	22 1f       	adc	r18, r18
    6866:	74 9f       	mul	r23, r20
    6868:	33 27       	eor	r19, r19
    686a:	a0 0d       	add	r26, r0
    686c:	61 1d       	adc	r22, r1
    686e:	23 1f       	adc	r18, r19
    6870:	84 9f       	mul	r24, r20
    6872:	60 0d       	add	r22, r0
    6874:	21 1d       	adc	r18, r1
    6876:	82 2f       	mov	r24, r18
    6878:	76 2f       	mov	r23, r22
    687a:	6a 2f       	mov	r22, r26
    687c:	11 24       	eor	r1, r1
    687e:	9f 57       	subi	r25, 0x7F	; 127
    6880:	50 40       	sbci	r21, 0x00	; 0
    6882:	8a f0       	brmi	.+34     	; 0x68a6 <__mulsf3_pse+0x84>
    6884:	e1 f0       	breq	.+56     	; 0x68be <__mulsf3_pse+0x9c>
    6886:	88 23       	and	r24, r24
    6888:	4a f0       	brmi	.+18     	; 0x689c <__mulsf3_pse+0x7a>
    688a:	ee 0f       	add	r30, r30
    688c:	ff 1f       	adc	r31, r31
    688e:	bb 1f       	adc	r27, r27
    6890:	66 1f       	adc	r22, r22
    6892:	77 1f       	adc	r23, r23
    6894:	88 1f       	adc	r24, r24
    6896:	91 50       	subi	r25, 0x01	; 1
    6898:	50 40       	sbci	r21, 0x00	; 0
    689a:	a9 f7       	brne	.-22     	; 0x6886 <__mulsf3_pse+0x64>
    689c:	9e 3f       	cpi	r25, 0xFE	; 254
    689e:	51 05       	cpc	r21, r1
    68a0:	70 f0       	brcs	.+28     	; 0x68be <__mulsf3_pse+0x9c>
    68a2:	5c cf       	rjmp	.-328    	; 0x675c <__fp_inf>
    68a4:	a6 cf       	rjmp	.-180    	; 0x67f2 <__fp_szero>
    68a6:	5f 3f       	cpi	r21, 0xFF	; 255
    68a8:	ec f3       	brlt	.-6      	; 0x68a4 <__mulsf3_pse+0x82>
    68aa:	98 3e       	cpi	r25, 0xE8	; 232
    68ac:	dc f3       	brlt	.-10     	; 0x68a4 <__mulsf3_pse+0x82>
    68ae:	86 95       	lsr	r24
    68b0:	77 95       	ror	r23
    68b2:	67 95       	ror	r22
    68b4:	b7 95       	ror	r27
    68b6:	f7 95       	ror	r31
    68b8:	e7 95       	ror	r30
    68ba:	9f 5f       	subi	r25, 0xFF	; 255
    68bc:	c1 f7       	brne	.-16     	; 0x68ae <__mulsf3_pse+0x8c>
    68be:	fe 2b       	or	r31, r30
    68c0:	88 0f       	add	r24, r24
    68c2:	91 1d       	adc	r25, r1
    68c4:	96 95       	lsr	r25
    68c6:	87 95       	ror	r24
    68c8:	97 f9       	bld	r25, 7
    68ca:	08 95       	ret

000068cc <_exit>:
    68cc:	f8 94       	cli

000068ce <__stop_program>:
    68ce:	ff cf       	rjmp	.-2      	; 0x68ce <__stop_program>
