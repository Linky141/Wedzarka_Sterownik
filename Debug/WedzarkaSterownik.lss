
WedzarkaSterownik.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004290  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000092  00800060  00004290  00004324  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003a  008000f2  008000f2  000043b6  2**0
                  ALLOC
  3 .stab         00005940  00000000  00000000  000043b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000027c7  00000000  00000000  00009cf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000030  00000000  00000000  0000c4bf  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 01 	jmp	0x312	; 0x312 <__ctors_end>
       4:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
       8:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
       c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      10:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      14:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      18:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      1c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      20:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      24:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      28:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      2c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      30:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      34:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      38:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      3c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      40:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      44:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      48:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      4c:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      50:	0c 94 a6 01 	jmp	0x34c	; 0x34c <__bad_interrupt>
      54:	cb 0d       	add	r28, r11
      56:	d5 0f       	add	r29, r21
      58:	d5 0f       	add	r29, r21
      5a:	d5 0f       	add	r29, r21
      5c:	d5 0f       	add	r29, r21
      5e:	d5 0f       	add	r29, r21
      60:	d5 0f       	add	r29, r21
      62:	ae 0e       	add	r10, r30
      64:	d5 0f       	add	r29, r21
      66:	8c 0f       	add	r24, r28
      68:	d5 0f       	add	r29, r21
      6a:	d5 0f       	add	r29, r21
      6c:	d5 0f       	add	r29, r21
      6e:	d5 0f       	add	r29, r21
      70:	d5 0f       	add	r29, r21
      72:	d5 0f       	add	r29, r21
      74:	d5 0f       	add	r29, r21
      76:	d5 0f       	add	r29, r21
      78:	d5 0f       	add	r29, r21
      7a:	d5 0f       	add	r29, r21
      7c:	d5 0f       	add	r29, r21
      7e:	d4 0e       	add	r13, r20
      80:	fa 0e       	add	r15, r26
      82:	16 0e       	add	r1, r22
      84:	d5 0f       	add	r29, r21
      86:	f0 0d       	add	r31, r0
      88:	20 0f       	add	r18, r16
      8a:	d5 0f       	add	r29, r21
      8c:	d5 0f       	add	r29, r21
      8e:	d5 0f       	add	r29, r21
      90:	d5 0f       	add	r29, r21
      92:	d5 0f       	add	r29, r21
      94:	d5 0f       	add	r29, r21
      96:	d5 0f       	add	r29, r21
      98:	d5 0f       	add	r29, r21
      9a:	d5 0f       	add	r29, r21
      9c:	d5 0f       	add	r29, r21
      9e:	d5 0f       	add	r29, r21
      a0:	d5 0f       	add	r29, r21
      a2:	d5 0f       	add	r29, r21
      a4:	d5 0f       	add	r29, r21
      a6:	d5 0f       	add	r29, r21
      a8:	d5 0f       	add	r29, r21
      aa:	d5 0f       	add	r29, r21
      ac:	d5 0f       	add	r29, r21
      ae:	d5 0f       	add	r29, r21
      b0:	d5 0f       	add	r29, r21
      b2:	d5 0f       	add	r29, r21
      b4:	d5 0f       	add	r29, r21
      b6:	d5 0f       	add	r29, r21
      b8:	d5 0f       	add	r29, r21
      ba:	d5 0f       	add	r29, r21
      bc:	d5 0f       	add	r29, r21
      be:	d5 0f       	add	r29, r21
      c0:	44 0f       	add	r20, r20
      c2:	d5 0f       	add	r29, r21
      c4:	68 0f       	add	r22, r24
      c6:	d5 0f       	add	r29, r21
      c8:	d5 0f       	add	r29, r21
      ca:	d5 0f       	add	r29, r21
      cc:	d5 0f       	add	r29, r21
      ce:	d5 0f       	add	r29, r21
      d0:	d5 0f       	add	r29, r21
      d2:	d5 0f       	add	r29, r21
      d4:	d5 0f       	add	r29, r21
      d6:	d5 0f       	add	r29, r21
      d8:	d5 0f       	add	r29, r21
      da:	d5 0f       	add	r29, r21
      dc:	d5 0f       	add	r29, r21
      de:	d5 0f       	add	r29, r21
      e0:	d5 0f       	add	r29, r21
      e2:	d5 0f       	add	r29, r21
      e4:	d5 0f       	add	r29, r21
      e6:	d5 0f       	add	r29, r21
      e8:	d5 0f       	add	r29, r21
      ea:	d5 0f       	add	r29, r21
      ec:	d5 0f       	add	r29, r21
      ee:	d5 0f       	add	r29, r21
      f0:	d5 0f       	add	r29, r21
      f2:	d5 0f       	add	r29, r21
      f4:	d5 0f       	add	r29, r21
      f6:	d5 0f       	add	r29, r21
      f8:	d5 0f       	add	r29, r21
      fa:	d5 0f       	add	r29, r21
      fc:	d5 0f       	add	r29, r21
      fe:	d5 0f       	add	r29, r21
     100:	62 0e       	add	r6, r18
     102:	3c 0e       	add	r3, r28
     104:	88 0e       	add	r8, r24
     106:	f2 15       	cp	r31, r2
     108:	27 16       	cp	r2, r23
     10a:	27 16       	cp	r2, r23
     10c:	27 16       	cp	r2, r23
     10e:	27 16       	cp	r2, r23
     110:	27 16       	cp	r2, r23
     112:	27 16       	cp	r2, r23
     114:	a0 13       	cpse	r26, r16
     116:	27 16       	cp	r2, r23
     118:	3c 14       	cp	r3, r12
     11a:	27 16       	cp	r2, r23
     11c:	27 16       	cp	r2, r23
     11e:	27 16       	cp	r2, r23
     120:	27 16       	cp	r2, r23
     122:	27 16       	cp	r2, r23
     124:	27 16       	cp	r2, r23
     126:	27 16       	cp	r2, r23
     128:	27 16       	cp	r2, r23
     12a:	27 16       	cp	r2, r23
     12c:	27 16       	cp	r2, r23
     12e:	27 16       	cp	r2, r23
     130:	bb 13       	cpse	r27, r27
     132:	d6 13       	cpse	r29, r22
     134:	34 13       	cpse	r19, r20
     136:	27 16       	cp	r2, r23
     138:	19 13       	cpse	r17, r25
     13a:	f1 13       	cpse	r31, r17
     13c:	27 16       	cp	r2, r23
     13e:	27 16       	cp	r2, r23
     140:	b4 15       	cp	r27, r4
     142:	55 14       	cp	r5, r5
     144:	be 14       	cp	r11, r14
     146:	27 16       	cp	r2, r23
     148:	0c 16       	cp	r0, r28
     14a:	27 16       	cp	r2, r23
     14c:	27 16       	cp	r2, r23
     14e:	27 16       	cp	r2, r23
     150:	27 16       	cp	r2, r23
     152:	27 16       	cp	r2, r23
     154:	27 16       	cp	r2, r23
     156:	27 16       	cp	r2, r23
     158:	27 16       	cp	r2, r23
     15a:	27 16       	cp	r2, r23
     15c:	27 16       	cp	r2, r23
     15e:	27 16       	cp	r2, r23
     160:	27 16       	cp	r2, r23
     162:	db 15       	cp	r29, r11
     164:	27 16       	cp	r2, r23
     166:	2d 15       	cp	r18, r13
     168:	27 16       	cp	r2, r23
     16a:	27 16       	cp	r2, r23
     16c:	6e 15       	cp	r22, r14
     16e:	27 16       	cp	r2, r23
     170:	27 16       	cp	r2, r23
     172:	0a 14       	cp	r0, r10
     174:	27 16       	cp	r2, r23
     176:	23 14       	cp	r2, r3
     178:	27 16       	cp	r2, r23
     17a:	27 16       	cp	r2, r23
     17c:	27 16       	cp	r2, r23
     17e:	27 16       	cp	r2, r23
     180:	90 15       	cp	r25, r0
     182:	55 14       	cp	r5, r5
     184:	7a 14       	cp	r7, r10
     186:	27 16       	cp	r2, r23
     188:	0c 16       	cp	r0, r28
     18a:	27 16       	cp	r2, r23
     18c:	27 16       	cp	r2, r23
     18e:	27 16       	cp	r2, r23
     190:	27 16       	cp	r2, r23
     192:	27 16       	cp	r2, r23
     194:	27 16       	cp	r2, r23
     196:	27 16       	cp	r2, r23
     198:	27 16       	cp	r2, r23
     19a:	27 16       	cp	r2, r23
     19c:	27 16       	cp	r2, r23
     19e:	27 16       	cp	r2, r23
     1a0:	27 16       	cp	r2, r23
     1a2:	db 15       	cp	r29, r11
     1a4:	27 16       	cp	r2, r23
     1a6:	0e 15       	cp	r16, r14
     1a8:	27 16       	cp	r2, r23
     1aa:	27 16       	cp	r2, r23
     1ac:	4f 15       	cp	r20, r15
     1ae:	27 16       	cp	r2, r23
     1b0:	27 16       	cp	r2, r23
     1b2:	6a 13       	cpse	r22, r26
     1b4:	4f 13       	cpse	r20, r31
     1b6:	85 13       	cpse	r24, r21
     1b8:	f2 17       	cp	r31, r18
     1ba:	fb 17       	cp	r31, r27
     1bc:	fb 17       	cp	r31, r27
     1be:	fb 17       	cp	r31, r27
     1c0:	fb 17       	cp	r31, r27
     1c2:	fb 17       	cp	r31, r27
     1c4:	fb 17       	cp	r31, r27
     1c6:	ba 16       	cp	r11, r26
     1c8:	fb 17       	cp	r31, r27
     1ca:	d2 16       	cp	r13, r18
     1cc:	fb 17       	cp	r31, r27
     1ce:	fb 17       	cp	r31, r27
     1d0:	fb 17       	cp	r31, r27
     1d2:	fb 17       	cp	r31, r27
     1d4:	fb 17       	cp	r31, r27
     1d6:	fb 17       	cp	r31, r27
     1d8:	fb 17       	cp	r31, r27
     1da:	fb 17       	cp	r31, r27
     1dc:	fb 17       	cp	r31, r27
     1de:	fb 17       	cp	r31, r27
     1e0:	fb 17       	cp	r31, r27
     1e2:	bf 16       	cp	r11, r31
     1e4:	c4 16       	cp	r12, r20
     1e6:	a6 16       	cp	r10, r22
     1e8:	fb 17       	cp	r31, r27
     1ea:	a1 16       	cp	r10, r17
     1ec:	c9 16       	cp	r12, r25
     1ee:	fb 17       	cp	r31, r27
     1f0:	fb 17       	cp	r31, r27
     1f2:	c1 17       	cp	r28, r17
     1f4:	d5 16       	cp	r13, r21
     1f6:	0b 17       	cp	r16, r27
     1f8:	fb 17       	cp	r31, r27
     1fa:	f6 17       	cp	r31, r22
     1fc:	fb 17       	cp	r31, r27
     1fe:	fb 17       	cp	r31, r27
     200:	fb 17       	cp	r31, r27
     202:	fb 17       	cp	r31, r27
     204:	fb 17       	cp	r31, r27
     206:	fb 17       	cp	r31, r27
     208:	fb 17       	cp	r31, r27
     20a:	fb 17       	cp	r31, r27
     20c:	fb 17       	cp	r31, r27
     20e:	fb 17       	cp	r31, r27
     210:	fb 17       	cp	r31, r27
     212:	fb 17       	cp	r31, r27
     214:	e1 17       	cp	r30, r17
     216:	fb 17       	cp	r31, r27
     218:	56 17       	cp	r21, r22
     21a:	fb 17       	cp	r31, r27
     21c:	fb 17       	cp	r31, r27
     21e:	89 17       	cp	r24, r25
     220:	fb 17       	cp	r31, r27
     222:	fb 17       	cp	r31, r27
     224:	cc 16       	cp	r12, r28
     226:	fb 17       	cp	r31, r27
     228:	cf 16       	cp	r12, r31
     22a:	fb 17       	cp	r31, r27
     22c:	fb 17       	cp	r31, r27
     22e:	fb 17       	cp	r31, r27
     230:	fb 17       	cp	r31, r27
     232:	a4 17       	cp	r26, r20
     234:	d5 16       	cp	r13, r21
     236:	e4 16       	cp	r14, r20
     238:	fb 17       	cp	r31, r27
     23a:	f6 17       	cp	r31, r22
     23c:	fb 17       	cp	r31, r27
     23e:	fb 17       	cp	r31, r27
     240:	fb 17       	cp	r31, r27
     242:	fb 17       	cp	r31, r27
     244:	fb 17       	cp	r31, r27
     246:	fb 17       	cp	r31, r27
     248:	fb 17       	cp	r31, r27
     24a:	fb 17       	cp	r31, r27
     24c:	fb 17       	cp	r31, r27
     24e:	fb 17       	cp	r31, r27
     250:	fb 17       	cp	r31, r27
     252:	fb 17       	cp	r31, r27
     254:	e1 17       	cp	r30, r17
     256:	fb 17       	cp	r31, r27
     258:	3e 17       	cp	r19, r30
     25a:	fb 17       	cp	r31, r27
     25c:	fb 17       	cp	r31, r27
     25e:	71 17       	cp	r23, r17
     260:	fb 17       	cp	r31, r27
     262:	fb 17       	cp	r31, r27
     264:	b0 16       	cp	r11, r16
     266:	ab 16       	cp	r10, r27
     268:	b5 16       	cp	r11, r21
     26a:	eb 1e       	adc	r14, r27
     26c:	f3 1e       	adc	r15, r19
     26e:	f3 1e       	adc	r15, r19
     270:	f3 1e       	adc	r15, r19
     272:	f3 1e       	adc	r15, r19
     274:	f3 1e       	adc	r15, r19
     276:	f3 1e       	adc	r15, r19
     278:	f3 1e       	adc	r15, r19
     27a:	f3 1e       	adc	r15, r19
     27c:	f3 1e       	adc	r15, r19
     27e:	f3 1e       	adc	r15, r19
     280:	f3 1e       	adc	r15, r19
     282:	f3 1e       	adc	r15, r19
     284:	f3 1e       	adc	r15, r19
     286:	f3 1e       	adc	r15, r19
     288:	f3 1e       	adc	r15, r19
     28a:	f3 1e       	adc	r15, r19
     28c:	f3 1e       	adc	r15, r19
     28e:	f3 1e       	adc	r15, r19
     290:	f3 1e       	adc	r15, r19
     292:	f3 1e       	adc	r15, r19
     294:	f3 1e       	adc	r15, r19
     296:	f3 1e       	adc	r15, r19
     298:	f3 1e       	adc	r15, r19
     29a:	f3 1e       	adc	r15, r19
     29c:	f3 1e       	adc	r15, r19
     29e:	f3 1e       	adc	r15, r19
     2a0:	f3 1e       	adc	r15, r19
     2a2:	f3 1e       	adc	r15, r19
     2a4:	a1 1e       	adc	r10, r17
     2a6:	b5 1d       	adc	r27, r5
     2a8:	eb 1d       	adc	r30, r11
     2aa:	f3 1e       	adc	r15, r19
     2ac:	c1 1e       	adc	r12, r17
     2ae:	f3 1e       	adc	r15, r19
     2b0:	f3 1e       	adc	r15, r19
     2b2:	f3 1e       	adc	r15, r19
     2b4:	f3 1e       	adc	r15, r19
     2b6:	f3 1e       	adc	r15, r19
     2b8:	f3 1e       	adc	r15, r19
     2ba:	f3 1e       	adc	r15, r19
     2bc:	f3 1e       	adc	r15, r19
     2be:	f3 1e       	adc	r15, r19
     2c0:	f3 1e       	adc	r15, r19
     2c2:	f3 1e       	adc	r15, r19
     2c4:	f3 1e       	adc	r15, r19
     2c6:	da 1e       	adc	r13, r26
     2c8:	f3 1e       	adc	r15, r19
     2ca:	36 1e       	adc	r3, r22
     2cc:	f3 1e       	adc	r15, r19
     2ce:	f3 1e       	adc	r15, r19
     2d0:	69 1e       	adc	r6, r25
     2d2:	f3 1e       	adc	r15, r19
     2d4:	f3 1e       	adc	r15, r19
     2d6:	f3 1e       	adc	r15, r19
     2d8:	f3 1e       	adc	r15, r19
     2da:	f3 1e       	adc	r15, r19
     2dc:	f3 1e       	adc	r15, r19
     2de:	f3 1e       	adc	r15, r19
     2e0:	f3 1e       	adc	r15, r19
     2e2:	f3 1e       	adc	r15, r19
     2e4:	84 1e       	adc	r8, r20
     2e6:	b5 1d       	adc	r27, r5
     2e8:	c4 1d       	adc	r28, r4
     2ea:	f3 1e       	adc	r15, r19
     2ec:	c1 1e       	adc	r12, r17
     2ee:	f3 1e       	adc	r15, r19
     2f0:	f3 1e       	adc	r15, r19
     2f2:	f3 1e       	adc	r15, r19
     2f4:	f3 1e       	adc	r15, r19
     2f6:	f3 1e       	adc	r15, r19
     2f8:	f3 1e       	adc	r15, r19
     2fa:	f3 1e       	adc	r15, r19
     2fc:	f3 1e       	adc	r15, r19
     2fe:	f3 1e       	adc	r15, r19
     300:	f3 1e       	adc	r15, r19
     302:	f3 1e       	adc	r15, r19
     304:	f3 1e       	adc	r15, r19
     306:	da 1e       	adc	r13, r26
     308:	f3 1e       	adc	r15, r19
     30a:	1e 1e       	adc	r1, r30
     30c:	f3 1e       	adc	r15, r19
     30e:	f3 1e       	adc	r15, r19
     310:	51 1e       	adc	r5, r17

00000312 <__ctors_end>:
     312:	11 24       	eor	r1, r1
     314:	1f be       	out	0x3f, r1	; 63
     316:	cf e5       	ldi	r28, 0x5F	; 95
     318:	d4 e0       	ldi	r29, 0x04	; 4
     31a:	de bf       	out	0x3e, r29	; 62
     31c:	cd bf       	out	0x3d, r28	; 61

0000031e <__do_copy_data>:
     31e:	10 e0       	ldi	r17, 0x00	; 0
     320:	a0 e6       	ldi	r26, 0x60	; 96
     322:	b0 e0       	ldi	r27, 0x00	; 0
     324:	e0 e9       	ldi	r30, 0x90	; 144
     326:	f2 e4       	ldi	r31, 0x42	; 66
     328:	02 c0       	rjmp	.+4      	; 0x32e <__do_copy_data+0x10>
     32a:	05 90       	lpm	r0, Z+
     32c:	0d 92       	st	X+, r0
     32e:	a2 3f       	cpi	r26, 0xF2	; 242
     330:	b1 07       	cpc	r27, r17
     332:	d9 f7       	brne	.-10     	; 0x32a <__do_copy_data+0xc>

00000334 <__do_clear_bss>:
     334:	21 e0       	ldi	r18, 0x01	; 1
     336:	a2 ef       	ldi	r26, 0xF2	; 242
     338:	b0 e0       	ldi	r27, 0x00	; 0
     33a:	01 c0       	rjmp	.+2      	; 0x33e <.do_clear_bss_start>

0000033c <.do_clear_bss_loop>:
     33c:	1d 92       	st	X+, r1

0000033e <.do_clear_bss_start>:
     33e:	ac 32       	cpi	r26, 0x2C	; 44
     340:	b2 07       	cpc	r27, r18
     342:	e1 f7       	brne	.-8      	; 0x33c <.do_clear_bss_loop>
     344:	0e 94 a8 01 	call	0x350	; 0x350 <main>
     348:	0c 94 46 21 	jmp	0x428c	; 0x428c <_exit>

0000034c <__bad_interrupt>:
     34c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000350 <main>:
bool mute = false;
uint8_t histerezeLock = 0;
uint16_t lcdRefreshClock = 0;

/* MAIN PROGRAM */
int main() {
     350:	cf 93       	push	r28
     352:	df 93       	push	r29
     354:	cd b7       	in	r28, 0x3d	; 61
     356:	de b7       	in	r29, 0x3e	; 62

	while(1){
		beep(500, 500);
     358:	64 ef       	ldi	r22, 0xF4	; 244
     35a:	71 e0       	ldi	r23, 0x01	; 1
     35c:	84 ef       	ldi	r24, 0xF4	; 244
     35e:	91 e0       	ldi	r25, 0x01	; 1
     360:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>
		DELAY_ms(100);
     364:	84 e6       	ldi	r24, 0x64	; 100
     366:	90 e0       	ldi	r25, 0x00	; 0
     368:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
	}
     36c:	f5 cf       	rjmp	.-22     	; 0x358 <main+0x8>

0000036e <Initialization>:

	return 0;
}

/* FUNCTIONS */
void Initialization() {
     36e:	8f 92       	push	r8
     370:	af 92       	push	r10
     372:	cf 92       	push	r12
     374:	ef 92       	push	r14
     376:	0f 93       	push	r16
     378:	cf 93       	push	r28
     37a:	df 93       	push	r29
     37c:	cd b7       	in	r28, 0x3d	; 61
     37e:	de b7       	in	r29, 0x3e	; 62

	MAX6675();
     380:	0e 94 2c 05 	call	0xa58	; 0xa58 <MAX6675>
	/*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
	LCD_SetUp(PA_0, PA_1, PA_2, P_NC, P_NC, P_NC, P_NC, PA_3, PA_4, PA_5, PA_6);
     384:	86 e0       	ldi	r24, 0x06	; 6
     386:	8f 93       	push	r24
     388:	85 e0       	ldi	r24, 0x05	; 5
     38a:	8f 93       	push	r24
     38c:	68 94       	set
     38e:	88 24       	eor	r8, r8
     390:	82 f8       	bld	r8, 2
     392:	0f 2e       	mov	r0, r31
     394:	f3 e0       	ldi	r31, 0x03	; 3
     396:	af 2e       	mov	r10, r31
     398:	f0 2d       	mov	r31, r0
     39a:	cc 24       	eor	r12, r12
     39c:	ca 94       	dec	r12
     39e:	ee 24       	eor	r14, r14
     3a0:	ea 94       	dec	r14
     3a2:	0f ef       	ldi	r16, 0xFF	; 255
     3a4:	2f ef       	ldi	r18, 0xFF	; 255
     3a6:	42 e0       	ldi	r20, 0x02	; 2
     3a8:	61 e0       	ldi	r22, 0x01	; 1
     3aa:	80 e0       	ldi	r24, 0x00	; 0
     3ac:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <LCD_SetUp>
     3b0:	0f 90       	pop	r0
     3b2:	0f 90       	pop	r0
	LCD_Init(2, 8);
     3b4:	68 e0       	ldi	r22, 0x08	; 8
     3b6:	82 e0       	ldi	r24, 0x02	; 2
     3b8:	0e 94 84 0c 	call	0x1908	; 0x1908 <LCD_Init>

	DDRB = 0x00;
     3bc:	87 e3       	ldi	r24, 0x37	; 55
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	fc 01       	movw	r30, r24
     3c2:	10 82       	st	Z, r1
	DDRD = 0xff;
     3c4:	81 e3       	ldi	r24, 0x31	; 49
     3c6:	90 e0       	ldi	r25, 0x00	; 0
     3c8:	2f ef       	ldi	r18, 0xFF	; 255
     3ca:	fc 01       	movw	r30, r24
     3cc:	20 83       	st	Z, r18
	PORTB = 0xff;
     3ce:	88 e3       	ldi	r24, 0x38	; 56
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	2f ef       	ldi	r18, 0xFF	; 255
     3d4:	fc 01       	movw	r30, r24
     3d6:	20 83       	st	Z, r18
	PORTD = 0xff;
     3d8:	82 e3       	ldi	r24, 0x32	; 50
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	2f ef       	ldi	r18, 0xFF	; 255
     3de:	fc 01       	movw	r30, r24
     3e0:	20 83       	st	Z, r18

	Lamp(true);
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	0e 94 c6 04 	call	0x98c	; 0x98c <Lamp>
	beep(600, 200);
     3e8:	68 ec       	ldi	r22, 0xC8	; 200
     3ea:	70 e0       	ldi	r23, 0x00	; 0
     3ec:	88 e5       	ldi	r24, 0x58	; 88
     3ee:	92 e0       	ldi	r25, 0x02	; 2
     3f0:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>
	beep(600, 300);
     3f4:	6c e2       	ldi	r22, 0x2C	; 44
     3f6:	71 e0       	ldi	r23, 0x01	; 1
     3f8:	88 e5       	ldi	r24, 0x58	; 88
     3fa:	92 e0       	ldi	r25, 0x02	; 2
     3fc:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>
	beep(600, 200);
     400:	68 ec       	ldi	r22, 0xC8	; 200
     402:	70 e0       	ldi	r23, 0x00	; 0
     404:	88 e5       	ldi	r24, 0x58	; 88
     406:	92 e0       	ldi	r25, 0x02	; 2
     408:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>
	Lamp(false);
     40c:	80 e0       	ldi	r24, 0x00	; 0
     40e:	0e 94 c6 04 	call	0x98c	; 0x98c <Lamp>
	while(true){
		if(lcdRefreshClock >= LCD_REFRESH_TIME){
     412:	80 91 fa 00 	lds	r24, 0x00FA
     416:	90 91 fb 00 	lds	r25, 0x00FB
     41a:	80 32       	cpi	r24, 0x20	; 32
     41c:	fe e4       	ldi	r31, 0x4E	; 78
     41e:	9f 07       	cpc	r25, r31
     420:	b0 f1       	brcs	.+108    	; 0x48e <__stack+0x2f>
			LCD_Clear();
     422:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
			LCD_XYPrintf(0, 0, "Min temp");
     426:	8a e6       	ldi	r24, 0x6A	; 106
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	89 2f       	mov	r24, r25
     42c:	8f 93       	push	r24
     42e:	8a e6       	ldi	r24, 0x6A	; 106
     430:	90 e0       	ldi	r25, 0x00	; 0
     432:	8f 93       	push	r24
     434:	1f 92       	push	r1
     436:	1f 92       	push	r1
     438:	1f 92       	push	r1
     43a:	1f 92       	push	r1
     43c:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     440:	0f 90       	pop	r0
     442:	0f 90       	pop	r0
     444:	0f 90       	pop	r0
     446:	0f 90       	pop	r0
     448:	0f 90       	pop	r0
     44a:	0f 90       	pop	r0
			LCD_XYPrintf(0, 1, ": %d", minTemp);
     44c:	80 91 f2 00 	lds	r24, 0x00F2
     450:	90 91 f3 00 	lds	r25, 0x00F3
     454:	29 2f       	mov	r18, r25
     456:	2f 93       	push	r18
     458:	8f 93       	push	r24
     45a:	83 e7       	ldi	r24, 0x73	; 115
     45c:	90 e0       	ldi	r25, 0x00	; 0
     45e:	89 2f       	mov	r24, r25
     460:	8f 93       	push	r24
     462:	83 e7       	ldi	r24, 0x73	; 115
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	8f 93       	push	r24
     468:	1f 92       	push	r1
     46a:	81 e0       	ldi	r24, 0x01	; 1
     46c:	8f 93       	push	r24
     46e:	1f 92       	push	r1
     470:	1f 92       	push	r1
     472:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     476:	8d b7       	in	r24, 0x3d	; 61
     478:	9e b7       	in	r25, 0x3e	; 62
     47a:	08 96       	adiw	r24, 0x08	; 8
     47c:	0f b6       	in	r0, 0x3f	; 63
     47e:	f8 94       	cli
     480:	de bf       	out	0x3e, r29	; 62
     482:	0f be       	out	0x3f, r0	; 63
     484:	cd bf       	out	0x3d, r28	; 61
			lcdRefreshClock = 0;
     486:	10 92 fb 00 	sts	0x00FB, r1
     48a:	10 92 fa 00 	sts	0x00FA, r1
		}
		if(BTN_PLUS && minTemp < MAXIMUM_TEMPERATURE) {
     48e:	86 e3       	ldi	r24, 0x36	; 54
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	fc 01       	movw	r30, r24
     494:	80 81       	ld	r24, Z
     496:	88 2f       	mov	r24, r24
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	81 70       	andi	r24, 0x01	; 1
     49c:	99 27       	eor	r25, r25
     49e:	00 97       	sbiw	r24, 0x00	; 0
     4a0:	a1 f4       	brne	.+40     	; 0x4ca <__stack+0x6b>
     4a2:	80 91 f2 00 	lds	r24, 0x00F2
     4a6:	90 91 f3 00 	lds	r25, 0x00F3
     4aa:	88 3c       	cpi	r24, 0xC8	; 200
     4ac:	91 05       	cpc	r25, r1
     4ae:	68 f4       	brcc	.+26     	; 0x4ca <__stack+0x6b>
			minTemp++;
     4b0:	80 91 f2 00 	lds	r24, 0x00F2
     4b4:	90 91 f3 00 	lds	r25, 0x00F3
     4b8:	01 96       	adiw	r24, 0x01	; 1
     4ba:	90 93 f3 00 	sts	0x00F3, r25
     4be:	80 93 f2 00 	sts	0x00F2, r24
			DELAY_ms(BUTTON_PRESS_DELAY);
     4c2:	82 e3       	ldi	r24, 0x32	; 50
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
		}
		if(BTN_MINUS && minTemp > MINIMUM_TEMPERATURE)  {
     4ca:	86 e3       	ldi	r24, 0x36	; 54
     4cc:	90 e0       	ldi	r25, 0x00	; 0
     4ce:	fc 01       	movw	r30, r24
     4d0:	80 81       	ld	r24, Z
     4d2:	88 2f       	mov	r24, r24
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	82 70       	andi	r24, 0x02	; 2
     4d8:	99 27       	eor	r25, r25
     4da:	00 97       	sbiw	r24, 0x00	; 0
     4dc:	99 f4       	brne	.+38     	; 0x504 <__stack+0xa5>
     4de:	80 91 f2 00 	lds	r24, 0x00F2
     4e2:	90 91 f3 00 	lds	r25, 0x00F3
     4e6:	00 97       	sbiw	r24, 0x00	; 0
     4e8:	69 f0       	breq	.+26     	; 0x504 <__stack+0xa5>
			minTemp--;
     4ea:	80 91 f2 00 	lds	r24, 0x00F2
     4ee:	90 91 f3 00 	lds	r25, 0x00F3
     4f2:	01 97       	sbiw	r24, 0x01	; 1
     4f4:	90 93 f3 00 	sts	0x00F3, r25
     4f8:	80 93 f2 00 	sts	0x00F2, r24
			DELAY_ms(BUTTON_PRESS_DELAY);
     4fc:	82 e3       	ldi	r24, 0x32	; 50
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
		}if(BTN_OK) break;
     504:	86 e3       	ldi	r24, 0x36	; 54
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	fc 01       	movw	r30, r24
     50a:	80 81       	ld	r24, Z
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	84 70       	andi	r24, 0x04	; 4
     512:	99 27       	eor	r25, r25
     514:	00 97       	sbiw	r24, 0x00	; 0
     516:	49 f5       	brne	.+82     	; 0x56a <__stack+0x10b>
     518:	00 00       	nop
		lcdRefreshClock++;
	}
	LCD_Clear();
     51a:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
	LCD_XYPrintf(0, 0, "OK");
     51e:	88 e7       	ldi	r24, 0x78	; 120
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	89 2f       	mov	r24, r25
     524:	8f 93       	push	r24
     526:	88 e7       	ldi	r24, 0x78	; 120
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	8f 93       	push	r24
     52c:	1f 92       	push	r1
     52e:	1f 92       	push	r1
     530:	1f 92       	push	r1
     532:	1f 92       	push	r1
     534:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     538:	0f 90       	pop	r0
     53a:	0f 90       	pop	r0
     53c:	0f 90       	pop	r0
     53e:	0f 90       	pop	r0
     540:	0f 90       	pop	r0
     542:	0f 90       	pop	r0
	beep(3000, 100);
     544:	64 e6       	ldi	r22, 0x64	; 100
     546:	70 e0       	ldi	r23, 0x00	; 0
     548:	88 eb       	ldi	r24, 0xB8	; 184
     54a:	9b e0       	ldi	r25, 0x0B	; 11
     54c:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>
	DELAY_ms(200);
     550:	88 ec       	ldi	r24, 0xC8	; 200
     552:	90 e0       	ldi	r25, 0x00	; 0
     554:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
	maxTemp = minTemp;
     558:	80 91 f2 00 	lds	r24, 0x00F2
     55c:	90 91 f3 00 	lds	r25, 0x00F3
     560:	90 93 f5 00 	sts	0x00F5, r25
     564:	80 93 f4 00 	sts	0x00F4, r24

	while(!BTN_OK){
     568:	97 c0       	rjmp	.+302    	; 0x698 <__stack+0x239>
		}
		if(BTN_MINUS && minTemp > MINIMUM_TEMPERATURE)  {
			minTemp--;
			DELAY_ms(BUTTON_PRESS_DELAY);
		}if(BTN_OK) break;
		lcdRefreshClock++;
     56a:	80 91 fa 00 	lds	r24, 0x00FA
     56e:	90 91 fb 00 	lds	r25, 0x00FB
     572:	01 96       	adiw	r24, 0x01	; 1
     574:	90 93 fb 00 	sts	0x00FB, r25
     578:	80 93 fa 00 	sts	0x00FA, r24
	}
     57c:	4a cf       	rjmp	.-364    	; 0x412 <Initialization+0xa4>
	beep(3000, 100);
	DELAY_ms(200);
	maxTemp = minTemp;

	while(!BTN_OK){
		if(lcdRefreshClock >= LCD_REFRESH_TIME){
     57e:	80 91 fa 00 	lds	r24, 0x00FA
     582:	90 91 fb 00 	lds	r25, 0x00FB
     586:	80 32       	cpi	r24, 0x20	; 32
     588:	fe e4       	ldi	r31, 0x4E	; 78
     58a:	9f 07       	cpc	r25, r31
     58c:	b0 f1       	brcs	.+108    	; 0x5fa <__stack+0x19b>
			LCD_Clear();
     58e:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
			LCD_XYPrintf(0, 0, "Max temp");
     592:	8b e7       	ldi	r24, 0x7B	; 123
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	89 2f       	mov	r24, r25
     598:	8f 93       	push	r24
     59a:	8b e7       	ldi	r24, 0x7B	; 123
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	8f 93       	push	r24
     5a0:	1f 92       	push	r1
     5a2:	1f 92       	push	r1
     5a4:	1f 92       	push	r1
     5a6:	1f 92       	push	r1
     5a8:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     5ac:	0f 90       	pop	r0
     5ae:	0f 90       	pop	r0
     5b0:	0f 90       	pop	r0
     5b2:	0f 90       	pop	r0
     5b4:	0f 90       	pop	r0
     5b6:	0f 90       	pop	r0
			LCD_XYPrintf(0, 1, ": %d", maxTemp);
     5b8:	80 91 f4 00 	lds	r24, 0x00F4
     5bc:	90 91 f5 00 	lds	r25, 0x00F5
     5c0:	29 2f       	mov	r18, r25
     5c2:	2f 93       	push	r18
     5c4:	8f 93       	push	r24
     5c6:	83 e7       	ldi	r24, 0x73	; 115
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	89 2f       	mov	r24, r25
     5cc:	8f 93       	push	r24
     5ce:	83 e7       	ldi	r24, 0x73	; 115
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	8f 93       	push	r24
     5d4:	1f 92       	push	r1
     5d6:	81 e0       	ldi	r24, 0x01	; 1
     5d8:	8f 93       	push	r24
     5da:	1f 92       	push	r1
     5dc:	1f 92       	push	r1
     5de:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     5e2:	8d b7       	in	r24, 0x3d	; 61
     5e4:	9e b7       	in	r25, 0x3e	; 62
     5e6:	08 96       	adiw	r24, 0x08	; 8
     5e8:	0f b6       	in	r0, 0x3f	; 63
     5ea:	f8 94       	cli
     5ec:	de bf       	out	0x3e, r29	; 62
     5ee:	0f be       	out	0x3f, r0	; 63
     5f0:	cd bf       	out	0x3d, r28	; 61
			lcdRefreshClock = 0;
     5f2:	10 92 fb 00 	sts	0x00FB, r1
     5f6:	10 92 fa 00 	sts	0x00FA, r1
		}
		if(BTN_PLUS && maxTemp < MAXIMUM_TEMPERATURE) {
     5fa:	86 e3       	ldi	r24, 0x36	; 54
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	fc 01       	movw	r30, r24
     600:	80 81       	ld	r24, Z
     602:	88 2f       	mov	r24, r24
     604:	90 e0       	ldi	r25, 0x00	; 0
     606:	81 70       	andi	r24, 0x01	; 1
     608:	99 27       	eor	r25, r25
     60a:	00 97       	sbiw	r24, 0x00	; 0
     60c:	a1 f4       	brne	.+40     	; 0x636 <__stack+0x1d7>
     60e:	80 91 f4 00 	lds	r24, 0x00F4
     612:	90 91 f5 00 	lds	r25, 0x00F5
     616:	88 3c       	cpi	r24, 0xC8	; 200
     618:	91 05       	cpc	r25, r1
     61a:	68 f4       	brcc	.+26     	; 0x636 <__stack+0x1d7>
			maxTemp++;
     61c:	80 91 f4 00 	lds	r24, 0x00F4
     620:	90 91 f5 00 	lds	r25, 0x00F5
     624:	01 96       	adiw	r24, 0x01	; 1
     626:	90 93 f5 00 	sts	0x00F5, r25
     62a:	80 93 f4 00 	sts	0x00F4, r24
			DELAY_ms(BUTTON_PRESS_DELAY);
     62e:	82 e3       	ldi	r24, 0x32	; 50
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
		}
		if(BTN_MINUS && maxTemp > MINIMUM_TEMPERATURE && maxTemp > minTemp)  {
     636:	86 e3       	ldi	r24, 0x36	; 54
     638:	90 e0       	ldi	r25, 0x00	; 0
     63a:	fc 01       	movw	r30, r24
     63c:	80 81       	ld	r24, Z
     63e:	88 2f       	mov	r24, r24
     640:	90 e0       	ldi	r25, 0x00	; 0
     642:	82 70       	andi	r24, 0x02	; 2
     644:	99 27       	eor	r25, r25
     646:	00 97       	sbiw	r24, 0x00	; 0
     648:	f1 f4       	brne	.+60     	; 0x686 <__stack+0x227>
     64a:	80 91 f4 00 	lds	r24, 0x00F4
     64e:	90 91 f5 00 	lds	r25, 0x00F5
     652:	00 97       	sbiw	r24, 0x00	; 0
     654:	c1 f0       	breq	.+48     	; 0x686 <__stack+0x227>
     656:	20 91 f4 00 	lds	r18, 0x00F4
     65a:	30 91 f5 00 	lds	r19, 0x00F5
     65e:	80 91 f2 00 	lds	r24, 0x00F2
     662:	90 91 f3 00 	lds	r25, 0x00F3
     666:	82 17       	cp	r24, r18
     668:	93 07       	cpc	r25, r19
     66a:	68 f4       	brcc	.+26     	; 0x686 <__stack+0x227>
			maxTemp--;
     66c:	80 91 f4 00 	lds	r24, 0x00F4
     670:	90 91 f5 00 	lds	r25, 0x00F5
     674:	01 97       	sbiw	r24, 0x01	; 1
     676:	90 93 f5 00 	sts	0x00F5, r25
     67a:	80 93 f4 00 	sts	0x00F4, r24
			DELAY_ms(BUTTON_PRESS_DELAY);
     67e:	82 e3       	ldi	r24, 0x32	; 50
     680:	90 e0       	ldi	r25, 0x00	; 0
     682:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
		}
		lcdRefreshClock++;
     686:	80 91 fa 00 	lds	r24, 0x00FA
     68a:	90 91 fb 00 	lds	r25, 0x00FB
     68e:	01 96       	adiw	r24, 0x01	; 1
     690:	90 93 fb 00 	sts	0x00FB, r25
     694:	80 93 fa 00 	sts	0x00FA, r24
	LCD_XYPrintf(0, 0, "OK");
	beep(3000, 100);
	DELAY_ms(200);
	maxTemp = minTemp;

	while(!BTN_OK){
     698:	86 e3       	ldi	r24, 0x36	; 54
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	fc 01       	movw	r30, r24
     69e:	80 81       	ld	r24, Z
     6a0:	88 2f       	mov	r24, r24
     6a2:	90 e0       	ldi	r25, 0x00	; 0
     6a4:	84 70       	andi	r24, 0x04	; 4
     6a6:	99 27       	eor	r25, r25
     6a8:	00 97       	sbiw	r24, 0x00	; 0
     6aa:	09 f0       	breq	.+2      	; 0x6ae <__stack+0x24f>
     6ac:	68 cf       	rjmp	.-304    	; 0x57e <__stack+0x11f>
			maxTemp--;
			DELAY_ms(BUTTON_PRESS_DELAY);
		}
		lcdRefreshClock++;
	}
	LCD_Clear();
     6ae:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
	LCD_XYPrintf(0, 0, "OK");
     6b2:	88 e7       	ldi	r24, 0x78	; 120
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	89 2f       	mov	r24, r25
     6b8:	8f 93       	push	r24
     6ba:	88 e7       	ldi	r24, 0x78	; 120
     6bc:	90 e0       	ldi	r25, 0x00	; 0
     6be:	8f 93       	push	r24
     6c0:	1f 92       	push	r1
     6c2:	1f 92       	push	r1
     6c4:	1f 92       	push	r1
     6c6:	1f 92       	push	r1
     6c8:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     6cc:	0f 90       	pop	r0
     6ce:	0f 90       	pop	r0
     6d0:	0f 90       	pop	r0
     6d2:	0f 90       	pop	r0
     6d4:	0f 90       	pop	r0
     6d6:	0f 90       	pop	r0
	beep(3000, 100);
     6d8:	64 e6       	ldi	r22, 0x64	; 100
     6da:	70 e0       	ldi	r23, 0x00	; 0
     6dc:	88 eb       	ldi	r24, 0xB8	; 184
     6de:	9b e0       	ldi	r25, 0x0B	; 11
     6e0:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>
	DELAY_ms(200);
     6e4:	88 ec       	ldi	r24, 0xC8	; 200
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
	LCD_Clear();
     6ec:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
	LCD_XYPrintf(0, 0, "Max:%d", maxTemp);
     6f0:	80 91 f4 00 	lds	r24, 0x00F4
     6f4:	90 91 f5 00 	lds	r25, 0x00F5
     6f8:	29 2f       	mov	r18, r25
     6fa:	2f 93       	push	r18
     6fc:	8f 93       	push	r24
     6fe:	84 e8       	ldi	r24, 0x84	; 132
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	89 2f       	mov	r24, r25
     704:	8f 93       	push	r24
     706:	84 e8       	ldi	r24, 0x84	; 132
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	8f 93       	push	r24
     70c:	1f 92       	push	r1
     70e:	1f 92       	push	r1
     710:	1f 92       	push	r1
     712:	1f 92       	push	r1
     714:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     718:	8d b7       	in	r24, 0x3d	; 61
     71a:	9e b7       	in	r25, 0x3e	; 62
     71c:	08 96       	adiw	r24, 0x08	; 8
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	f8 94       	cli
     722:	de bf       	out	0x3e, r29	; 62
     724:	0f be       	out	0x3f, r0	; 63
     726:	cd bf       	out	0x3d, r28	; 61
	LCD_XYPrintf(0, 1, "Min:%d", minTemp);
     728:	80 91 f2 00 	lds	r24, 0x00F2
     72c:	90 91 f3 00 	lds	r25, 0x00F3
     730:	29 2f       	mov	r18, r25
     732:	2f 93       	push	r18
     734:	8f 93       	push	r24
     736:	8b e8       	ldi	r24, 0x8B	; 139
     738:	90 e0       	ldi	r25, 0x00	; 0
     73a:	89 2f       	mov	r24, r25
     73c:	8f 93       	push	r24
     73e:	8b e8       	ldi	r24, 0x8B	; 139
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	8f 93       	push	r24
     744:	1f 92       	push	r1
     746:	81 e0       	ldi	r24, 0x01	; 1
     748:	8f 93       	push	r24
     74a:	1f 92       	push	r1
     74c:	1f 92       	push	r1
     74e:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     752:	ed b7       	in	r30, 0x3d	; 61
     754:	fe b7       	in	r31, 0x3e	; 62
     756:	38 96       	adiw	r30, 0x08	; 8
     758:	0f b6       	in	r0, 0x3f	; 63
     75a:	f8 94       	cli
     75c:	de bf       	out	0x3e, r29	; 62
     75e:	0f be       	out	0x3f, r0	; 63
     760:	cd bf       	out	0x3d, r28	; 61
	DELAY_ms(1000);
     762:	88 ee       	ldi	r24, 0xE8	; 232
     764:	93 e0       	ldi	r25, 0x03	; 3
     766:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
	return;
     76a:	00 00       	nop
}
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	0f 91       	pop	r16
     772:	ef 90       	pop	r14
     774:	cf 90       	pop	r12
     776:	af 90       	pop	r10
     778:	8f 90       	pop	r8
     77a:	08 95       	ret

0000077c <MainLoop>:

void MainLoop() {
     77c:	cf 93       	push	r28
     77e:	df 93       	push	r29
     780:	cd b7       	in	r28, 0x3d	; 61
     782:	de b7       	in	r29, 0x3e	; 62
	LCD_Clear();
     784:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
	lcdRefreshClock=0;
     788:	10 92 fb 00 	sts	0x00FB, r1
     78c:	10 92 fa 00 	sts	0x00FA, r1
while(true){
	if(lcdRefreshClock >= 1){
     790:	80 91 fa 00 	lds	r24, 0x00FA
     794:	90 91 fb 00 	lds	r25, 0x00FB
     798:	00 97       	sbiw	r24, 0x00	; 0
     79a:	09 f4       	brne	.+2      	; 0x79e <MainLoop+0x22>
     79c:	66 c0       	rjmp	.+204    	; 0x86a <MainLoop+0xee>
		LCD_Clear();
     79e:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
		if(actTemp != -100) LCD_XYPrintf(0, 0, "TEMP:%d", actTemp);
     7a2:	80 91 f6 00 	lds	r24, 0x00F6
     7a6:	90 91 f7 00 	lds	r25, 0x00F7
     7aa:	8c 39       	cpi	r24, 0x9C	; 156
     7ac:	2f ef       	ldi	r18, 0xFF	; 255
     7ae:	92 07       	cpc	r25, r18
     7b0:	e9 f0       	breq	.+58     	; 0x7ec <MainLoop+0x70>
     7b2:	80 91 f6 00 	lds	r24, 0x00F6
     7b6:	90 91 f7 00 	lds	r25, 0x00F7
     7ba:	29 2f       	mov	r18, r25
     7bc:	2f 93       	push	r18
     7be:	8f 93       	push	r24
     7c0:	82 e9       	ldi	r24, 0x92	; 146
     7c2:	90 e0       	ldi	r25, 0x00	; 0
     7c4:	89 2f       	mov	r24, r25
     7c6:	8f 93       	push	r24
     7c8:	82 e9       	ldi	r24, 0x92	; 146
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	8f 93       	push	r24
     7ce:	1f 92       	push	r1
     7d0:	1f 92       	push	r1
     7d2:	1f 92       	push	r1
     7d4:	1f 92       	push	r1
     7d6:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     7da:	8d b7       	in	r24, 0x3d	; 61
     7dc:	9e b7       	in	r25, 0x3e	; 62
     7de:	08 96       	adiw	r24, 0x08	; 8
     7e0:	0f b6       	in	r0, 0x3f	; 63
     7e2:	f8 94       	cli
     7e4:	de bf       	out	0x3e, r29	; 62
     7e6:	0f be       	out	0x3f, r0	; 63
     7e8:	cd bf       	out	0x3d, r28	; 61
     7ea:	16 c0       	rjmp	.+44     	; 0x818 <MainLoop+0x9c>
		else  {
			LCD_XYPrintf(0, 0, "TEMP:ERR");
     7ec:	8a e9       	ldi	r24, 0x9A	; 154
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	89 2f       	mov	r24, r25
     7f2:	8f 93       	push	r24
     7f4:	8a e9       	ldi	r24, 0x9A	; 154
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	8f 93       	push	r24
     7fa:	1f 92       	push	r1
     7fc:	1f 92       	push	r1
     7fe:	1f 92       	push	r1
     800:	1f 92       	push	r1
     802:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     806:	0f 90       	pop	r0
     808:	0f 90       	pop	r0
     80a:	0f 90       	pop	r0
     80c:	0f 90       	pop	r0
     80e:	0f 90       	pop	r0
     810:	0f 90       	pop	r0
			Lamp(true);
     812:	81 e0       	ldi	r24, 0x01	; 1
     814:	0e 94 c6 04 	call	0x98c	; 0x98c <Lamp>
		}
		LCD_XYPrintf(0, 1, " %d/%d", minTemp, maxTemp);
     818:	20 91 f4 00 	lds	r18, 0x00F4
     81c:	30 91 f5 00 	lds	r19, 0x00F5
     820:	80 91 f2 00 	lds	r24, 0x00F2
     824:	90 91 f3 00 	lds	r25, 0x00F3
     828:	43 2f       	mov	r20, r19
     82a:	4f 93       	push	r20
     82c:	2f 93       	push	r18
     82e:	29 2f       	mov	r18, r25
     830:	2f 93       	push	r18
     832:	8f 93       	push	r24
     834:	83 ea       	ldi	r24, 0xA3	; 163
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	89 2f       	mov	r24, r25
     83a:	8f 93       	push	r24
     83c:	83 ea       	ldi	r24, 0xA3	; 163
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	8f 93       	push	r24
     842:	1f 92       	push	r1
     844:	81 e0       	ldi	r24, 0x01	; 1
     846:	8f 93       	push	r24
     848:	1f 92       	push	r1
     84a:	1f 92       	push	r1
     84c:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
     850:	ed b7       	in	r30, 0x3d	; 61
     852:	fe b7       	in	r31, 0x3e	; 62
     854:	3a 96       	adiw	r30, 0x0a	; 10
     856:	0f b6       	in	r0, 0x3f	; 63
     858:	f8 94       	cli
     85a:	de bf       	out	0x3e, r29	; 62
     85c:	0f be       	out	0x3f, r0	; 63
     85e:	cd bf       	out	0x3d, r28	; 61
		lcdRefreshClock = 0;
     860:	10 92 fb 00 	sts	0x00FB, r1
     864:	10 92 fa 00 	sts	0x00FA, r1
     868:	09 c0       	rjmp	.+18     	; 0x87c <MainLoop+0x100>
		//beep(200, 600);
	}
	else lcdRefreshClock++;
     86a:	80 91 fa 00 	lds	r24, 0x00FA
     86e:	90 91 fb 00 	lds	r25, 0x00FB
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	90 93 fb 00 	sts	0x00FB, r25
     878:	80 93 fa 00 	sts	0x00FA, r24
	actTemp = readCelsius();
     87c:	0e 94 3a 05 	call	0xa74	; 0xa74 <readCelsius>
     880:	dc 01       	movw	r26, r24
     882:	cb 01       	movw	r24, r22
     884:	bc 01       	movw	r22, r24
     886:	cd 01       	movw	r24, r26
     888:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
     88c:	dc 01       	movw	r26, r24
     88e:	cb 01       	movw	r24, r22
     890:	90 93 f7 00 	sts	0x00F7, r25
     894:	80 93 f6 00 	sts	0x00F6, r24
	if((actTemp > maxTemp || actTemp < minTemp) && (histerezeLock == 0 || histerezeLock == 1)){
     898:	20 91 f6 00 	lds	r18, 0x00F6
     89c:	30 91 f7 00 	lds	r19, 0x00F7
     8a0:	80 91 f4 00 	lds	r24, 0x00F4
     8a4:	90 91 f5 00 	lds	r25, 0x00F5
     8a8:	82 17       	cp	r24, r18
     8aa:	93 07       	cpc	r25, r19
     8ac:	58 f0       	brcs	.+22     	; 0x8c4 <MainLoop+0x148>
     8ae:	20 91 f6 00 	lds	r18, 0x00F6
     8b2:	30 91 f7 00 	lds	r19, 0x00F7
     8b6:	80 91 f2 00 	lds	r24, 0x00F2
     8ba:	90 91 f3 00 	lds	r25, 0x00F3
     8be:	28 17       	cp	r18, r24
     8c0:	39 07       	cpc	r19, r25
     8c2:	28 f5       	brcc	.+74     	; 0x90e <MainLoop+0x192>
     8c4:	80 91 f9 00 	lds	r24, 0x00F9
     8c8:	88 23       	and	r24, r24
     8ca:	21 f0       	breq	.+8      	; 0x8d4 <MainLoop+0x158>
     8cc:	80 91 f9 00 	lds	r24, 0x00F9
     8d0:	81 30       	cpi	r24, 0x01	; 1
     8d2:	e9 f4       	brne	.+58     	; 0x90e <MainLoop+0x192>
		Lamp(true);
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 c6 04 	call	0x98c	; 0x98c <Lamp>
		histerezeLock = 1;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	80 93 f9 00 	sts	0x00F9, r24
		if(!mute) ALARM();
     8e0:	90 91 f8 00 	lds	r25, 0x00F8
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	89 27       	eor	r24, r25
     8e8:	88 23       	and	r24, r24
     8ea:	11 f0       	breq	.+4      	; 0x8f0 <MainLoop+0x174>
     8ec:	0e 94 b3 04 	call	0x966	; 0x966 <ALARM>
		if(BTN_OK) mute=true;
     8f0:	86 e3       	ldi	r24, 0x36	; 54
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	fc 01       	movw	r30, r24
     8f6:	80 81       	ld	r24, Z
     8f8:	88 2f       	mov	r24, r24
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	84 70       	andi	r24, 0x04	; 4
     8fe:	99 27       	eor	r25, r25
     900:	00 97       	sbiw	r24, 0x00	; 0
     902:	21 f4       	brne	.+8      	; 0x90c <MainLoop+0x190>
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	80 93 f8 00 	sts	0x00F8, r24
     90a:	2c c0       	rjmp	.+88     	; 0x964 <MainLoop+0x1e8>
     90c:	2b c0       	rjmp	.+86     	; 0x964 <MainLoop+0x1e8>
	}
	else {
		mute=false;
     90e:	10 92 f8 00 	sts	0x00F8, r1
		Lamp(false);
     912:	80 e0       	ldi	r24, 0x00	; 0
     914:	0e 94 c6 04 	call	0x98c	; 0x98c <Lamp>
		if(histerezeLock == 1) histerezeLock =2;
     918:	80 91 f9 00 	lds	r24, 0x00F9
     91c:	81 30       	cpi	r24, 0x01	; 1
     91e:	19 f4       	brne	.+6      	; 0x926 <MainLoop+0x1aa>
     920:	82 e0       	ldi	r24, 0x02	; 2
     922:	80 93 f9 00 	sts	0x00F9, r24
		if(actTemp < maxTemp-1 && actTemp > minTemp +1)histerezeLock=0;
     926:	80 91 f4 00 	lds	r24, 0x00F4
     92a:	90 91 f5 00 	lds	r25, 0x00F5
     92e:	9c 01       	movw	r18, r24
     930:	21 50       	subi	r18, 0x01	; 1
     932:	31 09       	sbc	r19, r1
     934:	80 91 f6 00 	lds	r24, 0x00F6
     938:	90 91 f7 00 	lds	r25, 0x00F7
     93c:	82 17       	cp	r24, r18
     93e:	93 07       	cpc	r25, r19
     940:	88 f4       	brcc	.+34     	; 0x964 <MainLoop+0x1e8>
     942:	80 91 f2 00 	lds	r24, 0x00F2
     946:	90 91 f3 00 	lds	r25, 0x00F3
     94a:	9c 01       	movw	r18, r24
     94c:	2f 5f       	subi	r18, 0xFF	; 255
     94e:	3f 4f       	sbci	r19, 0xFF	; 255
     950:	80 91 f6 00 	lds	r24, 0x00F6
     954:	90 91 f7 00 	lds	r25, 0x00F7
     958:	28 17       	cp	r18, r24
     95a:	39 07       	cpc	r19, r25
     95c:	18 f4       	brcc	.+6      	; 0x964 <MainLoop+0x1e8>
     95e:	10 92 f9 00 	sts	0x00F9, r1
	}
}
     962:	16 cf       	rjmp	.-468    	; 0x790 <MainLoop+0x14>
     964:	15 cf       	rjmp	.-470    	; 0x790 <MainLoop+0x14>

00000966 <ALARM>:
}

void ALARM() {
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
     96a:	cd b7       	in	r28, 0x3d	; 61
     96c:	de b7       	in	r29, 0x3e	; 62
	beep(500, 100);
     96e:	64 e6       	ldi	r22, 0x64	; 100
     970:	70 e0       	ldi	r23, 0x00	; 0
     972:	84 ef       	ldi	r24, 0xF4	; 244
     974:	91 e0       	ldi	r25, 0x01	; 1
     976:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>
	beep(500, 200);
     97a:	68 ec       	ldi	r22, 0xC8	; 200
     97c:	70 e0       	ldi	r23, 0x00	; 0
     97e:	84 ef       	ldi	r24, 0xF4	; 244
     980:	91 e0       	ldi	r25, 0x01	; 1
     982:	0e 94 e7 04 	call	0x9ce	; 0x9ce <beep>

}
     986:	df 91       	pop	r29
     988:	cf 91       	pop	r28
     98a:	08 95       	ret

0000098c <Lamp>:

void Lamp(bool mode){
     98c:	cf 93       	push	r28
     98e:	df 93       	push	r29
     990:	1f 92       	push	r1
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	89 83       	std	Y+1, r24	; 0x01
	if(!mode) PORTD |= (1 << 1);
     998:	99 81       	ldd	r25, Y+1	; 0x01
     99a:	81 e0       	ldi	r24, 0x01	; 1
     99c:	89 27       	eor	r24, r25
     99e:	88 23       	and	r24, r24
     9a0:	51 f0       	breq	.+20     	; 0x9b6 <Lamp+0x2a>
     9a2:	82 e3       	ldi	r24, 0x32	; 50
     9a4:	90 e0       	ldi	r25, 0x00	; 0
     9a6:	22 e3       	ldi	r18, 0x32	; 50
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	f9 01       	movw	r30, r18
     9ac:	20 81       	ld	r18, Z
     9ae:	22 60       	ori	r18, 0x02	; 2
     9b0:	fc 01       	movw	r30, r24
     9b2:	20 83       	st	Z, r18
     9b4:	08 c0       	rjmp	.+16     	; 0x9c6 <Lamp+0x3a>
	else PORTD &= (0 << 1);
     9b6:	82 e3       	ldi	r24, 0x32	; 50
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	fc 01       	movw	r30, r24
     9bc:	80 81       	ld	r24, Z
     9be:	82 e3       	ldi	r24, 0x32	; 50
     9c0:	90 e0       	ldi	r25, 0x00	; 0
     9c2:	fc 01       	movw	r30, r24
     9c4:	10 82       	st	Z, r1
}
     9c6:	0f 90       	pop	r0
     9c8:	df 91       	pop	r29
     9ca:	cf 91       	pop	r28
     9cc:	08 95       	ret

000009ce <beep>:

void beep(uint16_t time, uint16_t delay){
     9ce:	cf 93       	push	r28
     9d0:	df 93       	push	r29
     9d2:	00 d0       	rcall	.+0      	; 0x9d4 <beep+0x6>
     9d4:	00 d0       	rcall	.+0      	; 0x9d6 <beep+0x8>
     9d6:	00 d0       	rcall	.+0      	; 0x9d8 <beep+0xa>
     9d8:	cd b7       	in	r28, 0x3d	; 61
     9da:	de b7       	in	r29, 0x3e	; 62
     9dc:	9c 83       	std	Y+4, r25	; 0x04
     9de:	8b 83       	std	Y+3, r24	; 0x03
     9e0:	7e 83       	std	Y+6, r23	; 0x06
     9e2:	6d 83       	std	Y+5, r22	; 0x05
	for(int clk=0;clk<time;clk++){
     9e4:	1a 82       	std	Y+2, r1	; 0x02
     9e6:	19 82       	std	Y+1, r1	; 0x01
     9e8:	1e c0       	rjmp	.+60     	; 0xa26 <beep+0x58>
		PORTD &= (0 << 0);
     9ea:	82 e3       	ldi	r24, 0x32	; 50
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	fc 01       	movw	r30, r24
     9f0:	80 81       	ld	r24, Z
     9f2:	82 e3       	ldi	r24, 0x32	; 50
     9f4:	90 e0       	ldi	r25, 0x00	; 0
     9f6:	fc 01       	movw	r30, r24
     9f8:	10 82       	st	Z, r1
		DELAY_us(delay);
     9fa:	8d 81       	ldd	r24, Y+5	; 0x05
     9fc:	9e 81       	ldd	r25, Y+6	; 0x06
     9fe:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
		PORTD |= (1 << 0);
     a02:	82 e3       	ldi	r24, 0x32	; 50
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	22 e3       	ldi	r18, 0x32	; 50
     a08:	30 e0       	ldi	r19, 0x00	; 0
     a0a:	f9 01       	movw	r30, r18
     a0c:	20 81       	ld	r18, Z
     a0e:	21 60       	ori	r18, 0x01	; 1
     a10:	fc 01       	movw	r30, r24
     a12:	20 83       	st	Z, r18
		DELAY_us(delay);
     a14:	8d 81       	ldd	r24, Y+5	; 0x05
     a16:	9e 81       	ldd	r25, Y+6	; 0x06
     a18:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
	if(!mode) PORTD |= (1 << 1);
	else PORTD &= (0 << 1);
}

void beep(uint16_t time, uint16_t delay){
	for(int clk=0;clk<time;clk++){
     a1c:	89 81       	ldd	r24, Y+1	; 0x01
     a1e:	9a 81       	ldd	r25, Y+2	; 0x02
     a20:	01 96       	adiw	r24, 0x01	; 1
     a22:	9a 83       	std	Y+2, r25	; 0x02
     a24:	89 83       	std	Y+1, r24	; 0x01
     a26:	29 81       	ldd	r18, Y+1	; 0x01
     a28:	3a 81       	ldd	r19, Y+2	; 0x02
     a2a:	8b 81       	ldd	r24, Y+3	; 0x03
     a2c:	9c 81       	ldd	r25, Y+4	; 0x04
     a2e:	28 17       	cp	r18, r24
     a30:	39 07       	cpc	r19, r25
     a32:	d8 f2       	brcs	.-74     	; 0x9ea <beep+0x1c>
		PORTD &= (0 << 0);
		DELAY_us(delay);
		PORTD |= (1 << 0);
		DELAY_us(delay);
	}
	PORTD |= (1 << 0);
     a34:	82 e3       	ldi	r24, 0x32	; 50
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	22 e3       	ldi	r18, 0x32	; 50
     a3a:	30 e0       	ldi	r19, 0x00	; 0
     a3c:	f9 01       	movw	r30, r18
     a3e:	20 81       	ld	r18, Z
     a40:	21 60       	ori	r18, 0x01	; 1
     a42:	fc 01       	movw	r30, r24
     a44:	20 83       	st	Z, r18
}
     a46:	26 96       	adiw	r28, 0x06	; 6
     a48:	0f b6       	in	r0, 0x3f	; 63
     a4a:	f8 94       	cli
     a4c:	de bf       	out	0x3e, r29	; 62
     a4e:	0f be       	out	0x3f, r0	; 63
     a50:	cd bf       	out	0x3d, r28	; 61
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	08 95       	ret

00000a58 <MAX6675>:
#include "../HEADERS/termo.h"
#include "../../Libraries/Headers/delay.h"
#include <avr/io.h>
#define MISO (!(PINC & 0x80))

void MAX6675() {
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
     a5c:	cd b7       	in	r28, 0x3d	; 61
     a5e:	de b7       	in	r29, 0x3e	; 62

  // define pin modes
//  pinMode(cs, OUTPUT); 0
//  pinMode(sclk, OUTPUT); 1
//  pinMode(miso, INPUT); 2
	DDRC = 0x07;
     a60:	84 e3       	ldi	r24, 0x34	; 52
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	27 e0       	ldi	r18, 0x07	; 7
     a66:	fc 01       	movw	r30, r24
     a68:	20 83       	st	Z, r18
  CS_HIGH();
     a6a:	0e 94 ed 05 	call	0xbda	; 0xbda <CS_HIGH>
}
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	08 95       	ret

00000a74 <readCelsius>:
/*!
    @brief  Read the Celsius temperature
    @returns Temperature in C or NAN on failure!
*/
/**************************************************************************/
float readCelsius(void) {
     a74:	cf 93       	push	r28
     a76:	df 93       	push	r29
     a78:	00 d0       	rcall	.+0      	; 0xa7a <readCelsius+0x6>
     a7a:	cd b7       	in	r28, 0x3d	; 61
     a7c:	de b7       	in	r29, 0x3e	; 62

  uint16_t v;

  CS_LOW();
     a7e:	0e 94 de 05 	call	0xbbc	; 0xbbc <CS_LOW>
  DELAY_us(10);
     a82:	8a e0       	ldi	r24, 0x0A	; 10
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
  v = spiread();
     a8a:	0e 94 a4 05 	call	0xb48	; 0xb48 <spiread>
     a8e:	88 2f       	mov	r24, r24
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	9a 83       	std	Y+2, r25	; 0x02
     a94:	89 83       	std	Y+1, r24	; 0x01
  v <<= 8;
     a96:	89 81       	ldd	r24, Y+1	; 0x01
     a98:	9a 81       	ldd	r25, Y+2	; 0x02
     a9a:	98 2f       	mov	r25, r24
     a9c:	88 27       	eor	r24, r24
     a9e:	9a 83       	std	Y+2, r25	; 0x02
     aa0:	89 83       	std	Y+1, r24	; 0x01
  v |= spiread();
     aa2:	0e 94 a4 05 	call	0xb48	; 0xb48 <spiread>
     aa6:	88 2f       	mov	r24, r24
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	29 81       	ldd	r18, Y+1	; 0x01
     aac:	3a 81       	ldd	r19, Y+2	; 0x02
     aae:	82 2b       	or	r24, r18
     ab0:	93 2b       	or	r25, r19
     ab2:	9a 83       	std	Y+2, r25	; 0x02
     ab4:	89 83       	std	Y+1, r24	; 0x01
  CS_HIGH();
     ab6:	0e 94 ed 05 	call	0xbda	; 0xbda <CS_HIGH>
  DELAY_ms(10);
     aba:	8a e0       	ldi	r24, 0x0A	; 10
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
  SCK_LOW();
     ac2:	0e 94 fd 05 	call	0xbfa	; 0xbfa <SCK_LOW>
  CS_LOW();
     ac6:	0e 94 de 05 	call	0xbbc	; 0xbbc <CS_LOW>
  DELAY_ms(10);
     aca:	8a e0       	ldi	r24, 0x0A	; 10
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
  CS_HIGH();
     ad2:	0e 94 ed 05 	call	0xbda	; 0xbda <CS_HIGH>
  DELAY_ms(200);
     ad6:	88 ec       	ldi	r24, 0xC8	; 200
     ad8:	90 e0       	ldi	r25, 0x00	; 0
     ada:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>

  DELAY_us(10);
     ade:	8a e0       	ldi	r24, 0x0A	; 10
     ae0:	90 e0       	ldi	r25, 0x00	; 0
     ae2:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
  if (v & 0x4) {
     ae6:	89 81       	ldd	r24, Y+1	; 0x01
     ae8:	9a 81       	ldd	r25, Y+2	; 0x02
     aea:	84 70       	andi	r24, 0x04	; 4
     aec:	99 27       	eor	r25, r25
     aee:	00 97       	sbiw	r24, 0x00	; 0
     af0:	29 f0       	breq	.+10     	; 0xafc <readCelsius+0x88>
    return -100;
     af2:	80 e0       	ldi	r24, 0x00	; 0
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	a8 ec       	ldi	r26, 0xC8	; 200
     af8:	b2 ec       	ldi	r27, 0xC2	; 194
     afa:	1f c0       	rjmp	.+62     	; 0xb3a <readCelsius+0xc6>

  }

  v >>= 3;
     afc:	89 81       	ldd	r24, Y+1	; 0x01
     afe:	9a 81       	ldd	r25, Y+2	; 0x02
     b00:	96 95       	lsr	r25
     b02:	87 95       	ror	r24
     b04:	96 95       	lsr	r25
     b06:	87 95       	ror	r24
     b08:	96 95       	lsr	r25
     b0a:	87 95       	ror	r24
     b0c:	9a 83       	std	Y+2, r25	; 0x02
     b0e:	89 83       	std	Y+1, r24	; 0x01

  return (v *0.25);
     b10:	89 81       	ldd	r24, Y+1	; 0x01
     b12:	9a 81       	ldd	r25, Y+2	; 0x02
     b14:	cc 01       	movw	r24, r24
     b16:	a0 e0       	ldi	r26, 0x00	; 0
     b18:	b0 e0       	ldi	r27, 0x00	; 0
     b1a:	bc 01       	movw	r22, r24
     b1c:	cd 01       	movw	r24, r26
     b1e:	0e 94 2d 20 	call	0x405a	; 0x405a <__floatunsisf>
     b22:	dc 01       	movw	r26, r24
     b24:	cb 01       	movw	r24, r22
     b26:	20 e0       	ldi	r18, 0x00	; 0
     b28:	30 e0       	ldi	r19, 0x00	; 0
     b2a:	40 e8       	ldi	r20, 0x80	; 128
     b2c:	5e e3       	ldi	r21, 0x3E	; 62
     b2e:	bc 01       	movw	r22, r24
     b30:	cd 01       	movw	r24, r26
     b32:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
     b36:	dc 01       	movw	r26, r24
     b38:	cb 01       	movw	r24, r22
}
     b3a:	bc 01       	movw	r22, r24
     b3c:	cd 01       	movw	r24, r26
     b3e:	0f 90       	pop	r0
     b40:	0f 90       	pop	r0
     b42:	df 91       	pop	r29
     b44:	cf 91       	pop	r28
     b46:	08 95       	ret

00000b48 <spiread>:

uint8_t spiread(void) {
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	00 d0       	rcall	.+0      	; 0xb4e <spiread+0x6>
     b4e:	1f 92       	push	r1
     b50:	cd b7       	in	r28, 0x3d	; 61
     b52:	de b7       	in	r29, 0x3e	; 62
  int i;
  uint8_t d = 0;
     b54:	1b 82       	std	Y+3, r1	; 0x03

  for (i = 7; i >= 0; i--) {
     b56:	87 e0       	ldi	r24, 0x07	; 7
     b58:	90 e0       	ldi	r25, 0x00	; 0
     b5a:	9a 83       	std	Y+2, r25	; 0x02
     b5c:	89 83       	std	Y+1, r24	; 0x01
     b5e:	23 c0       	rjmp	.+70     	; 0xba6 <spiread+0x5e>
    SCK_LOW();
     b60:	0e 94 fd 05 	call	0xbfa	; 0xbfa <SCK_LOW>
    DELAY_us(10);
     b64:	8a e0       	ldi	r24, 0x0A	; 10
     b66:	90 e0       	ldi	r25, 0x00	; 0
     b68:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
    if (!MISO) {
     b6c:	83 e3       	ldi	r24, 0x33	; 51
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	fc 01       	movw	r30, r24
     b72:	80 81       	ld	r24, Z
     b74:	88 23       	and	r24, r24
     b76:	64 f4       	brge	.+24     	; 0xb90 <spiread+0x48>
      // set the bit to 0 no matter what
      d |= (1 << i);
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	90 e0       	ldi	r25, 0x00	; 0
     b7c:	09 80       	ldd	r0, Y+1	; 0x01
     b7e:	02 c0       	rjmp	.+4      	; 0xb84 <spiread+0x3c>
     b80:	88 0f       	add	r24, r24
     b82:	99 1f       	adc	r25, r25
     b84:	0a 94       	dec	r0
     b86:	e2 f7       	brpl	.-8      	; 0xb80 <spiread+0x38>
     b88:	98 2f       	mov	r25, r24
     b8a:	8b 81       	ldd	r24, Y+3	; 0x03
     b8c:	89 2b       	or	r24, r25
     b8e:	8b 83       	std	Y+3, r24	; 0x03
    }

    SCK_HIGH();
     b90:	0e 94 0c 06 	call	0xc18	; 0xc18 <SCK_HIGH>
    DELAY_us(10);
     b94:	8a e0       	ldi	r24, 0x0A	; 10
     b96:	90 e0       	ldi	r25, 0x00	; 0
     b98:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>

uint8_t spiread(void) {
  int i;
  uint8_t d = 0;

  for (i = 7; i >= 0; i--) {
     b9c:	89 81       	ldd	r24, Y+1	; 0x01
     b9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ba0:	01 97       	sbiw	r24, 0x01	; 1
     ba2:	9a 83       	std	Y+2, r25	; 0x02
     ba4:	89 83       	std	Y+1, r24	; 0x01
     ba6:	89 81       	ldd	r24, Y+1	; 0x01
     ba8:	9a 81       	ldd	r25, Y+2	; 0x02
     baa:	99 23       	and	r25, r25
     bac:	cc f6       	brge	.-78     	; 0xb60 <spiread+0x18>

    SCK_HIGH();
    DELAY_us(10);
  }

  return d;
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
}
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <CS_LOW>:

void CS_LOW(){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
	PORTC &= (0 << 0);
     bc4:	85 e3       	ldi	r24, 0x35	; 53
     bc6:	90 e0       	ldi	r25, 0x00	; 0
     bc8:	fc 01       	movw	r30, r24
     bca:	80 81       	ld	r24, Z
     bcc:	85 e3       	ldi	r24, 0x35	; 53
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	fc 01       	movw	r30, r24
     bd2:	10 82       	st	Z, r1
}
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	08 95       	ret

00000bda <CS_HIGH>:
void CS_HIGH(){
     bda:	cf 93       	push	r28
     bdc:	df 93       	push	r29
     bde:	cd b7       	in	r28, 0x3d	; 61
     be0:	de b7       	in	r29, 0x3e	; 62
	PORTC |= (1 << 0);
     be2:	85 e3       	ldi	r24, 0x35	; 53
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	25 e3       	ldi	r18, 0x35	; 53
     be8:	30 e0       	ldi	r19, 0x00	; 0
     bea:	f9 01       	movw	r30, r18
     bec:	20 81       	ld	r18, Z
     bee:	21 60       	ori	r18, 0x01	; 1
     bf0:	fc 01       	movw	r30, r24
     bf2:	20 83       	st	Z, r18
}
     bf4:	df 91       	pop	r29
     bf6:	cf 91       	pop	r28
     bf8:	08 95       	ret

00000bfa <SCK_LOW>:
void SCK_LOW(){
     bfa:	cf 93       	push	r28
     bfc:	df 93       	push	r29
     bfe:	cd b7       	in	r28, 0x3d	; 61
     c00:	de b7       	in	r29, 0x3e	; 62
	PORTC &= (0 << 1);
     c02:	85 e3       	ldi	r24, 0x35	; 53
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	fc 01       	movw	r30, r24
     c08:	80 81       	ld	r24, Z
     c0a:	85 e3       	ldi	r24, 0x35	; 53
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	fc 01       	movw	r30, r24
     c10:	10 82       	st	Z, r1
}
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	08 95       	ret

00000c18 <SCK_HIGH>:
void SCK_HIGH(){
     c18:	cf 93       	push	r28
     c1a:	df 93       	push	r29
     c1c:	cd b7       	in	r28, 0x3d	; 61
     c1e:	de b7       	in	r29, 0x3e	; 62
	PORTC |= (1 << 1);
     c20:	85 e3       	ldi	r24, 0x35	; 53
     c22:	90 e0       	ldi	r25, 0x00	; 0
     c24:	25 e3       	ldi	r18, 0x35	; 53
     c26:	30 e0       	ldi	r19, 0x00	; 0
     c28:	f9 01       	movw	r30, r18
     c2a:	20 81       	ld	r18, Z
     c2c:	22 60       	ori	r18, 0x02	; 2
     c2e:	fc 01       	movw	r30, r24
     c30:	20 83       	st	Z, r18
}
     c32:	df 91       	pop	r29
     c34:	cf 91       	pop	r28
     c36:	08 95       	ret

00000c38 <spi_init>:
#define DD_SCK      DDC3


void spi_init()
// Initialize pins for spi communication
{
     c38:	cf 93       	push	r28
     c3a:	df 93       	push	r29
     c3c:	cd b7       	in	r28, 0x3d	; 61
     c3e:	de b7       	in	r29, 0x3e	; 62
    DDR_SPI &= ~((1<<DD_MOSI)|(1<<DD_MISO)|(1<<DD_SS)|(1<<DD_SCK));
     c40:	84 e3       	ldi	r24, 0x34	; 52
     c42:	90 e0       	ldi	r25, 0x00	; 0
     c44:	24 e3       	ldi	r18, 0x34	; 52
     c46:	30 e0       	ldi	r19, 0x00	; 0
     c48:	f9 01       	movw	r30, r18
     c4a:	20 81       	ld	r18, Z
     c4c:	20 7f       	andi	r18, 0xF0	; 240
     c4e:	fc 01       	movw	r30, r24
     c50:	20 83       	st	Z, r18
    // Define the following pins as output
    DDR_SPI |= ((1<<DD_MOSI)|(1<<DD_SS)|(1<<DD_SCK));
     c52:	84 e3       	ldi	r24, 0x34	; 52
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	24 e3       	ldi	r18, 0x34	; 52
     c58:	30 e0       	ldi	r19, 0x00	; 0
     c5a:	f9 01       	movw	r30, r18
     c5c:	20 81       	ld	r18, Z
     c5e:	2e 60       	ori	r18, 0x0E	; 14
     c60:	fc 01       	movw	r30, r24
     c62:	20 83       	st	Z, r18


    SPCR = ((1<<SPE)|               // SPI Enable
     c64:	8d e2       	ldi	r24, 0x2D	; 45
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	21 e5       	ldi	r18, 0x51	; 81
     c6a:	fc 01       	movw	r30, r24
     c6c:	20 83       	st	Z, r18
            (1<<MSTR)|              // Master/Slave select
            (0<<SPR1)|(1<<SPR0)|    // SPI Clock Rate
            (0<<CPOL)|              // Clock Polarity (0:SCK low / 1:SCK hi when idle)
            (0<<CPHA));             // Clock Phase (0:leading / 1:trailing edge sampling)

    SPSR = (1<<SPI2X);              // Double Clock Rate
     c6e:	8e e2       	ldi	r24, 0x2E	; 46
     c70:	90 e0       	ldi	r25, 0x00	; 0
     c72:	21 e0       	ldi	r18, 0x01	; 1
     c74:	fc 01       	movw	r30, r24
     c76:	20 83       	st	Z, r18

}
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	08 95       	ret

00000c7e <spi_transfer_sync>:

void spi_transfer_sync (uint8_t * dataout, uint8_t * datain, uint8_t len)
// Shift full array through target device
{
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	00 d0       	rcall	.+0      	; 0xc84 <spi_transfer_sync+0x6>
     c84:	00 d0       	rcall	.+0      	; 0xc86 <spi_transfer_sync+0x8>
     c86:	00 d0       	rcall	.+0      	; 0xc88 <spi_transfer_sync+0xa>
     c88:	cd b7       	in	r28, 0x3d	; 61
     c8a:	de b7       	in	r29, 0x3e	; 62
     c8c:	9b 83       	std	Y+3, r25	; 0x03
     c8e:	8a 83       	std	Y+2, r24	; 0x02
     c90:	7d 83       	std	Y+5, r23	; 0x05
     c92:	6c 83       	std	Y+4, r22	; 0x04
     c94:	4e 83       	std	Y+6, r20	; 0x06
       uint8_t i;
       for (i = 0; i < len; i++) {
     c96:	19 82       	std	Y+1, r1	; 0x01
     c98:	24 c0       	rjmp	.+72     	; 0xce2 <spi_transfer_sync+0x64>
             SPDR = dataout[i];
     c9a:	8f e2       	ldi	r24, 0x2F	; 47
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	29 81       	ldd	r18, Y+1	; 0x01
     ca0:	22 2f       	mov	r18, r18
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	4a 81       	ldd	r20, Y+2	; 0x02
     ca6:	5b 81       	ldd	r21, Y+3	; 0x03
     ca8:	24 0f       	add	r18, r20
     caa:	35 1f       	adc	r19, r21
     cac:	f9 01       	movw	r30, r18
     cae:	20 81       	ld	r18, Z
     cb0:	fc 01       	movw	r30, r24
     cb2:	20 83       	st	Z, r18
             while((SPSR & (1<<SPIF))==0);
     cb4:	00 00       	nop
     cb6:	8e e2       	ldi	r24, 0x2E	; 46
     cb8:	90 e0       	ldi	r25, 0x00	; 0
     cba:	fc 01       	movw	r30, r24
     cbc:	80 81       	ld	r24, Z
     cbe:	88 23       	and	r24, r24
     cc0:	d4 f7       	brge	.-12     	; 0xcb6 <spi_transfer_sync+0x38>
             datain[i] = SPDR;
     cc2:	89 81       	ldd	r24, Y+1	; 0x01
     cc4:	88 2f       	mov	r24, r24
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	2c 81       	ldd	r18, Y+4	; 0x04
     cca:	3d 81       	ldd	r19, Y+5	; 0x05
     ccc:	82 0f       	add	r24, r18
     cce:	93 1f       	adc	r25, r19
     cd0:	2f e2       	ldi	r18, 0x2F	; 47
     cd2:	30 e0       	ldi	r19, 0x00	; 0
     cd4:	f9 01       	movw	r30, r18
     cd6:	20 81       	ld	r18, Z
     cd8:	fc 01       	movw	r30, r24
     cda:	20 83       	st	Z, r18

void spi_transfer_sync (uint8_t * dataout, uint8_t * datain, uint8_t len)
// Shift full array through target device
{
       uint8_t i;
       for (i = 0; i < len; i++) {
     cdc:	89 81       	ldd	r24, Y+1	; 0x01
     cde:	8f 5f       	subi	r24, 0xFF	; 255
     ce0:	89 83       	std	Y+1, r24	; 0x01
     ce2:	99 81       	ldd	r25, Y+1	; 0x01
     ce4:	8e 81       	ldd	r24, Y+6	; 0x06
     ce6:	98 17       	cp	r25, r24
     ce8:	c0 f2       	brcs	.-80     	; 0xc9a <spi_transfer_sync+0x1c>
             SPDR = dataout[i];
             while((SPSR & (1<<SPIF))==0);
             datain[i] = SPDR;
       }
}
     cea:	26 96       	adiw	r28, 0x06	; 6
     cec:	0f b6       	in	r0, 0x3f	; 63
     cee:	f8 94       	cli
     cf0:	de bf       	out	0x3e, r29	; 62
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	cd bf       	out	0x3d, r28	; 61
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	08 95       	ret

00000cfc <spi_transmit_sync>:

void spi_transmit_sync (uint8_t * dataout, uint8_t len)
// Shift full array to target device without receiving any byte
{
     cfc:	cf 93       	push	r28
     cfe:	df 93       	push	r29
     d00:	00 d0       	rcall	.+0      	; 0xd02 <spi_transmit_sync+0x6>
     d02:	00 d0       	rcall	.+0      	; 0xd04 <spi_transmit_sync+0x8>
     d04:	cd b7       	in	r28, 0x3d	; 61
     d06:	de b7       	in	r29, 0x3e	; 62
     d08:	9b 83       	std	Y+3, r25	; 0x03
     d0a:	8a 83       	std	Y+2, r24	; 0x02
     d0c:	6c 83       	std	Y+4, r22	; 0x04
       uint8_t i;
       for (i = 0; i < len; i++) {
     d0e:	19 82       	std	Y+1, r1	; 0x01
     d10:	17 c0       	rjmp	.+46     	; 0xd40 <spi_transmit_sync+0x44>
             SPDR = dataout[i];
     d12:	8f e2       	ldi	r24, 0x2F	; 47
     d14:	90 e0       	ldi	r25, 0x00	; 0
     d16:	29 81       	ldd	r18, Y+1	; 0x01
     d18:	22 2f       	mov	r18, r18
     d1a:	30 e0       	ldi	r19, 0x00	; 0
     d1c:	4a 81       	ldd	r20, Y+2	; 0x02
     d1e:	5b 81       	ldd	r21, Y+3	; 0x03
     d20:	24 0f       	add	r18, r20
     d22:	35 1f       	adc	r19, r21
     d24:	f9 01       	movw	r30, r18
     d26:	20 81       	ld	r18, Z
     d28:	fc 01       	movw	r30, r24
     d2a:	20 83       	st	Z, r18
             while((SPSR & (1<<SPIF))==0);
     d2c:	00 00       	nop
     d2e:	8e e2       	ldi	r24, 0x2E	; 46
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	fc 01       	movw	r30, r24
     d34:	80 81       	ld	r24, Z
     d36:	88 23       	and	r24, r24
     d38:	d4 f7       	brge	.-12     	; 0xd2e <spi_transmit_sync+0x32>

void spi_transmit_sync (uint8_t * dataout, uint8_t len)
// Shift full array to target device without receiving any byte
{
       uint8_t i;
       for (i = 0; i < len; i++) {
     d3a:	89 81       	ldd	r24, Y+1	; 0x01
     d3c:	8f 5f       	subi	r24, 0xFF	; 255
     d3e:	89 83       	std	Y+1, r24	; 0x01
     d40:	99 81       	ldd	r25, Y+1	; 0x01
     d42:	8c 81       	ldd	r24, Y+4	; 0x04
     d44:	98 17       	cp	r25, r24
     d46:	28 f3       	brcs	.-54     	; 0xd12 <spi_transmit_sync+0x16>
             SPDR = dataout[i];
             while((SPSR & (1<<SPIF))==0);
       }
}
     d48:	0f 90       	pop	r0
     d4a:	0f 90       	pop	r0
     d4c:	0f 90       	pop	r0
     d4e:	0f 90       	pop	r0
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	08 95       	ret

00000d56 <spi_fast_shift>:

uint8_t spi_fast_shift (uint8_t data)
// Clocks only one byte to target device and returns the received one
{
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	1f 92       	push	r1
     d5c:	cd b7       	in	r28, 0x3d	; 61
     d5e:	de b7       	in	r29, 0x3e	; 62
     d60:	89 83       	std	Y+1, r24	; 0x01
    SPDR = data;
     d62:	8f e2       	ldi	r24, 0x2F	; 47
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	29 81       	ldd	r18, Y+1	; 0x01
     d68:	fc 01       	movw	r30, r24
     d6a:	20 83       	st	Z, r18
    while((SPSR & (1<<SPIF))==0);
     d6c:	00 00       	nop
     d6e:	8e e2       	ldi	r24, 0x2E	; 46
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	fc 01       	movw	r30, r24
     d74:	80 81       	ld	r24, Z
     d76:	88 23       	and	r24, r24
     d78:	d4 f7       	brge	.-12     	; 0xd6e <spi_fast_shift+0x18>
    return SPDR;
     d7a:	8f e2       	ldi	r24, 0x2F	; 47
     d7c:	90 e0       	ldi	r25, 0x00	; 0
     d7e:	fc 01       	movw	r30, r24
     d80:	80 81       	ld	r24, Z
}
     d82:	0f 90       	pop	r0
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	08 95       	ret

00000d8a <DELAY_us>:
         It generates a delay of approximate 1us for each count,
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
     d8a:	cf 93       	push	r28
     d8c:	df 93       	push	r29
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
     d92:	a3 97       	sbiw	r28, 0x23	; 35
     d94:	0f b6       	in	r0, 0x3f	; 63
     d96:	f8 94       	cli
     d98:	de bf       	out	0x3e, r29	; 62
     d9a:	0f be       	out	0x3f, r0	; 63
     d9c:	cd bf       	out	0x3d, r28	; 61
     d9e:	9b a3       	std	Y+35, r25	; 0x23
     da0:	8a a3       	std	Y+34, r24	; 0x22
    while (us_count != 0) 
     da2:	f8 c0       	rjmp	.+496    	; 0xf94 <DELAY_us+0x20a>
     da4:	80 e0       	ldi	r24, 0x00	; 0
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	a0 e8       	ldi	r26, 0x80	; 128
     daa:	bf e3       	ldi	r27, 0x3F	; 63
     dac:	89 83       	std	Y+1, r24	; 0x01
     dae:	9a 83       	std	Y+2, r25	; 0x02
     db0:	ab 83       	std	Y+3, r26	; 0x03
     db2:	bc 83       	std	Y+4, r27	; 0x04
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ; 
	__tmp = ((F_CPU) / 3e6) * __us;
     db4:	2b ea       	ldi	r18, 0xAB	; 171
     db6:	3a ea       	ldi	r19, 0xAA	; 170
     db8:	4a e2       	ldi	r20, 0x2A	; 42
     dba:	50 e4       	ldi	r21, 0x40	; 64
     dbc:	69 81       	ldd	r22, Y+1	; 0x01
     dbe:	7a 81       	ldd	r23, Y+2	; 0x02
     dc0:	8b 81       	ldd	r24, Y+3	; 0x03
     dc2:	9c 81       	ldd	r25, Y+4	; 0x04
     dc4:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
     dc8:	dc 01       	movw	r26, r24
     dca:	cb 01       	movw	r24, r22
     dcc:	8d 83       	std	Y+5, r24	; 0x05
     dce:	9e 83       	std	Y+6, r25	; 0x06
     dd0:	af 83       	std	Y+7, r26	; 0x07
     dd2:	b8 87       	std	Y+8, r27	; 0x08
	__tmp2 = ((F_CPU) / 4e6) * __us;
     dd4:	89 81       	ldd	r24, Y+1	; 0x01
     dd6:	9a 81       	ldd	r25, Y+2	; 0x02
     dd8:	ab 81       	ldd	r26, Y+3	; 0x03
     dda:	bc 81       	ldd	r27, Y+4	; 0x04
     ddc:	9c 01       	movw	r18, r24
     dde:	ad 01       	movw	r20, r26
     de0:	bc 01       	movw	r22, r24
     de2:	cd 01       	movw	r24, r26
     de4:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <__addsf3>
     de8:	dc 01       	movw	r26, r24
     dea:	cb 01       	movw	r24, r22
     dec:	89 87       	std	Y+9, r24	; 0x09
     dee:	9a 87       	std	Y+10, r25	; 0x0a
     df0:	ab 87       	std	Y+11, r26	; 0x0b
     df2:	bc 87       	std	Y+12, r27	; 0x0c
	if (__tmp < 1.0)
     df4:	20 e0       	ldi	r18, 0x00	; 0
     df6:	30 e0       	ldi	r19, 0x00	; 0
     df8:	40 e8       	ldi	r20, 0x80	; 128
     dfa:	5f e3       	ldi	r21, 0x3F	; 63
     dfc:	6d 81       	ldd	r22, Y+5	; 0x05
     dfe:	7e 81       	ldd	r23, Y+6	; 0x06
     e00:	8f 81       	ldd	r24, Y+7	; 0x07
     e02:	98 85       	ldd	r25, Y+8	; 0x08
     e04:	0e 94 95 1f 	call	0x3f2a	; 0x3f2a <__cmpsf2>
     e08:	88 23       	and	r24, r24
     e0a:	1c f4       	brge	.+6      	; 0xe12 <DELAY_us+0x88>
		__ticks = 1;
     e0c:	81 e0       	ldi	r24, 0x01	; 1
     e0e:	8d 87       	std	Y+13, r24	; 0x0d
     e10:	b6 c0       	rjmp	.+364    	; 0xf7e <DELAY_us+0x1f4>
	else if (__tmp2 > 65535)
     e12:	20 e0       	ldi	r18, 0x00	; 0
     e14:	3f ef       	ldi	r19, 0xFF	; 255
     e16:	4f e7       	ldi	r20, 0x7F	; 127
     e18:	57 e4       	ldi	r21, 0x47	; 71
     e1a:	69 85       	ldd	r22, Y+9	; 0x09
     e1c:	7a 85       	ldd	r23, Y+10	; 0x0a
     e1e:	8b 85       	ldd	r24, Y+11	; 0x0b
     e20:	9c 85       	ldd	r25, Y+12	; 0x0c
     e22:	0e 94 df 20 	call	0x41be	; 0x41be <__gesf2>
     e26:	18 16       	cp	r1, r24
     e28:	0c f0       	brlt	.+2      	; 0xe2c <DELAY_us+0xa2>
     e2a:	7f c0       	rjmp	.+254    	; 0xf2a <DELAY_us+0x1a0>
	{
		_delay_ms(__us / 1000.0);
     e2c:	20 e0       	ldi	r18, 0x00	; 0
     e2e:	30 e0       	ldi	r19, 0x00	; 0
     e30:	4a e7       	ldi	r20, 0x7A	; 122
     e32:	54 e4       	ldi	r21, 0x44	; 68
     e34:	69 81       	ldd	r22, Y+1	; 0x01
     e36:	7a 81       	ldd	r23, Y+2	; 0x02
     e38:	8b 81       	ldd	r24, Y+3	; 0x03
     e3a:	9c 81       	ldd	r25, Y+4	; 0x04
     e3c:	0e 94 99 1f 	call	0x3f32	; 0x3f32 <__divsf3>
     e40:	dc 01       	movw	r26, r24
     e42:	cb 01       	movw	r24, r22
     e44:	8e 87       	std	Y+14, r24	; 0x0e
     e46:	9f 87       	std	Y+15, r25	; 0x0f
     e48:	a8 8b       	std	Y+16, r26	; 0x10
     e4a:	b9 8b       	std	Y+17, r27	; 0x11

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
     e4c:	20 e0       	ldi	r18, 0x00	; 0
     e4e:	30 e0       	ldi	r19, 0x00	; 0
     e50:	4a ef       	ldi	r20, 0xFA	; 250
     e52:	54 e4       	ldi	r21, 0x44	; 68
     e54:	6e 85       	ldd	r22, Y+14	; 0x0e
     e56:	7f 85       	ldd	r23, Y+15	; 0x0f
     e58:	88 89       	ldd	r24, Y+16	; 0x10
     e5a:	99 89       	ldd	r25, Y+17	; 0x11
     e5c:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
     e60:	dc 01       	movw	r26, r24
     e62:	cb 01       	movw	r24, r22
     e64:	8a 8b       	std	Y+18, r24	; 0x12
     e66:	9b 8b       	std	Y+19, r25	; 0x13
     e68:	ac 8b       	std	Y+20, r26	; 0x14
     e6a:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
     e6c:	20 e0       	ldi	r18, 0x00	; 0
     e6e:	30 e0       	ldi	r19, 0x00	; 0
     e70:	40 e8       	ldi	r20, 0x80	; 128
     e72:	5f e3       	ldi	r21, 0x3F	; 63
     e74:	6a 89       	ldd	r22, Y+18	; 0x12
     e76:	7b 89       	ldd	r23, Y+19	; 0x13
     e78:	8c 89       	ldd	r24, Y+20	; 0x14
     e7a:	9d 89       	ldd	r25, Y+21	; 0x15
     e7c:	0e 94 95 1f 	call	0x3f2a	; 0x3f2a <__cmpsf2>
     e80:	88 23       	and	r24, r24
     e82:	2c f4       	brge	.+10     	; 0xe8e <DELAY_us+0x104>
		__ticks = 1;
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	9f 8b       	std	Y+23, r25	; 0x17
     e8a:	8e 8b       	std	Y+22, r24	; 0x16
     e8c:	41 c0       	rjmp	.+130    	; 0xf10 <DELAY_us+0x186>
	else if (__tmp > 65535)
     e8e:	20 e0       	ldi	r18, 0x00	; 0
     e90:	3f ef       	ldi	r19, 0xFF	; 255
     e92:	4f e7       	ldi	r20, 0x7F	; 127
     e94:	57 e4       	ldi	r21, 0x47	; 71
     e96:	6a 89       	ldd	r22, Y+18	; 0x12
     e98:	7b 89       	ldd	r23, Y+19	; 0x13
     e9a:	8c 89       	ldd	r24, Y+20	; 0x14
     e9c:	9d 89       	ldd	r25, Y+21	; 0x15
     e9e:	0e 94 df 20 	call	0x41be	; 0x41be <__gesf2>
     ea2:	18 16       	cp	r1, r24
     ea4:	5c f5       	brge	.+86     	; 0xefc <DELAY_us+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     ea6:	20 e0       	ldi	r18, 0x00	; 0
     ea8:	30 e0       	ldi	r19, 0x00	; 0
     eaa:	40 e2       	ldi	r20, 0x20	; 32
     eac:	51 e4       	ldi	r21, 0x41	; 65
     eae:	6e 85       	ldd	r22, Y+14	; 0x0e
     eb0:	7f 85       	ldd	r23, Y+15	; 0x0f
     eb2:	88 89       	ldd	r24, Y+16	; 0x10
     eb4:	99 89       	ldd	r25, Y+17	; 0x11
     eb6:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
     eba:	dc 01       	movw	r26, r24
     ebc:	cb 01       	movw	r24, r22
     ebe:	bc 01       	movw	r22, r24
     ec0:	cd 01       	movw	r24, r26
     ec2:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
     ec6:	dc 01       	movw	r26, r24
     ec8:	cb 01       	movw	r24, r22
     eca:	9f 8b       	std	Y+23, r25	; 0x17
     ecc:	8e 8b       	std	Y+22, r24	; 0x16
     ece:	0f c0       	rjmp	.+30     	; 0xeee <DELAY_us+0x164>
     ed0:	88 ec       	ldi	r24, 0xC8	; 200
     ed2:	90 e0       	ldi	r25, 0x00	; 0
     ed4:	99 8f       	std	Y+25, r25	; 0x19
     ed6:	88 8f       	std	Y+24, r24	; 0x18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ed8:	88 8d       	ldd	r24, Y+24	; 0x18
     eda:	99 8d       	ldd	r25, Y+25	; 0x19
     edc:	01 97       	sbiw	r24, 0x01	; 1
     ede:	f1 f7       	brne	.-4      	; 0xedc <DELAY_us+0x152>
     ee0:	99 8f       	std	Y+25, r25	; 0x19
     ee2:	88 8f       	std	Y+24, r24	; 0x18
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ee4:	8e 89       	ldd	r24, Y+22	; 0x16
     ee6:	9f 89       	ldd	r25, Y+23	; 0x17
     ee8:	01 97       	sbiw	r24, 0x01	; 1
     eea:	9f 8b       	std	Y+23, r25	; 0x17
     eec:	8e 8b       	std	Y+22, r24	; 0x16
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     eee:	8e 89       	ldd	r24, Y+22	; 0x16
     ef0:	9f 89       	ldd	r25, Y+23	; 0x17
     ef2:	00 97       	sbiw	r24, 0x00	; 0
     ef4:	69 f7       	brne	.-38     	; 0xed0 <DELAY_us+0x146>
     ef6:	89 a1       	ldd	r24, Y+33	; 0x21
     ef8:	8d 87       	std	Y+13, r24	; 0x0d
     efa:	41 c0       	rjmp	.+130    	; 0xf7e <DELAY_us+0x1f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     efc:	6a 89       	ldd	r22, Y+18	; 0x12
     efe:	7b 89       	ldd	r23, Y+19	; 0x13
     f00:	8c 89       	ldd	r24, Y+20	; 0x14
     f02:	9d 89       	ldd	r25, Y+21	; 0x15
     f04:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
     f08:	dc 01       	movw	r26, r24
     f0a:	cb 01       	movw	r24, r22
     f0c:	9f 8b       	std	Y+23, r25	; 0x17
     f0e:	8e 8b       	std	Y+22, r24	; 0x16
     f10:	8e 89       	ldd	r24, Y+22	; 0x16
     f12:	9f 89       	ldd	r25, Y+23	; 0x17
     f14:	9b 8f       	std	Y+27, r25	; 0x1b
     f16:	8a 8f       	std	Y+26, r24	; 0x1a
     f18:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f1a:	9b 8d       	ldd	r25, Y+27	; 0x1b
     f1c:	01 97       	sbiw	r24, 0x01	; 1
     f1e:	f1 f7       	brne	.-4      	; 0xf1c <DELAY_us+0x192>
     f20:	9b 8f       	std	Y+27, r25	; 0x1b
     f22:	8a 8f       	std	Y+26, r24	; 0x1a
     f24:	89 a1       	ldd	r24, Y+33	; 0x21
     f26:	8d 87       	std	Y+13, r24	; 0x0d
     f28:	2a c0       	rjmp	.+84     	; 0xf7e <DELAY_us+0x1f4>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
     f2a:	20 e0       	ldi	r18, 0x00	; 0
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	4f e7       	ldi	r20, 0x7F	; 127
     f30:	53 e4       	ldi	r21, 0x43	; 67
     f32:	6d 81       	ldd	r22, Y+5	; 0x05
     f34:	7e 81       	ldd	r23, Y+6	; 0x06
     f36:	8f 81       	ldd	r24, Y+7	; 0x07
     f38:	98 85       	ldd	r25, Y+8	; 0x08
     f3a:	0e 94 df 20 	call	0x41be	; 0x41be <__gesf2>
     f3e:	18 16       	cp	r1, r24
     f40:	ac f4       	brge	.+42     	; 0xf6c <DELAY_us+0x1e2>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
     f42:	69 85       	ldd	r22, Y+9	; 0x09
     f44:	7a 85       	ldd	r23, Y+10	; 0x0a
     f46:	8b 85       	ldd	r24, Y+11	; 0x0b
     f48:	9c 85       	ldd	r25, Y+12	; 0x0c
     f4a:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
     f4e:	dc 01       	movw	r26, r24
     f50:	cb 01       	movw	r24, r22
     f52:	9d 8f       	std	Y+29, r25	; 0x1d
     f54:	8c 8f       	std	Y+28, r24	; 0x1c
     f56:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f58:	9d 8d       	ldd	r25, Y+29	; 0x1d
     f5a:	9f 8f       	std	Y+31, r25	; 0x1f
     f5c:	8e 8f       	std	Y+30, r24	; 0x1e
     f5e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f60:	9f 8d       	ldd	r25, Y+31	; 0x1f
     f62:	01 97       	sbiw	r24, 0x01	; 1
     f64:	f1 f7       	brne	.-4      	; 0xf62 <DELAY_us+0x1d8>
     f66:	9f 8f       	std	Y+31, r25	; 0x1f
     f68:	8e 8f       	std	Y+30, r24	; 0x1e
     f6a:	0f c0       	rjmp	.+30     	; 0xf8a <DELAY_us+0x200>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
     f6c:	6d 81       	ldd	r22, Y+5	; 0x05
     f6e:	7e 81       	ldd	r23, Y+6	; 0x06
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	98 85       	ldd	r25, Y+8	; 0x08
     f74:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
     f78:	dc 01       	movw	r26, r24
     f7a:	cb 01       	movw	r24, r22
     f7c:	8d 87       	std	Y+13, r24	; 0x0d
     f7e:	8d 85       	ldd	r24, Y+13	; 0x0d
     f80:	88 a3       	std	Y+32, r24	; 0x20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     f82:	88 a1       	ldd	r24, Y+32	; 0x20
     f84:	8a 95       	dec	r24
     f86:	f1 f7       	brne	.-4      	; 0xf84 <DELAY_us+0x1fa>
     f88:	88 a3       	std	Y+32, r24	; 0x20
    {
        _delay_us(1);
		us_count--;
     f8a:	8a a1       	ldd	r24, Y+34	; 0x22
     f8c:	9b a1       	ldd	r25, Y+35	; 0x23
     f8e:	01 97       	sbiw	r24, 0x01	; 1
     f90:	9b a3       	std	Y+35, r25	; 0x23
     f92:	8a a3       	std	Y+34, r24	; 0x22
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
     f94:	8a a1       	ldd	r24, Y+34	; 0x22
     f96:	9b a1       	ldd	r25, Y+35	; 0x23
     f98:	00 97       	sbiw	r24, 0x00	; 0
     f9a:	09 f0       	breq	.+2      	; 0xf9e <DELAY_us+0x214>
     f9c:	03 cf       	rjmp	.-506    	; 0xda4 <DELAY_us+0x1a>
    {
        _delay_us(1);
		us_count--;
    }
}
     f9e:	a3 96       	adiw	r28, 0x23	; 35
     fa0:	0f b6       	in	r0, 0x3f	; 63
     fa2:	f8 94       	cli
     fa4:	de bf       	out	0x3e, r29	; 62
     fa6:	0f be       	out	0x3f, r0	; 63
     fa8:	cd bf       	out	0x3d, r28	; 61
     faa:	df 91       	pop	r29
     fac:	cf 91       	pop	r28
     fae:	08 95       	ret

00000fb0 <DELAY_ms>:
     This function is used generate delay in ms.
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
     fb0:	cf 93       	push	r28
     fb2:	df 93       	push	r29
     fb4:	cd b7       	in	r28, 0x3d	; 61
     fb6:	de b7       	in	r29, 0x3e	; 62
     fb8:	a3 97       	sbiw	r28, 0x23	; 35
     fba:	0f b6       	in	r0, 0x3f	; 63
     fbc:	f8 94       	cli
     fbe:	de bf       	out	0x3e, r29	; 62
     fc0:	0f be       	out	0x3f, r0	; 63
     fc2:	cd bf       	out	0x3d, r28	; 61
     fc4:	9b a3       	std	Y+35, r25	; 0x23
     fc6:	8a a3       	std	Y+34, r24	; 0x22
    while (ms_count != 0) 
     fc8:	f8 c0       	rjmp	.+496    	; 0x11ba <DELAY_ms+0x20a>
     fca:	80 e0       	ldi	r24, 0x00	; 0
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	aa e7       	ldi	r26, 0x7A	; 122
     fd0:	b4 e4       	ldi	r27, 0x44	; 68
     fd2:	89 83       	std	Y+1, r24	; 0x01
     fd4:	9a 83       	std	Y+2, r25	; 0x02
     fd6:	ab 83       	std	Y+3, r26	; 0x03
     fd8:	bc 83       	std	Y+4, r27	; 0x04
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ; 
	__tmp = ((F_CPU) / 3e6) * __us;
     fda:	2b ea       	ldi	r18, 0xAB	; 171
     fdc:	3a ea       	ldi	r19, 0xAA	; 170
     fde:	4a e2       	ldi	r20, 0x2A	; 42
     fe0:	50 e4       	ldi	r21, 0x40	; 64
     fe2:	69 81       	ldd	r22, Y+1	; 0x01
     fe4:	7a 81       	ldd	r23, Y+2	; 0x02
     fe6:	8b 81       	ldd	r24, Y+3	; 0x03
     fe8:	9c 81       	ldd	r25, Y+4	; 0x04
     fea:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
     fee:	dc 01       	movw	r26, r24
     ff0:	cb 01       	movw	r24, r22
     ff2:	8d 83       	std	Y+5, r24	; 0x05
     ff4:	9e 83       	std	Y+6, r25	; 0x06
     ff6:	af 83       	std	Y+7, r26	; 0x07
     ff8:	b8 87       	std	Y+8, r27	; 0x08
	__tmp2 = ((F_CPU) / 4e6) * __us;
     ffa:	89 81       	ldd	r24, Y+1	; 0x01
     ffc:	9a 81       	ldd	r25, Y+2	; 0x02
     ffe:	ab 81       	ldd	r26, Y+3	; 0x03
    1000:	bc 81       	ldd	r27, Y+4	; 0x04
    1002:	9c 01       	movw	r18, r24
    1004:	ad 01       	movw	r20, r26
    1006:	bc 01       	movw	r22, r24
    1008:	cd 01       	movw	r24, r26
    100a:	0e 94 31 1f 	call	0x3e62	; 0x3e62 <__addsf3>
    100e:	dc 01       	movw	r26, r24
    1010:	cb 01       	movw	r24, r22
    1012:	89 87       	std	Y+9, r24	; 0x09
    1014:	9a 87       	std	Y+10, r25	; 0x0a
    1016:	ab 87       	std	Y+11, r26	; 0x0b
    1018:	bc 87       	std	Y+12, r27	; 0x0c
	if (__tmp < 1.0)
    101a:	20 e0       	ldi	r18, 0x00	; 0
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	40 e8       	ldi	r20, 0x80	; 128
    1020:	5f e3       	ldi	r21, 0x3F	; 63
    1022:	6d 81       	ldd	r22, Y+5	; 0x05
    1024:	7e 81       	ldd	r23, Y+6	; 0x06
    1026:	8f 81       	ldd	r24, Y+7	; 0x07
    1028:	98 85       	ldd	r25, Y+8	; 0x08
    102a:	0e 94 95 1f 	call	0x3f2a	; 0x3f2a <__cmpsf2>
    102e:	88 23       	and	r24, r24
    1030:	1c f4       	brge	.+6      	; 0x1038 <DELAY_ms+0x88>
		__ticks = 1;
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	8d 87       	std	Y+13, r24	; 0x0d
    1036:	b6 c0       	rjmp	.+364    	; 0x11a4 <DELAY_ms+0x1f4>
	else if (__tmp2 > 65535)
    1038:	20 e0       	ldi	r18, 0x00	; 0
    103a:	3f ef       	ldi	r19, 0xFF	; 255
    103c:	4f e7       	ldi	r20, 0x7F	; 127
    103e:	57 e4       	ldi	r21, 0x47	; 71
    1040:	69 85       	ldd	r22, Y+9	; 0x09
    1042:	7a 85       	ldd	r23, Y+10	; 0x0a
    1044:	8b 85       	ldd	r24, Y+11	; 0x0b
    1046:	9c 85       	ldd	r25, Y+12	; 0x0c
    1048:	0e 94 df 20 	call	0x41be	; 0x41be <__gesf2>
    104c:	18 16       	cp	r1, r24
    104e:	0c f0       	brlt	.+2      	; 0x1052 <DELAY_ms+0xa2>
    1050:	7f c0       	rjmp	.+254    	; 0x1150 <DELAY_ms+0x1a0>
	{
		_delay_ms(__us / 1000.0);
    1052:	20 e0       	ldi	r18, 0x00	; 0
    1054:	30 e0       	ldi	r19, 0x00	; 0
    1056:	4a e7       	ldi	r20, 0x7A	; 122
    1058:	54 e4       	ldi	r21, 0x44	; 68
    105a:	69 81       	ldd	r22, Y+1	; 0x01
    105c:	7a 81       	ldd	r23, Y+2	; 0x02
    105e:	8b 81       	ldd	r24, Y+3	; 0x03
    1060:	9c 81       	ldd	r25, Y+4	; 0x04
    1062:	0e 94 99 1f 	call	0x3f32	; 0x3f32 <__divsf3>
    1066:	dc 01       	movw	r26, r24
    1068:	cb 01       	movw	r24, r22
    106a:	8e 87       	std	Y+14, r24	; 0x0e
    106c:	9f 87       	std	Y+15, r25	; 0x0f
    106e:	a8 8b       	std	Y+16, r26	; 0x10
    1070:	b9 8b       	std	Y+17, r27	; 0x11

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    1072:	20 e0       	ldi	r18, 0x00	; 0
    1074:	30 e0       	ldi	r19, 0x00	; 0
    1076:	4a ef       	ldi	r20, 0xFA	; 250
    1078:	54 e4       	ldi	r21, 0x44	; 68
    107a:	6e 85       	ldd	r22, Y+14	; 0x0e
    107c:	7f 85       	ldd	r23, Y+15	; 0x0f
    107e:	88 89       	ldd	r24, Y+16	; 0x10
    1080:	99 89       	ldd	r25, Y+17	; 0x11
    1082:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
    1086:	dc 01       	movw	r26, r24
    1088:	cb 01       	movw	r24, r22
    108a:	8a 8b       	std	Y+18, r24	; 0x12
    108c:	9b 8b       	std	Y+19, r25	; 0x13
    108e:	ac 8b       	std	Y+20, r26	; 0x14
    1090:	bd 8b       	std	Y+21, r27	; 0x15
	if (__tmp < 1.0)
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	40 e8       	ldi	r20, 0x80	; 128
    1098:	5f e3       	ldi	r21, 0x3F	; 63
    109a:	6a 89       	ldd	r22, Y+18	; 0x12
    109c:	7b 89       	ldd	r23, Y+19	; 0x13
    109e:	8c 89       	ldd	r24, Y+20	; 0x14
    10a0:	9d 89       	ldd	r25, Y+21	; 0x15
    10a2:	0e 94 95 1f 	call	0x3f2a	; 0x3f2a <__cmpsf2>
    10a6:	88 23       	and	r24, r24
    10a8:	2c f4       	brge	.+10     	; 0x10b4 <DELAY_ms+0x104>
		__ticks = 1;
    10aa:	81 e0       	ldi	r24, 0x01	; 1
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	9f 8b       	std	Y+23, r25	; 0x17
    10b0:	8e 8b       	std	Y+22, r24	; 0x16
    10b2:	41 c0       	rjmp	.+130    	; 0x1136 <DELAY_ms+0x186>
	else if (__tmp > 65535)
    10b4:	20 e0       	ldi	r18, 0x00	; 0
    10b6:	3f ef       	ldi	r19, 0xFF	; 255
    10b8:	4f e7       	ldi	r20, 0x7F	; 127
    10ba:	57 e4       	ldi	r21, 0x47	; 71
    10bc:	6a 89       	ldd	r22, Y+18	; 0x12
    10be:	7b 89       	ldd	r23, Y+19	; 0x13
    10c0:	8c 89       	ldd	r24, Y+20	; 0x14
    10c2:	9d 89       	ldd	r25, Y+21	; 0x15
    10c4:	0e 94 df 20 	call	0x41be	; 0x41be <__gesf2>
    10c8:	18 16       	cp	r1, r24
    10ca:	5c f5       	brge	.+86     	; 0x1122 <DELAY_ms+0x172>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    10cc:	20 e0       	ldi	r18, 0x00	; 0
    10ce:	30 e0       	ldi	r19, 0x00	; 0
    10d0:	40 e2       	ldi	r20, 0x20	; 32
    10d2:	51 e4       	ldi	r21, 0x41	; 65
    10d4:	6e 85       	ldd	r22, Y+14	; 0x0e
    10d6:	7f 85       	ldd	r23, Y+15	; 0x0f
    10d8:	88 89       	ldd	r24, Y+16	; 0x10
    10da:	99 89       	ldd	r25, Y+17	; 0x11
    10dc:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
    10e0:	dc 01       	movw	r26, r24
    10e2:	cb 01       	movw	r24, r22
    10e4:	bc 01       	movw	r22, r24
    10e6:	cd 01       	movw	r24, r26
    10e8:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
    10ec:	dc 01       	movw	r26, r24
    10ee:	cb 01       	movw	r24, r22
    10f0:	9f 8b       	std	Y+23, r25	; 0x17
    10f2:	8e 8b       	std	Y+22, r24	; 0x16
    10f4:	0f c0       	rjmp	.+30     	; 0x1114 <DELAY_ms+0x164>
    10f6:	88 ec       	ldi	r24, 0xC8	; 200
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	99 8f       	std	Y+25, r25	; 0x19
    10fc:	88 8f       	std	Y+24, r24	; 0x18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    10fe:	88 8d       	ldd	r24, Y+24	; 0x18
    1100:	99 8d       	ldd	r25, Y+25	; 0x19
    1102:	01 97       	sbiw	r24, 0x01	; 1
    1104:	f1 f7       	brne	.-4      	; 0x1102 <DELAY_ms+0x152>
    1106:	99 8f       	std	Y+25, r25	; 0x19
    1108:	88 8f       	std	Y+24, r24	; 0x18
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    110a:	8e 89       	ldd	r24, Y+22	; 0x16
    110c:	9f 89       	ldd	r25, Y+23	; 0x17
    110e:	01 97       	sbiw	r24, 0x01	; 1
    1110:	9f 8b       	std	Y+23, r25	; 0x17
    1112:	8e 8b       	std	Y+22, r24	; 0x16
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1114:	8e 89       	ldd	r24, Y+22	; 0x16
    1116:	9f 89       	ldd	r25, Y+23	; 0x17
    1118:	00 97       	sbiw	r24, 0x00	; 0
    111a:	69 f7       	brne	.-38     	; 0x10f6 <DELAY_ms+0x146>
    111c:	89 a1       	ldd	r24, Y+33	; 0x21
    111e:	8d 87       	std	Y+13, r24	; 0x0d
    1120:	41 c0       	rjmp	.+130    	; 0x11a4 <DELAY_ms+0x1f4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1122:	6a 89       	ldd	r22, Y+18	; 0x12
    1124:	7b 89       	ldd	r23, Y+19	; 0x13
    1126:	8c 89       	ldd	r24, Y+20	; 0x14
    1128:	9d 89       	ldd	r25, Y+21	; 0x15
    112a:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
    112e:	dc 01       	movw	r26, r24
    1130:	cb 01       	movw	r24, r22
    1132:	9f 8b       	std	Y+23, r25	; 0x17
    1134:	8e 8b       	std	Y+22, r24	; 0x16
    1136:	8e 89       	ldd	r24, Y+22	; 0x16
    1138:	9f 89       	ldd	r25, Y+23	; 0x17
    113a:	9b 8f       	std	Y+27, r25	; 0x1b
    113c:	8a 8f       	std	Y+26, r24	; 0x1a
    113e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1140:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1142:	01 97       	sbiw	r24, 0x01	; 1
    1144:	f1 f7       	brne	.-4      	; 0x1142 <DELAY_ms+0x192>
    1146:	9b 8f       	std	Y+27, r25	; 0x1b
    1148:	8a 8f       	std	Y+26, r24	; 0x1a
    114a:	89 a1       	ldd	r24, Y+33	; 0x21
    114c:	8d 87       	std	Y+13, r24	; 0x0d
    114e:	2a c0       	rjmp	.+84     	; 0x11a4 <DELAY_ms+0x1f4>
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    1150:	20 e0       	ldi	r18, 0x00	; 0
    1152:	30 e0       	ldi	r19, 0x00	; 0
    1154:	4f e7       	ldi	r20, 0x7F	; 127
    1156:	53 e4       	ldi	r21, 0x43	; 67
    1158:	6d 81       	ldd	r22, Y+5	; 0x05
    115a:	7e 81       	ldd	r23, Y+6	; 0x06
    115c:	8f 81       	ldd	r24, Y+7	; 0x07
    115e:	98 85       	ldd	r25, Y+8	; 0x08
    1160:	0e 94 df 20 	call	0x41be	; 0x41be <__gesf2>
    1164:	18 16       	cp	r1, r24
    1166:	ac f4       	brge	.+42     	; 0x1192 <DELAY_ms+0x1e2>
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    1168:	69 85       	ldd	r22, Y+9	; 0x09
    116a:	7a 85       	ldd	r23, Y+10	; 0x0a
    116c:	8b 85       	ldd	r24, Y+11	; 0x0b
    116e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1170:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
    1174:	dc 01       	movw	r26, r24
    1176:	cb 01       	movw	r24, r22
    1178:	9d 8f       	std	Y+29, r25	; 0x1d
    117a:	8c 8f       	std	Y+28, r24	; 0x1c
    117c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    117e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1180:	9f 8f       	std	Y+31, r25	; 0x1f
    1182:	8e 8f       	std	Y+30, r24	; 0x1e
    1184:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1186:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1188:	01 97       	sbiw	r24, 0x01	; 1
    118a:	f1 f7       	brne	.-4      	; 0x1188 <DELAY_ms+0x1d8>
    118c:	9f 8f       	std	Y+31, r25	; 0x1f
    118e:	8e 8f       	std	Y+30, r24	; 0x1e
    1190:	0f c0       	rjmp	.+30     	; 0x11b0 <DELAY_ms+0x200>
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1192:	6d 81       	ldd	r22, Y+5	; 0x05
    1194:	7e 81       	ldd	r23, Y+6	; 0x06
    1196:	8f 81       	ldd	r24, Y+7	; 0x07
    1198:	98 85       	ldd	r25, Y+8	; 0x08
    119a:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
    119e:	dc 01       	movw	r26, r24
    11a0:	cb 01       	movw	r24, r22
    11a2:	8d 87       	std	Y+13, r24	; 0x0d
    11a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    11a6:	88 a3       	std	Y+32, r24	; 0x20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    11a8:	88 a1       	ldd	r24, Y+32	; 0x20
    11aa:	8a 95       	dec	r24
    11ac:	f1 f7       	brne	.-4      	; 0x11aa <DELAY_ms+0x1fa>
    11ae:	88 a3       	std	Y+32, r24	; 0x20
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
    11b0:	8a a1       	ldd	r24, Y+34	; 0x22
    11b2:	9b a1       	ldd	r25, Y+35	; 0x23
    11b4:	01 97       	sbiw	r24, 0x01	; 1
    11b6:	9b a3       	std	Y+35, r25	; 0x23
    11b8:	8a a3       	std	Y+34, r24	; 0x22
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
    11ba:	8a a1       	ldd	r24, Y+34	; 0x22
    11bc:	9b a1       	ldd	r25, Y+35	; 0x23
    11be:	00 97       	sbiw	r24, 0x00	; 0
    11c0:	09 f0       	breq	.+2      	; 0x11c4 <DELAY_ms+0x214>
    11c2:	03 cf       	rjmp	.-506    	; 0xfca <DELAY_ms+0x1a>
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
    }
}
    11c4:	a3 96       	adiw	r28, 0x23	; 35
    11c6:	0f b6       	in	r0, 0x3f	; 63
    11c8:	f8 94       	cli
    11ca:	de bf       	out	0x3e, r29	; 62
    11cc:	0f be       	out	0x3f, r0	; 63
    11ce:	cd bf       	out	0x3d, r28	; 61
    11d0:	df 91       	pop	r29
    11d2:	cf 91       	pop	r28
    11d4:	08 95       	ret

000011d6 <EEPROM_WriteByte>:

 * description: This function is used to write the data at specified EEPROM_address..

 **************************************************************************************************/
void EEPROM_WriteByte(uint16_t v_eepromAddress_u16, uint8_t v_eepromData_u8)
{
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	00 d0       	rcall	.+0      	; 0x11dc <EEPROM_WriteByte+0x6>
    11dc:	1f 92       	push	r1
    11de:	cd b7       	in	r28, 0x3d	; 61
    11e0:	de b7       	in	r29, 0x3e	; 62
    11e2:	9a 83       	std	Y+2, r25	; 0x02
    11e4:	89 83       	std	Y+1, r24	; 0x01
    11e6:	6b 83       	std	Y+3, r22	; 0x03
	while(util_IsBitSet(EECR,EEWE)); // Wait for completion of previous write.
    11e8:	00 00       	nop
    11ea:	8c e3       	ldi	r24, 0x3C	; 60
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	fc 01       	movw	r30, r24
    11f0:	80 81       	ld	r24, Z
    11f2:	88 2f       	mov	r24, r24
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	82 70       	andi	r24, 0x02	; 2
    11f8:	99 27       	eor	r25, r25
    11fa:	00 97       	sbiw	r24, 0x00	; 0
    11fc:	b1 f7       	brne	.-20     	; 0x11ea <EEPROM_WriteByte+0x14>
	                                 // EEWE will be cleared by hardware once Eeprom write is completed.

	EEAR = v_eepromAddress_u16;  //Load the eeprom address and data
    11fe:	8e e3       	ldi	r24, 0x3E	; 62
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	29 81       	ldd	r18, Y+1	; 0x01
    1204:	3a 81       	ldd	r19, Y+2	; 0x02
    1206:	fc 01       	movw	r30, r24
    1208:	31 83       	std	Z+1, r19	; 0x01
    120a:	20 83       	st	Z, r18
	EEDR = v_eepromData_u8;
    120c:	8d e3       	ldi	r24, 0x3D	; 61
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	2b 81       	ldd	r18, Y+3	; 0x03
    1212:	fc 01       	movw	r30, r24
    1214:	20 83       	st	Z, r18

	util_BitSet(EECR,EEMWE);    // Eeprom Master Write Enable
    1216:	8c e3       	ldi	r24, 0x3C	; 60
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	2c e3       	ldi	r18, 0x3C	; 60
    121c:	30 e0       	ldi	r19, 0x00	; 0
    121e:	f9 01       	movw	r30, r18
    1220:	20 81       	ld	r18, Z
    1222:	24 60       	ori	r18, 0x04	; 4
    1224:	fc 01       	movw	r30, r24
    1226:	20 83       	st	Z, r18
	util_BitSet(EECR,EEWE);     // Start eeprom write by setting EEWE
    1228:	8c e3       	ldi	r24, 0x3C	; 60
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	2c e3       	ldi	r18, 0x3C	; 60
    122e:	30 e0       	ldi	r19, 0x00	; 0
    1230:	f9 01       	movw	r30, r18
    1232:	20 81       	ld	r18, Z
    1234:	22 60       	ori	r18, 0x02	; 2
    1236:	fc 01       	movw	r30, r24
    1238:	20 83       	st	Z, r18
}
    123a:	0f 90       	pop	r0
    123c:	0f 90       	pop	r0
    123e:	0f 90       	pop	r0
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	08 95       	ret

00001246 <EEPROM_ReadByte>:
 * Return value	: uint8_t: data read from Eeprom.

 * description: This function is used to read the data from specified EEPROM_address.        
 ***************************************************************************************************/
uint8_t EEPROM_ReadByte(uint16_t v_eepromAddress_u16)
{
    1246:	cf 93       	push	r28
    1248:	df 93       	push	r29
    124a:	00 d0       	rcall	.+0      	; 0x124c <EEPROM_ReadByte+0x6>
    124c:	cd b7       	in	r28, 0x3d	; 61
    124e:	de b7       	in	r29, 0x3e	; 62
    1250:	9a 83       	std	Y+2, r25	; 0x02
    1252:	89 83       	std	Y+1, r24	; 0x01
	while(util_IsBitSet(EECR,EEWE));  //Wait for completion of previous write if any.
    1254:	00 00       	nop
    1256:	8c e3       	ldi	r24, 0x3C	; 60
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	fc 01       	movw	r30, r24
    125c:	80 81       	ld	r24, Z
    125e:	88 2f       	mov	r24, r24
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	82 70       	andi	r24, 0x02	; 2
    1264:	99 27       	eor	r25, r25
    1266:	00 97       	sbiw	r24, 0x00	; 0
    1268:	b1 f7       	brne	.-20     	; 0x1256 <EEPROM_ReadByte+0x10>

	EEAR = v_eepromAddress_u16;    //Load the address from where the data needs to be read.
    126a:	8e e3       	ldi	r24, 0x3E	; 62
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	29 81       	ldd	r18, Y+1	; 0x01
    1270:	3a 81       	ldd	r19, Y+2	; 0x02
    1272:	fc 01       	movw	r30, r24
    1274:	31 83       	std	Z+1, r19	; 0x01
    1276:	20 83       	st	Z, r18
	util_BitSet(EECR,EERE);   // start eeprom read by setting EERE
    1278:	8c e3       	ldi	r24, 0x3C	; 60
    127a:	90 e0       	ldi	r25, 0x00	; 0
    127c:	2c e3       	ldi	r18, 0x3C	; 60
    127e:	30 e0       	ldi	r19, 0x00	; 0
    1280:	f9 01       	movw	r30, r18
    1282:	20 81       	ld	r18, Z
    1284:	21 60       	ori	r18, 0x01	; 1
    1286:	fc 01       	movw	r30, r24
    1288:	20 83       	st	Z, r18

	return EEDR;             // Return data from data register
    128a:	8d e3       	ldi	r24, 0x3D	; 61
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	fc 01       	movw	r30, r24
    1290:	80 81       	ld	r24, Z
}
    1292:	0f 90       	pop	r0
    1294:	0f 90       	pop	r0
    1296:	df 91       	pop	r29
    1298:	cf 91       	pop	r28
    129a:	08 95       	ret

0000129c <EEPROM_WriteString>:

   NOTE: Null char is also written into the eeprom.
 ***************************************************************************************************/
#if ( ENABLE_EEPROM_WriteString == 1)
void EEPROM_WriteString(uint16_t v_eepromAddress_u16, uint8_t *ptr_stringPointer_u8)
{
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
    12a0:	00 d0       	rcall	.+0      	; 0x12a2 <EEPROM_WriteString+0x6>
    12a2:	00 d0       	rcall	.+0      	; 0x12a4 <EEPROM_WriteString+0x8>
    12a4:	cd b7       	in	r28, 0x3d	; 61
    12a6:	de b7       	in	r29, 0x3e	; 62
    12a8:	9a 83       	std	Y+2, r25	; 0x02
    12aa:	89 83       	std	Y+1, r24	; 0x01
    12ac:	7c 83       	std	Y+4, r23	; 0x04
    12ae:	6b 83       	std	Y+3, r22	; 0x03
	do
	{
		EEPROM_WriteByte(v_eepromAddress_u16,*ptr_stringPointer_u8); //Write a byte from RAM to EEPROM
    12b0:	8b 81       	ldd	r24, Y+3	; 0x03
    12b2:	9c 81       	ldd	r25, Y+4	; 0x04
    12b4:	fc 01       	movw	r30, r24
    12b6:	20 81       	ld	r18, Z
    12b8:	89 81       	ldd	r24, Y+1	; 0x01
    12ba:	9a 81       	ldd	r25, Y+2	; 0x02
    12bc:	62 2f       	mov	r22, r18
    12be:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <EEPROM_WriteByte>
		ptr_stringPointer_u8++;								//Increment the RAM Address
    12c2:	8b 81       	ldd	r24, Y+3	; 0x03
    12c4:	9c 81       	ldd	r25, Y+4	; 0x04
    12c6:	01 96       	adiw	r24, 0x01	; 1
    12c8:	9c 83       	std	Y+4, r25	; 0x04
    12ca:	8b 83       	std	Y+3, r24	; 0x03
		v_eepromAddress_u16++;								//Increment the Eeprom Address
    12cc:	89 81       	ldd	r24, Y+1	; 0x01
    12ce:	9a 81       	ldd	r25, Y+2	; 0x02
    12d0:	01 96       	adiw	r24, 0x01	; 1
    12d2:	9a 83       	std	Y+2, r25	; 0x02
    12d4:	89 83       	std	Y+1, r24	; 0x01
	}while(*(ptr_stringPointer_u8-1) !=0);
    12d6:	8b 81       	ldd	r24, Y+3	; 0x03
    12d8:	9c 81       	ldd	r25, Y+4	; 0x04
    12da:	01 97       	sbiw	r24, 0x01	; 1
    12dc:	fc 01       	movw	r30, r24
    12de:	80 81       	ld	r24, Z
    12e0:	88 23       	and	r24, r24
    12e2:	31 f7       	brne	.-52     	; 0x12b0 <EEPROM_WriteString+0x14>
}
    12e4:	0f 90       	pop	r0
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	0f 90       	pop	r0
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	08 95       	ret

000012f2 <EEPROM_ReadString>:
 * description:This function is used to Read a String from specified EEPROM_address.
           The string read from eeprom will be copied to specified buffer along with NULL character
 ***************************************************************************************************/
#if ( ENABLE_EEPROM_ReadString == 1)
void EEPROM_ReadString(uint16_t v_eepromAddress_u16, uint8_t *ptr_destStringAddress_u8)
{
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	00 d0       	rcall	.+0      	; 0x12f8 <EEPROM_ReadString+0x6>
    12f8:	00 d0       	rcall	.+0      	; 0x12fa <EEPROM_ReadString+0x8>
    12fa:	1f 92       	push	r1
    12fc:	cd b7       	in	r28, 0x3d	; 61
    12fe:	de b7       	in	r29, 0x3e	; 62
    1300:	9b 83       	std	Y+3, r25	; 0x03
    1302:	8a 83       	std	Y+2, r24	; 0x02
    1304:	7d 83       	std	Y+5, r23	; 0x05
    1306:	6c 83       	std	Y+4, r22	; 0x04
	char eeprom_data;

	do
	{
		eeprom_data = EEPROM_ReadByte(v_eepromAddress_u16); //Read a byte from EEPROM to RAM
    1308:	8a 81       	ldd	r24, Y+2	; 0x02
    130a:	9b 81       	ldd	r25, Y+3	; 0x03
    130c:	0e 94 23 09 	call	0x1246	; 0x1246 <EEPROM_ReadByte>
    1310:	89 83       	std	Y+1, r24	; 0x01
		*ptr_destStringAddress_u8 = eeprom_data;			 //Copy the data into String Buffer
    1312:	8c 81       	ldd	r24, Y+4	; 0x04
    1314:	9d 81       	ldd	r25, Y+5	; 0x05
    1316:	29 81       	ldd	r18, Y+1	; 0x01
    1318:	fc 01       	movw	r30, r24
    131a:	20 83       	st	Z, r18
		ptr_destStringAddress_u8++;						 //Increment the RAM Address
    131c:	8c 81       	ldd	r24, Y+4	; 0x04
    131e:	9d 81       	ldd	r25, Y+5	; 0x05
    1320:	01 96       	adiw	r24, 0x01	; 1
    1322:	9d 83       	std	Y+5, r25	; 0x05
    1324:	8c 83       	std	Y+4, r24	; 0x04
		v_eepromAddress_u16++;							 //Increment the Eeprom Address
    1326:	8a 81       	ldd	r24, Y+2	; 0x02
    1328:	9b 81       	ldd	r25, Y+3	; 0x03
    132a:	01 96       	adiw	r24, 0x01	; 1
    132c:	9b 83       	std	Y+3, r25	; 0x03
    132e:	8a 83       	std	Y+2, r24	; 0x02
	}while(eeprom_data!=0);
    1330:	89 81       	ldd	r24, Y+1	; 0x01
    1332:	88 23       	and	r24, r24
    1334:	49 f7       	brne	.-46     	; 0x1308 <EEPROM_ReadString+0x16>
}
    1336:	0f 90       	pop	r0
    1338:	0f 90       	pop	r0
    133a:	0f 90       	pop	r0
    133c:	0f 90       	pop	r0
    133e:	0f 90       	pop	r0
    1340:	df 91       	pop	r29
    1342:	cf 91       	pop	r28
    1344:	08 95       	ret

00001346 <GPIO_PinDirection>:
 * Return value    : none

 * description :This function sets the specified direction as INPUT/OUTPUT.  
 ***************************************************************************************************/
void GPIO_PinDirection(gpioPins_et enm_pinNumber, uint8_t v_pinDirn_u8)
{
    1346:	cf 93       	push	r28
    1348:	df 93       	push	r29
    134a:	00 d0       	rcall	.+0      	; 0x134c <GPIO_PinDirection+0x6>
    134c:	1f 92       	push	r1
    134e:	cd b7       	in	r28, 0x3d	; 61
    1350:	de b7       	in	r29, 0x3e	; 62
    1352:	8a 83       	std	Y+2, r24	; 0x02
    1354:	6b 83       	std	Y+3, r22	; 0x03

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    1356:	8a 81       	ldd	r24, Y+2	; 0x02
    1358:	86 95       	lsr	r24
    135a:	86 95       	lsr	r24
    135c:	86 95       	lsr	r24
    135e:	89 83       	std	Y+1, r24	; 0x01
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
    1360:	8a 81       	ldd	r24, Y+2	; 0x02
    1362:	87 70       	andi	r24, 0x07	; 7
    1364:	8a 83       	std	Y+2, r24	; 0x02

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	88 2f       	mov	r24, r24
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	81 30       	cpi	r24, 0x01	; 1
    136e:	91 05       	cpc	r25, r1
    1370:	09 f4       	brne	.+2      	; 0x1374 <GPIO_PinDirection+0x2e>
    1372:	3f c0       	rjmp	.+126    	; 0x13f2 <GPIO_PinDirection+0xac>
    1374:	82 30       	cpi	r24, 0x02	; 2
    1376:	91 05       	cpc	r25, r1
    1378:	1c f4       	brge	.+6      	; 0x1380 <GPIO_PinDirection+0x3a>
    137a:	00 97       	sbiw	r24, 0x00	; 0
    137c:	51 f0       	breq	.+20     	; 0x1392 <GPIO_PinDirection+0x4c>
    137e:	c9 c0       	rjmp	.+402    	; 0x1512 <GPIO_PinDirection+0x1cc>
    1380:	82 30       	cpi	r24, 0x02	; 2
    1382:	91 05       	cpc	r25, r1
    1384:	09 f4       	brne	.+2      	; 0x1388 <GPIO_PinDirection+0x42>
    1386:	65 c0       	rjmp	.+202    	; 0x1452 <GPIO_PinDirection+0x10c>
    1388:	83 30       	cpi	r24, 0x03	; 3
    138a:	91 05       	cpc	r25, r1
    138c:	09 f4       	brne	.+2      	; 0x1390 <GPIO_PinDirection+0x4a>
    138e:	91 c0       	rjmp	.+290    	; 0x14b2 <GPIO_PinDirection+0x16c>
    1390:	c0 c0       	rjmp	.+384    	; 0x1512 <GPIO_PinDirection+0x1cc>
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
    1392:	8b 81       	ldd	r24, Y+3	; 0x03
    1394:	88 23       	and	r24, r24
    1396:	b1 f0       	breq	.+44     	; 0x13c4 <GPIO_PinDirection+0x7e>
    1398:	8a e3       	ldi	r24, 0x3A	; 58
    139a:	90 e0       	ldi	r25, 0x00	; 0
    139c:	2a e3       	ldi	r18, 0x3A	; 58
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	f9 01       	movw	r30, r18
    13a2:	20 81       	ld	r18, Z
    13a4:	62 2f       	mov	r22, r18
    13a6:	2a 81       	ldd	r18, Y+2	; 0x02
    13a8:	42 2f       	mov	r20, r18
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	21 e0       	ldi	r18, 0x01	; 1
    13ae:	30 e0       	ldi	r19, 0x00	; 0
    13b0:	04 2e       	mov	r0, r20
    13b2:	02 c0       	rjmp	.+4      	; 0x13b8 <GPIO_PinDirection+0x72>
    13b4:	22 0f       	add	r18, r18
    13b6:	33 1f       	adc	r19, r19
    13b8:	0a 94       	dec	r0
    13ba:	e2 f7       	brpl	.-8      	; 0x13b4 <GPIO_PinDirection+0x6e>
    13bc:	26 2b       	or	r18, r22
    13be:	fc 01       	movw	r30, r24
    13c0:	20 83       	st	Z, r18
        break;
    13c2:	a7 c0       	rjmp	.+334    	; 0x1512 <GPIO_PinDirection+0x1cc>
        set the direction as specified*/
    switch(v_portNumber_u8)
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
    13c4:	8a e3       	ldi	r24, 0x3A	; 58
    13c6:	90 e0       	ldi	r25, 0x00	; 0
    13c8:	2a e3       	ldi	r18, 0x3A	; 58
    13ca:	30 e0       	ldi	r19, 0x00	; 0
    13cc:	f9 01       	movw	r30, r18
    13ce:	20 81       	ld	r18, Z
    13d0:	62 2f       	mov	r22, r18
    13d2:	2a 81       	ldd	r18, Y+2	; 0x02
    13d4:	42 2f       	mov	r20, r18
    13d6:	50 e0       	ldi	r21, 0x00	; 0
    13d8:	21 e0       	ldi	r18, 0x01	; 1
    13da:	30 e0       	ldi	r19, 0x00	; 0
    13dc:	04 2e       	mov	r0, r20
    13de:	02 c0       	rjmp	.+4      	; 0x13e4 <GPIO_PinDirection+0x9e>
    13e0:	22 0f       	add	r18, r18
    13e2:	33 1f       	adc	r19, r19
    13e4:	0a 94       	dec	r0
    13e6:	e2 f7       	brpl	.-8      	; 0x13e0 <GPIO_PinDirection+0x9a>
    13e8:	20 95       	com	r18
    13ea:	26 23       	and	r18, r22
    13ec:	fc 01       	movw	r30, r24
    13ee:	20 83       	st	Z, r18
        break;
    13f0:	90 c0       	rjmp	.+288    	; 0x1512 <GPIO_PinDirection+0x1cc>
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
    13f2:	8b 81       	ldd	r24, Y+3	; 0x03
    13f4:	88 23       	and	r24, r24
    13f6:	b1 f0       	breq	.+44     	; 0x1424 <GPIO_PinDirection+0xde>
    13f8:	87 e3       	ldi	r24, 0x37	; 55
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	27 e3       	ldi	r18, 0x37	; 55
    13fe:	30 e0       	ldi	r19, 0x00	; 0
    1400:	f9 01       	movw	r30, r18
    1402:	20 81       	ld	r18, Z
    1404:	62 2f       	mov	r22, r18
    1406:	2a 81       	ldd	r18, Y+2	; 0x02
    1408:	42 2f       	mov	r20, r18
    140a:	50 e0       	ldi	r21, 0x00	; 0
    140c:	21 e0       	ldi	r18, 0x01	; 1
    140e:	30 e0       	ldi	r19, 0x00	; 0
    1410:	04 2e       	mov	r0, r20
    1412:	02 c0       	rjmp	.+4      	; 0x1418 <GPIO_PinDirection+0xd2>
    1414:	22 0f       	add	r18, r18
    1416:	33 1f       	adc	r19, r19
    1418:	0a 94       	dec	r0
    141a:	e2 f7       	brpl	.-8      	; 0x1414 <GPIO_PinDirection+0xce>
    141c:	26 2b       	or	r18, r22
    141e:	fc 01       	movw	r30, r24
    1420:	20 83       	st	Z, r18
        break;
    1422:	77 c0       	rjmp	.+238    	; 0x1512 <GPIO_PinDirection+0x1cc>
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
    1424:	87 e3       	ldi	r24, 0x37	; 55
    1426:	90 e0       	ldi	r25, 0x00	; 0
    1428:	27 e3       	ldi	r18, 0x37	; 55
    142a:	30 e0       	ldi	r19, 0x00	; 0
    142c:	f9 01       	movw	r30, r18
    142e:	20 81       	ld	r18, Z
    1430:	62 2f       	mov	r22, r18
    1432:	2a 81       	ldd	r18, Y+2	; 0x02
    1434:	42 2f       	mov	r20, r18
    1436:	50 e0       	ldi	r21, 0x00	; 0
    1438:	21 e0       	ldi	r18, 0x01	; 1
    143a:	30 e0       	ldi	r19, 0x00	; 0
    143c:	04 2e       	mov	r0, r20
    143e:	02 c0       	rjmp	.+4      	; 0x1444 <GPIO_PinDirection+0xfe>
    1440:	22 0f       	add	r18, r18
    1442:	33 1f       	adc	r19, r19
    1444:	0a 94       	dec	r0
    1446:	e2 f7       	brpl	.-8      	; 0x1440 <GPIO_PinDirection+0xfa>
    1448:	20 95       	com	r18
    144a:	26 23       	and	r18, r22
    144c:	fc 01       	movw	r30, r24
    144e:	20 83       	st	Z, r18
        break;
    1450:	60 c0       	rjmp	.+192    	; 0x1512 <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
    1452:	8b 81       	ldd	r24, Y+3	; 0x03
    1454:	88 23       	and	r24, r24
    1456:	b1 f0       	breq	.+44     	; 0x1484 <GPIO_PinDirection+0x13e>
    1458:	84 e3       	ldi	r24, 0x34	; 52
    145a:	90 e0       	ldi	r25, 0x00	; 0
    145c:	24 e3       	ldi	r18, 0x34	; 52
    145e:	30 e0       	ldi	r19, 0x00	; 0
    1460:	f9 01       	movw	r30, r18
    1462:	20 81       	ld	r18, Z
    1464:	62 2f       	mov	r22, r18
    1466:	2a 81       	ldd	r18, Y+2	; 0x02
    1468:	42 2f       	mov	r20, r18
    146a:	50 e0       	ldi	r21, 0x00	; 0
    146c:	21 e0       	ldi	r18, 0x01	; 1
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	04 2e       	mov	r0, r20
    1472:	02 c0       	rjmp	.+4      	; 0x1478 <GPIO_PinDirection+0x132>
    1474:	22 0f       	add	r18, r18
    1476:	33 1f       	adc	r19, r19
    1478:	0a 94       	dec	r0
    147a:	e2 f7       	brpl	.-8      	; 0x1474 <GPIO_PinDirection+0x12e>
    147c:	26 2b       	or	r18, r22
    147e:	fc 01       	movw	r30, r24
    1480:	20 83       	st	Z, r18
        break;
    1482:	47 c0       	rjmp	.+142    	; 0x1512 <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
    1484:	84 e3       	ldi	r24, 0x34	; 52
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	24 e3       	ldi	r18, 0x34	; 52
    148a:	30 e0       	ldi	r19, 0x00	; 0
    148c:	f9 01       	movw	r30, r18
    148e:	20 81       	ld	r18, Z
    1490:	62 2f       	mov	r22, r18
    1492:	2a 81       	ldd	r18, Y+2	; 0x02
    1494:	42 2f       	mov	r20, r18
    1496:	50 e0       	ldi	r21, 0x00	; 0
    1498:	21 e0       	ldi	r18, 0x01	; 1
    149a:	30 e0       	ldi	r19, 0x00	; 0
    149c:	04 2e       	mov	r0, r20
    149e:	02 c0       	rjmp	.+4      	; 0x14a4 <GPIO_PinDirection+0x15e>
    14a0:	22 0f       	add	r18, r18
    14a2:	33 1f       	adc	r19, r19
    14a4:	0a 94       	dec	r0
    14a6:	e2 f7       	brpl	.-8      	; 0x14a0 <GPIO_PinDirection+0x15a>
    14a8:	20 95       	com	r18
    14aa:	26 23       	and	r18, r22
    14ac:	fc 01       	movw	r30, r24
    14ae:	20 83       	st	Z, r18
        break;
    14b0:	30 c0       	rjmp	.+96     	; 0x1512 <GPIO_PinDirection+0x1cc>
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
    14b2:	8b 81       	ldd	r24, Y+3	; 0x03
    14b4:	88 23       	and	r24, r24
    14b6:	b1 f0       	breq	.+44     	; 0x14e4 <GPIO_PinDirection+0x19e>
    14b8:	81 e3       	ldi	r24, 0x31	; 49
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	21 e3       	ldi	r18, 0x31	; 49
    14be:	30 e0       	ldi	r19, 0x00	; 0
    14c0:	f9 01       	movw	r30, r18
    14c2:	20 81       	ld	r18, Z
    14c4:	62 2f       	mov	r22, r18
    14c6:	2a 81       	ldd	r18, Y+2	; 0x02
    14c8:	42 2f       	mov	r20, r18
    14ca:	50 e0       	ldi	r21, 0x00	; 0
    14cc:	21 e0       	ldi	r18, 0x01	; 1
    14ce:	30 e0       	ldi	r19, 0x00	; 0
    14d0:	04 2e       	mov	r0, r20
    14d2:	02 c0       	rjmp	.+4      	; 0x14d8 <GPIO_PinDirection+0x192>
    14d4:	22 0f       	add	r18, r18
    14d6:	33 1f       	adc	r19, r19
    14d8:	0a 94       	dec	r0
    14da:	e2 f7       	brpl	.-8      	; 0x14d4 <GPIO_PinDirection+0x18e>
    14dc:	26 2b       	or	r18, r22
    14de:	fc 01       	movw	r30, r24
    14e0:	20 83       	st	Z, r18
    14e2:	16 c0       	rjmp	.+44     	; 0x1510 <GPIO_PinDirection+0x1ca>
    14e4:	81 e3       	ldi	r24, 0x31	; 49
    14e6:	90 e0       	ldi	r25, 0x00	; 0
    14e8:	21 e3       	ldi	r18, 0x31	; 49
    14ea:	30 e0       	ldi	r19, 0x00	; 0
    14ec:	f9 01       	movw	r30, r18
    14ee:	20 81       	ld	r18, Z
    14f0:	62 2f       	mov	r22, r18
    14f2:	2a 81       	ldd	r18, Y+2	; 0x02
    14f4:	42 2f       	mov	r20, r18
    14f6:	50 e0       	ldi	r21, 0x00	; 0
    14f8:	21 e0       	ldi	r18, 0x01	; 1
    14fa:	30 e0       	ldi	r19, 0x00	; 0
    14fc:	04 2e       	mov	r0, r20
    14fe:	02 c0       	rjmp	.+4      	; 0x1504 <GPIO_PinDirection+0x1be>
    1500:	22 0f       	add	r18, r18
    1502:	33 1f       	adc	r19, r19
    1504:	0a 94       	dec	r0
    1506:	e2 f7       	brpl	.-8      	; 0x1500 <GPIO_PinDirection+0x1ba>
    1508:	20 95       	com	r18
    150a:	26 23       	and	r18, r22
    150c:	fc 01       	movw	r30, r24
    150e:	20 83       	st	Z, r18
        break;
    1510:	00 00       	nop
    case 6:
        util_UpdateBit(DDRG,enm_pinNumber,v_pinDirn_u8);
        break;
#endif    
    }                
}
    1512:	0f 90       	pop	r0
    1514:	0f 90       	pop	r0
    1516:	0f 90       	pop	r0
    1518:	df 91       	pop	r29
    151a:	cf 91       	pop	r28
    151c:	08 95       	ret

0000151e <GPIO_PinWrite>:
 * description :This function updates the specified value on the selected pin.  
                Before updating the pins status, the pin function should be selected and then
                the pin should be configured as OUTPUT 
***************************************************************************************************/
void GPIO_PinWrite(gpioPins_et enm_pinNumber, uint8_t v_pinValue_u8)
{
    151e:	cf 93       	push	r28
    1520:	df 93       	push	r29
    1522:	00 d0       	rcall	.+0      	; 0x1524 <GPIO_PinWrite+0x6>
    1524:	1f 92       	push	r1
    1526:	cd b7       	in	r28, 0x3d	; 61
    1528:	de b7       	in	r29, 0x3e	; 62
    152a:	8a 83       	std	Y+2, r24	; 0x02
    152c:	6b 83       	std	Y+3, r22	; 0x03

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    152e:	8a 81       	ldd	r24, Y+2	; 0x02
    1530:	86 95       	lsr	r24
    1532:	86 95       	lsr	r24
    1534:	86 95       	lsr	r24
    1536:	89 83       	std	Y+1, r24	; 0x01
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
    1538:	8a 81       	ldd	r24, Y+2	; 0x02
    153a:	87 70       	andi	r24, 0x07	; 7
    153c:	8a 83       	std	Y+2, r24	; 0x02

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	88 2f       	mov	r24, r24
    1542:	90 e0       	ldi	r25, 0x00	; 0
    1544:	81 30       	cpi	r24, 0x01	; 1
    1546:	91 05       	cpc	r25, r1
    1548:	09 f4       	brne	.+2      	; 0x154c <GPIO_PinWrite+0x2e>
    154a:	3f c0       	rjmp	.+126    	; 0x15ca <GPIO_PinWrite+0xac>
    154c:	82 30       	cpi	r24, 0x02	; 2
    154e:	91 05       	cpc	r25, r1
    1550:	1c f4       	brge	.+6      	; 0x1558 <GPIO_PinWrite+0x3a>
    1552:	00 97       	sbiw	r24, 0x00	; 0
    1554:	51 f0       	breq	.+20     	; 0x156a <GPIO_PinWrite+0x4c>
    1556:	c9 c0       	rjmp	.+402    	; 0x16ea <GPIO_PinWrite+0x1cc>
    1558:	82 30       	cpi	r24, 0x02	; 2
    155a:	91 05       	cpc	r25, r1
    155c:	09 f4       	brne	.+2      	; 0x1560 <GPIO_PinWrite+0x42>
    155e:	65 c0       	rjmp	.+202    	; 0x162a <GPIO_PinWrite+0x10c>
    1560:	83 30       	cpi	r24, 0x03	; 3
    1562:	91 05       	cpc	r25, r1
    1564:	09 f4       	brne	.+2      	; 0x1568 <GPIO_PinWrite+0x4a>
    1566:	91 c0       	rjmp	.+290    	; 0x168a <GPIO_PinWrite+0x16c>
    1568:	c0 c0       	rjmp	.+384    	; 0x16ea <GPIO_PinWrite+0x1cc>
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
    156a:	8b 81       	ldd	r24, Y+3	; 0x03
    156c:	88 23       	and	r24, r24
    156e:	b1 f0       	breq	.+44     	; 0x159c <GPIO_PinWrite+0x7e>
    1570:	8b e3       	ldi	r24, 0x3B	; 59
    1572:	90 e0       	ldi	r25, 0x00	; 0
    1574:	2b e3       	ldi	r18, 0x3B	; 59
    1576:	30 e0       	ldi	r19, 0x00	; 0
    1578:	f9 01       	movw	r30, r18
    157a:	20 81       	ld	r18, Z
    157c:	62 2f       	mov	r22, r18
    157e:	2a 81       	ldd	r18, Y+2	; 0x02
    1580:	42 2f       	mov	r20, r18
    1582:	50 e0       	ldi	r21, 0x00	; 0
    1584:	21 e0       	ldi	r18, 0x01	; 1
    1586:	30 e0       	ldi	r19, 0x00	; 0
    1588:	04 2e       	mov	r0, r20
    158a:	02 c0       	rjmp	.+4      	; 0x1590 <GPIO_PinWrite+0x72>
    158c:	22 0f       	add	r18, r18
    158e:	33 1f       	adc	r19, r19
    1590:	0a 94       	dec	r0
    1592:	e2 f7       	brpl	.-8      	; 0x158c <GPIO_PinWrite+0x6e>
    1594:	26 2b       	or	r18, r22
    1596:	fc 01       	movw	r30, r24
    1598:	20 83       	st	Z, r18
        break;
    159a:	a7 c0       	rjmp	.+334    	; 0x16ea <GPIO_PinWrite+0x1cc>
        update the value of the specified pin*/
    switch(v_portNumber_u8)
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
    159c:	8b e3       	ldi	r24, 0x3B	; 59
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	2b e3       	ldi	r18, 0x3B	; 59
    15a2:	30 e0       	ldi	r19, 0x00	; 0
    15a4:	f9 01       	movw	r30, r18
    15a6:	20 81       	ld	r18, Z
    15a8:	62 2f       	mov	r22, r18
    15aa:	2a 81       	ldd	r18, Y+2	; 0x02
    15ac:	42 2f       	mov	r20, r18
    15ae:	50 e0       	ldi	r21, 0x00	; 0
    15b0:	21 e0       	ldi	r18, 0x01	; 1
    15b2:	30 e0       	ldi	r19, 0x00	; 0
    15b4:	04 2e       	mov	r0, r20
    15b6:	02 c0       	rjmp	.+4      	; 0x15bc <GPIO_PinWrite+0x9e>
    15b8:	22 0f       	add	r18, r18
    15ba:	33 1f       	adc	r19, r19
    15bc:	0a 94       	dec	r0
    15be:	e2 f7       	brpl	.-8      	; 0x15b8 <GPIO_PinWrite+0x9a>
    15c0:	20 95       	com	r18
    15c2:	26 23       	and	r18, r22
    15c4:	fc 01       	movw	r30, r24
    15c6:	20 83       	st	Z, r18
        break;
    15c8:	90 c0       	rjmp	.+288    	; 0x16ea <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
    15ca:	8b 81       	ldd	r24, Y+3	; 0x03
    15cc:	88 23       	and	r24, r24
    15ce:	b1 f0       	breq	.+44     	; 0x15fc <GPIO_PinWrite+0xde>
    15d0:	88 e3       	ldi	r24, 0x38	; 56
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	28 e3       	ldi	r18, 0x38	; 56
    15d6:	30 e0       	ldi	r19, 0x00	; 0
    15d8:	f9 01       	movw	r30, r18
    15da:	20 81       	ld	r18, Z
    15dc:	62 2f       	mov	r22, r18
    15de:	2a 81       	ldd	r18, Y+2	; 0x02
    15e0:	42 2f       	mov	r20, r18
    15e2:	50 e0       	ldi	r21, 0x00	; 0
    15e4:	21 e0       	ldi	r18, 0x01	; 1
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	04 2e       	mov	r0, r20
    15ea:	02 c0       	rjmp	.+4      	; 0x15f0 <GPIO_PinWrite+0xd2>
    15ec:	22 0f       	add	r18, r18
    15ee:	33 1f       	adc	r19, r19
    15f0:	0a 94       	dec	r0
    15f2:	e2 f7       	brpl	.-8      	; 0x15ec <GPIO_PinWrite+0xce>
    15f4:	26 2b       	or	r18, r22
    15f6:	fc 01       	movw	r30, r24
    15f8:	20 83       	st	Z, r18
        break;
    15fa:	77 c0       	rjmp	.+238    	; 0x16ea <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
    15fc:	88 e3       	ldi	r24, 0x38	; 56
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	28 e3       	ldi	r18, 0x38	; 56
    1602:	30 e0       	ldi	r19, 0x00	; 0
    1604:	f9 01       	movw	r30, r18
    1606:	20 81       	ld	r18, Z
    1608:	62 2f       	mov	r22, r18
    160a:	2a 81       	ldd	r18, Y+2	; 0x02
    160c:	42 2f       	mov	r20, r18
    160e:	50 e0       	ldi	r21, 0x00	; 0
    1610:	21 e0       	ldi	r18, 0x01	; 1
    1612:	30 e0       	ldi	r19, 0x00	; 0
    1614:	04 2e       	mov	r0, r20
    1616:	02 c0       	rjmp	.+4      	; 0x161c <GPIO_PinWrite+0xfe>
    1618:	22 0f       	add	r18, r18
    161a:	33 1f       	adc	r19, r19
    161c:	0a 94       	dec	r0
    161e:	e2 f7       	brpl	.-8      	; 0x1618 <GPIO_PinWrite+0xfa>
    1620:	20 95       	com	r18
    1622:	26 23       	and	r18, r22
    1624:	fc 01       	movw	r30, r24
    1626:	20 83       	st	Z, r18
        break;
    1628:	60 c0       	rjmp	.+192    	; 0x16ea <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
    162a:	8b 81       	ldd	r24, Y+3	; 0x03
    162c:	88 23       	and	r24, r24
    162e:	b1 f0       	breq	.+44     	; 0x165c <GPIO_PinWrite+0x13e>
    1630:	85 e3       	ldi	r24, 0x35	; 53
    1632:	90 e0       	ldi	r25, 0x00	; 0
    1634:	25 e3       	ldi	r18, 0x35	; 53
    1636:	30 e0       	ldi	r19, 0x00	; 0
    1638:	f9 01       	movw	r30, r18
    163a:	20 81       	ld	r18, Z
    163c:	62 2f       	mov	r22, r18
    163e:	2a 81       	ldd	r18, Y+2	; 0x02
    1640:	42 2f       	mov	r20, r18
    1642:	50 e0       	ldi	r21, 0x00	; 0
    1644:	21 e0       	ldi	r18, 0x01	; 1
    1646:	30 e0       	ldi	r19, 0x00	; 0
    1648:	04 2e       	mov	r0, r20
    164a:	02 c0       	rjmp	.+4      	; 0x1650 <GPIO_PinWrite+0x132>
    164c:	22 0f       	add	r18, r18
    164e:	33 1f       	adc	r19, r19
    1650:	0a 94       	dec	r0
    1652:	e2 f7       	brpl	.-8      	; 0x164c <GPIO_PinWrite+0x12e>
    1654:	26 2b       	or	r18, r22
    1656:	fc 01       	movw	r30, r24
    1658:	20 83       	st	Z, r18
        break;
    165a:	47 c0       	rjmp	.+142    	; 0x16ea <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
    165c:	85 e3       	ldi	r24, 0x35	; 53
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	25 e3       	ldi	r18, 0x35	; 53
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	f9 01       	movw	r30, r18
    1666:	20 81       	ld	r18, Z
    1668:	62 2f       	mov	r22, r18
    166a:	2a 81       	ldd	r18, Y+2	; 0x02
    166c:	42 2f       	mov	r20, r18
    166e:	50 e0       	ldi	r21, 0x00	; 0
    1670:	21 e0       	ldi	r18, 0x01	; 1
    1672:	30 e0       	ldi	r19, 0x00	; 0
    1674:	04 2e       	mov	r0, r20
    1676:	02 c0       	rjmp	.+4      	; 0x167c <GPIO_PinWrite+0x15e>
    1678:	22 0f       	add	r18, r18
    167a:	33 1f       	adc	r19, r19
    167c:	0a 94       	dec	r0
    167e:	e2 f7       	brpl	.-8      	; 0x1678 <GPIO_PinWrite+0x15a>
    1680:	20 95       	com	r18
    1682:	26 23       	and	r18, r22
    1684:	fc 01       	movw	r30, r24
    1686:	20 83       	st	Z, r18
        break;
    1688:	30 c0       	rjmp	.+96     	; 0x16ea <GPIO_PinWrite+0x1cc>
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
    168a:	8b 81       	ldd	r24, Y+3	; 0x03
    168c:	88 23       	and	r24, r24
    168e:	b1 f0       	breq	.+44     	; 0x16bc <GPIO_PinWrite+0x19e>
    1690:	82 e3       	ldi	r24, 0x32	; 50
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	22 e3       	ldi	r18, 0x32	; 50
    1696:	30 e0       	ldi	r19, 0x00	; 0
    1698:	f9 01       	movw	r30, r18
    169a:	20 81       	ld	r18, Z
    169c:	62 2f       	mov	r22, r18
    169e:	2a 81       	ldd	r18, Y+2	; 0x02
    16a0:	42 2f       	mov	r20, r18
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	21 e0       	ldi	r18, 0x01	; 1
    16a6:	30 e0       	ldi	r19, 0x00	; 0
    16a8:	04 2e       	mov	r0, r20
    16aa:	02 c0       	rjmp	.+4      	; 0x16b0 <GPIO_PinWrite+0x192>
    16ac:	22 0f       	add	r18, r18
    16ae:	33 1f       	adc	r19, r19
    16b0:	0a 94       	dec	r0
    16b2:	e2 f7       	brpl	.-8      	; 0x16ac <GPIO_PinWrite+0x18e>
    16b4:	26 2b       	or	r18, r22
    16b6:	fc 01       	movw	r30, r24
    16b8:	20 83       	st	Z, r18
    16ba:	16 c0       	rjmp	.+44     	; 0x16e8 <GPIO_PinWrite+0x1ca>
    16bc:	82 e3       	ldi	r24, 0x32	; 50
    16be:	90 e0       	ldi	r25, 0x00	; 0
    16c0:	22 e3       	ldi	r18, 0x32	; 50
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	f9 01       	movw	r30, r18
    16c6:	20 81       	ld	r18, Z
    16c8:	62 2f       	mov	r22, r18
    16ca:	2a 81       	ldd	r18, Y+2	; 0x02
    16cc:	42 2f       	mov	r20, r18
    16ce:	50 e0       	ldi	r21, 0x00	; 0
    16d0:	21 e0       	ldi	r18, 0x01	; 1
    16d2:	30 e0       	ldi	r19, 0x00	; 0
    16d4:	04 2e       	mov	r0, r20
    16d6:	02 c0       	rjmp	.+4      	; 0x16dc <GPIO_PinWrite+0x1be>
    16d8:	22 0f       	add	r18, r18
    16da:	33 1f       	adc	r19, r19
    16dc:	0a 94       	dec	r0
    16de:	e2 f7       	brpl	.-8      	; 0x16d8 <GPIO_PinWrite+0x1ba>
    16e0:	20 95       	com	r18
    16e2:	26 23       	and	r18, r22
    16e4:	fc 01       	movw	r30, r24
    16e6:	20 83       	st	Z, r18
        break;
    16e8:	00 00       	nop
    case 6:
        util_UpdateBit(PORTG,enm_pinNumber,v_pinValue_u8);
        break;
#endif      
    }                
}
    16ea:	0f 90       	pop	r0
    16ec:	0f 90       	pop	r0
    16ee:	0f 90       	pop	r0
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
    16f4:	08 95       	ret

000016f6 <GPIO_PinRead>:

 * description :This function returns the status of the selected pin.
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    16f6:	cf 93       	push	r28
    16f8:	df 93       	push	r29
    16fa:	00 d0       	rcall	.+0      	; 0x16fc <GPIO_PinRead+0x6>
    16fc:	1f 92       	push	r1
    16fe:	cd b7       	in	r28, 0x3d	; 61
    1700:	de b7       	in	r29, 0x3e	; 62
    1702:	8b 83       	std	Y+3, r24	; 0x03
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
    1704:	19 82       	std	Y+1, r1	; 0x01

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    1706:	8b 81       	ldd	r24, Y+3	; 0x03
    1708:	86 95       	lsr	r24
    170a:	86 95       	lsr	r24
    170c:	86 95       	lsr	r24
    170e:	8a 83       	std	Y+2, r24	; 0x02
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
    1710:	8b 81       	ldd	r24, Y+3	; 0x03
    1712:	87 70       	andi	r24, 0x07	; 7
    1714:	8b 83       	std	Y+3, r24	; 0x03

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    1716:	8a 81       	ldd	r24, Y+2	; 0x02
    1718:	88 2f       	mov	r24, r24
    171a:	90 e0       	ldi	r25, 0x00	; 0
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	91 05       	cpc	r25, r1
    1720:	21 f1       	breq	.+72     	; 0x176a <GPIO_PinRead+0x74>
    1722:	82 30       	cpi	r24, 0x02	; 2
    1724:	91 05       	cpc	r25, r1
    1726:	1c f4       	brge	.+6      	; 0x172e <GPIO_PinRead+0x38>
    1728:	00 97       	sbiw	r24, 0x00	; 0
    172a:	49 f0       	breq	.+18     	; 0x173e <GPIO_PinRead+0x48>
    172c:	60 c0       	rjmp	.+192    	; 0x17ee <GPIO_PinRead+0xf8>
    172e:	82 30       	cpi	r24, 0x02	; 2
    1730:	91 05       	cpc	r25, r1
    1732:	89 f1       	breq	.+98     	; 0x1796 <GPIO_PinRead+0xa0>
    1734:	83 30       	cpi	r24, 0x03	; 3
    1736:	91 05       	cpc	r25, r1
    1738:	09 f4       	brne	.+2      	; 0x173c <GPIO_PinRead+0x46>
    173a:	43 c0       	rjmp	.+134    	; 0x17c2 <GPIO_PinRead+0xcc>
    173c:	58 c0       	rjmp	.+176    	; 0x17ee <GPIO_PinRead+0xf8>
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
    173e:	89 e3       	ldi	r24, 0x39	; 57
    1740:	90 e0       	ldi	r25, 0x00	; 0
    1742:	fc 01       	movw	r30, r24
    1744:	80 81       	ld	r24, Z
    1746:	88 2f       	mov	r24, r24
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	2b 81       	ldd	r18, Y+3	; 0x03
    174c:	22 2f       	mov	r18, r18
    174e:	30 e0       	ldi	r19, 0x00	; 0
    1750:	02 c0       	rjmp	.+4      	; 0x1756 <GPIO_PinRead+0x60>
    1752:	95 95       	asr	r25
    1754:	87 95       	ror	r24
    1756:	2a 95       	dec	r18
    1758:	e2 f7       	brpl	.-8      	; 0x1752 <GPIO_PinRead+0x5c>
    175a:	81 70       	andi	r24, 0x01	; 1
    175c:	99 27       	eor	r25, r25
    175e:	21 e0       	ldi	r18, 0x01	; 1
    1760:	00 97       	sbiw	r24, 0x00	; 0
    1762:	09 f4       	brne	.+2      	; 0x1766 <GPIO_PinRead+0x70>
    1764:	20 e0       	ldi	r18, 0x00	; 0
    1766:	29 83       	std	Y+1, r18	; 0x01
        break;
    1768:	42 c0       	rjmp	.+132    	; 0x17ee <GPIO_PinRead+0xf8>
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
    176a:	86 e3       	ldi	r24, 0x36	; 54
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	fc 01       	movw	r30, r24
    1770:	80 81       	ld	r24, Z
    1772:	88 2f       	mov	r24, r24
    1774:	90 e0       	ldi	r25, 0x00	; 0
    1776:	2b 81       	ldd	r18, Y+3	; 0x03
    1778:	22 2f       	mov	r18, r18
    177a:	30 e0       	ldi	r19, 0x00	; 0
    177c:	02 c0       	rjmp	.+4      	; 0x1782 <GPIO_PinRead+0x8c>
    177e:	95 95       	asr	r25
    1780:	87 95       	ror	r24
    1782:	2a 95       	dec	r18
    1784:	e2 f7       	brpl	.-8      	; 0x177e <GPIO_PinRead+0x88>
    1786:	81 70       	andi	r24, 0x01	; 1
    1788:	99 27       	eor	r25, r25
    178a:	21 e0       	ldi	r18, 0x01	; 1
    178c:	00 97       	sbiw	r24, 0x00	; 0
    178e:	09 f4       	brne	.+2      	; 0x1792 <GPIO_PinRead+0x9c>
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	29 83       	std	Y+1, r18	; 0x01
        break;
    1794:	2c c0       	rjmp	.+88     	; 0x17ee <GPIO_PinRead+0xf8>
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
    1796:	83 e3       	ldi	r24, 0x33	; 51
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	fc 01       	movw	r30, r24
    179c:	80 81       	ld	r24, Z
    179e:	88 2f       	mov	r24, r24
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	2b 81       	ldd	r18, Y+3	; 0x03
    17a4:	22 2f       	mov	r18, r18
    17a6:	30 e0       	ldi	r19, 0x00	; 0
    17a8:	02 c0       	rjmp	.+4      	; 0x17ae <GPIO_PinRead+0xb8>
    17aa:	95 95       	asr	r25
    17ac:	87 95       	ror	r24
    17ae:	2a 95       	dec	r18
    17b0:	e2 f7       	brpl	.-8      	; 0x17aa <GPIO_PinRead+0xb4>
    17b2:	81 70       	andi	r24, 0x01	; 1
    17b4:	99 27       	eor	r25, r25
    17b6:	21 e0       	ldi	r18, 0x01	; 1
    17b8:	00 97       	sbiw	r24, 0x00	; 0
    17ba:	09 f4       	brne	.+2      	; 0x17be <GPIO_PinRead+0xc8>
    17bc:	20 e0       	ldi	r18, 0x00	; 0
    17be:	29 83       	std	Y+1, r18	; 0x01
        break;
    17c0:	16 c0       	rjmp	.+44     	; 0x17ee <GPIO_PinRead+0xf8>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
    17c2:	80 e3       	ldi	r24, 0x30	; 48
    17c4:	90 e0       	ldi	r25, 0x00	; 0
    17c6:	fc 01       	movw	r30, r24
    17c8:	80 81       	ld	r24, Z
    17ca:	88 2f       	mov	r24, r24
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	2b 81       	ldd	r18, Y+3	; 0x03
    17d0:	22 2f       	mov	r18, r18
    17d2:	30 e0       	ldi	r19, 0x00	; 0
    17d4:	02 c0       	rjmp	.+4      	; 0x17da <GPIO_PinRead+0xe4>
    17d6:	95 95       	asr	r25
    17d8:	87 95       	ror	r24
    17da:	2a 95       	dec	r18
    17dc:	e2 f7       	brpl	.-8      	; 0x17d6 <GPIO_PinRead+0xe0>
    17de:	81 70       	andi	r24, 0x01	; 1
    17e0:	99 27       	eor	r25, r25
    17e2:	21 e0       	ldi	r18, 0x01	; 1
    17e4:	00 97       	sbiw	r24, 0x00	; 0
    17e6:	09 f4       	brne	.+2      	; 0x17ea <GPIO_PinRead+0xf4>
    17e8:	20 e0       	ldi	r18, 0x00	; 0
    17ea:	29 83       	std	Y+1, r18	; 0x01
        break;
    17ec:	00 00       	nop
    case 6:
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
    17ee:	89 81       	ldd	r24, Y+1	; 0x01
}
    17f0:	0f 90       	pop	r0
    17f2:	0f 90       	pop	r0
    17f4:	0f 90       	pop	r0
    17f6:	df 91       	pop	r29
    17f8:	cf 91       	pop	r28
    17fa:	08 95       	ret

000017fc <LCD_SetUp>:
 In case of four bit mode pass P_NC as parameter for D0-D3.
 If RW is not used then pass P_NC as parameter for RS.
 **************************************************************************************************/
void LCD_SetUp(gpioPins_et RS, gpioPins_et RW, gpioPins_et EN, gpioPins_et D0,
		gpioPins_et D1, gpioPins_et D2, gpioPins_et D3, gpioPins_et D4,
		gpioPins_et D5, gpioPins_et D6, gpioPins_et D7) {
    17fc:	8f 92       	push	r8
    17fe:	af 92       	push	r10
    1800:	cf 92       	push	r12
    1802:	ef 92       	push	r14
    1804:	0f 93       	push	r16
    1806:	cf 93       	push	r28
    1808:	df 93       	push	r29
    180a:	cd b7       	in	r28, 0x3d	; 61
    180c:	de b7       	in	r29, 0x3e	; 62
    180e:	29 97       	sbiw	r28, 0x09	; 9
    1810:	0f b6       	in	r0, 0x3f	; 63
    1812:	f8 94       	cli
    1814:	de bf       	out	0x3e, r29	; 62
    1816:	0f be       	out	0x3f, r0	; 63
    1818:	cd bf       	out	0x3d, r28	; 61
    181a:	89 83       	std	Y+1, r24	; 0x01
    181c:	6a 83       	std	Y+2, r22	; 0x02
    181e:	4b 83       	std	Y+3, r20	; 0x03
    1820:	2c 83       	std	Y+4, r18	; 0x04
    1822:	0d 83       	std	Y+5, r16	; 0x05
    1824:	ee 82       	std	Y+6, r14	; 0x06
    1826:	cf 82       	std	Y+7, r12	; 0x07
    1828:	a8 86       	std	Y+8, r10	; 0x08
    182a:	89 86       	std	Y+9, r8	; 0x09
	/* Copy the PIN numbers where the LCD is connected */
	LCDConfig.RS = RS;
    182c:	89 81       	ldd	r24, Y+1	; 0x01
    182e:	80 93 1f 01 	sts	0x011F, r24
	LCDConfig.RW = RW;
    1832:	8a 81       	ldd	r24, Y+2	; 0x02
    1834:	80 93 20 01 	sts	0x0120, r24
	LCDConfig.EN = EN;
    1838:	8b 81       	ldd	r24, Y+3	; 0x03
    183a:	80 93 21 01 	sts	0x0121, r24

	LCDConfig.D0 = D0;
    183e:	8c 81       	ldd	r24, Y+4	; 0x04
    1840:	80 93 22 01 	sts	0x0122, r24
	LCDConfig.D1 = D1;
    1844:	8d 81       	ldd	r24, Y+5	; 0x05
    1846:	80 93 23 01 	sts	0x0123, r24
	LCDConfig.D2 = D2;
    184a:	8e 81       	ldd	r24, Y+6	; 0x06
    184c:	80 93 24 01 	sts	0x0124, r24
	LCDConfig.D3 = D3;
    1850:	8f 81       	ldd	r24, Y+7	; 0x07
    1852:	80 93 25 01 	sts	0x0125, r24
	LCDConfig.D4 = D4;
    1856:	88 85       	ldd	r24, Y+8	; 0x08
    1858:	80 93 26 01 	sts	0x0126, r24
	LCDConfig.D5 = D5;
    185c:	89 85       	ldd	r24, Y+9	; 0x09
    185e:	80 93 27 01 	sts	0x0127, r24
	LCDConfig.D6 = D6;
    1862:	8b 89       	ldd	r24, Y+19	; 0x13
    1864:	80 93 28 01 	sts	0x0128, r24
	LCDConfig.D7 = D7;
    1868:	8c 89       	ldd	r24, Y+20	; 0x14
    186a:	80 93 29 01 	sts	0x0129, r24

	if ((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC)) {
    186e:	8c 81       	ldd	r24, Y+4	; 0x04
    1870:	8f 3f       	cpi	r24, 0xFF	; 255
    1872:	49 f0       	breq	.+18     	; 0x1886 <LCD_SetUp+0x8a>
    1874:	8d 81       	ldd	r24, Y+5	; 0x05
    1876:	8f 3f       	cpi	r24, 0xFF	; 255
    1878:	31 f0       	breq	.+12     	; 0x1886 <LCD_SetUp+0x8a>
    187a:	8e 81       	ldd	r24, Y+6	; 0x06
    187c:	8f 3f       	cpi	r24, 0xFF	; 255
    187e:	19 f0       	breq	.+6      	; 0x1886 <LCD_SetUp+0x8a>
    1880:	8f 81       	ldd	r24, Y+7	; 0x07
    1882:	8f 3f       	cpi	r24, 0xFF	; 255
    1884:	21 f4       	brne	.+8      	; 0x188e <LCD_SetUp+0x92>
		LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
    1886:	84 e0       	ldi	r24, 0x04	; 4
    1888:	80 93 1e 01 	sts	0x011E, r24
    188c:	13 c0       	rjmp	.+38     	; 0x18b4 <LCD_SetUp+0xb8>
	} else {
		LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.
    188e:	88 e0       	ldi	r24, 0x08	; 8
    1890:	80 93 1e 01 	sts	0x011E, r24
		GPIO_PinDirection(D0, OUTPUT);
    1894:	61 e0       	ldi	r22, 0x01	; 1
    1896:	8c 81       	ldd	r24, Y+4	; 0x04
    1898:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
		GPIO_PinDirection(D1, OUTPUT);
    189c:	61 e0       	ldi	r22, 0x01	; 1
    189e:	8d 81       	ldd	r24, Y+5	; 0x05
    18a0:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
		GPIO_PinDirection(D2, OUTPUT);
    18a4:	61 e0       	ldi	r22, 0x01	; 1
    18a6:	8e 81       	ldd	r24, Y+6	; 0x06
    18a8:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
		GPIO_PinDirection(D3, OUTPUT);
    18ac:	61 e0       	ldi	r22, 0x01	; 1
    18ae:	8f 81       	ldd	r24, Y+7	; 0x07
    18b0:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
	}

	/* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
	GPIO_PinDirection(RS, OUTPUT);
    18b4:	61 e0       	ldi	r22, 0x01	; 1
    18b6:	89 81       	ldd	r24, Y+1	; 0x01
    18b8:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
	GPIO_PinDirection(RW, OUTPUT);
    18bc:	61 e0       	ldi	r22, 0x01	; 1
    18be:	8a 81       	ldd	r24, Y+2	; 0x02
    18c0:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
	GPIO_PinDirection(EN, OUTPUT);
    18c4:	61 e0       	ldi	r22, 0x01	; 1
    18c6:	8b 81       	ldd	r24, Y+3	; 0x03
    18c8:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>

	GPIO_PinDirection(D4, OUTPUT);
    18cc:	61 e0       	ldi	r22, 0x01	; 1
    18ce:	88 85       	ldd	r24, Y+8	; 0x08
    18d0:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
	GPIO_PinDirection(D5, OUTPUT);
    18d4:	61 e0       	ldi	r22, 0x01	; 1
    18d6:	89 85       	ldd	r24, Y+9	; 0x09
    18d8:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
	GPIO_PinDirection(D6, OUTPUT);
    18dc:	61 e0       	ldi	r22, 0x01	; 1
    18de:	8b 89       	ldd	r24, Y+19	; 0x13
    18e0:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
	GPIO_PinDirection(D7, OUTPUT);
    18e4:	61 e0       	ldi	r22, 0x01	; 1
    18e6:	8c 89       	ldd	r24, Y+20	; 0x14
    18e8:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
}
    18ec:	29 96       	adiw	r28, 0x09	; 9
    18ee:	0f b6       	in	r0, 0x3f	; 63
    18f0:	f8 94       	cli
    18f2:	de bf       	out	0x3e, r29	; 62
    18f4:	0f be       	out	0x3f, r0	; 63
    18f6:	cd bf       	out	0x3d, r28	; 61
    18f8:	df 91       	pop	r29
    18fa:	cf 91       	pop	r28
    18fc:	0f 91       	pop	r16
    18fe:	ef 90       	pop	r14
    1900:	cf 90       	pop	r12
    1902:	af 90       	pop	r10
    1904:	8f 90       	pop	r8
    1906:	08 95       	ret

00001908 <LCD_Init>:
 * Return value    : none

 * description  :This function is used to initialize the lcd.
 *It initializes the LCD for selected mode(4/8-bit) and Type(16x2/16x1 etc)
 **************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8) {
    1908:	cf 93       	push	r28
    190a:	df 93       	push	r29
    190c:	00 d0       	rcall	.+0      	; 0x190e <LCD_Init+0x6>
    190e:	cd b7       	in	r28, 0x3d	; 61
    1910:	de b7       	in	r29, 0x3e	; 62
    1912:	89 83       	std	Y+1, r24	; 0x01
    1914:	6a 83       	std	Y+2, r22	; 0x02

	LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
    1916:	8a 81       	ldd	r24, Y+2	; 0x02
    1918:	80 93 1d 01 	sts	0x011D, r24
	LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
    191c:	89 81       	ldd	r24, Y+1	; 0x01
    191e:	80 93 1c 01 	sts	0x011C, r24
	if (v_lcdNoOfLines_u8 > C_LcdLineTwo) {
    1922:	89 81       	ldd	r24, Y+1	; 0x01
    1924:	83 30       	cpi	r24, 0x03	; 3
    1926:	50 f0       	brcs	.+20     	; 0x193c <LCD_Init+0x34>
		ARR_LcdLineNumAddress_U8[C_LcdLineTwo] = 0x90
    1928:	8a 81       	ldd	r24, Y+2	; 0x02
    192a:	8f 70       	andi	r24, 0x0F	; 15
    192c:	80 57       	subi	r24, 0x70	; 112
    192e:	80 93 68 00 	sts	0x0068, r24
				+ (v_MaxCharsPerLine_u8 & 0x0fu);
		ARR_LcdLineNumAddress_U8[C_LcdLineThree] = 0xd0
    1932:	8a 81       	ldd	r24, Y+2	; 0x02
    1934:	8f 70       	andi	r24, 0x0F	; 15
    1936:	80 53       	subi	r24, 0x30	; 48
    1938:	80 93 69 00 	sts	0x0069, r24
				+ (v_MaxCharsPerLine_u8 & 0x0fu);
	}

	DELAY_ms(100);
    193c:	84 e6       	ldi	r24, 0x64	; 100
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>

	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    1944:	80 91 1e 01 	lds	r24, 0x011E
    1948:	88 30       	cpi	r24, 0x08	; 8
    194a:	21 f4       	brne	.+8      	; 0x1954 <LCD_Init+0x4c>
		LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    194c:	88 e3       	ldi	r24, 0x38	; 56
    194e:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
    1952:	09 c0       	rjmp	.+18     	; 0x1966 <LCD_Init+0x5e>
	} else if (LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8) {
    1954:	80 91 1e 01 	lds	r24, 0x011E
    1958:	84 30       	cpi	r24, 0x04	; 4
    195a:	29 f4       	brne	.+10     	; 0x1966 <LCD_Init+0x5e>
		lcd_Reset();
    195c:	0e 94 ab 18 	call	0x3156	; 0x3156 <lcd_Reset>
		LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type
    1960:	88 e2       	ldi	r24, 0x28	; 40
    1962:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
	}

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
    1966:	8e e0       	ldi	r24, 0x0E	; 14
    1968:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
	LCD_Clear();            // Clear the LCD and go to First line First Position
    196c:	0e 94 bd 0c 	call	0x197a	; 0x197a <LCD_Clear>
}
    1970:	0f 90       	pop	r0
    1972:	0f 90       	pop	r0
    1974:	df 91       	pop	r29
    1976:	cf 91       	pop	r28
    1978:	08 95       	ret

0000197a <LCD_Clear>:
 * I/P Arguments: none.
 * Return value    : none

 * description  :This function clears the LCD and moves the cursor to beginning of first line
 ****************************************************************************************************/
void LCD_Clear() {
    197a:	cf 93       	push	r28
    197c:	df 93       	push	r29
    197e:	cd b7       	in	r28, 0x3d	; 61
    1980:	de b7       	in	r29, 0x3e	; 62
	LCD_CmdWrite(CMD_LCD_CLEAR); // Clear the LCD and go to First line First Position
    1982:	81 e0       	ldi	r24, 0x01	; 1
    1984:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
	LCD_GoToLine(C_LcdLineZero);
    1988:	80 e0       	ldi	r24, 0x00	; 0
    198a:	0e 94 ca 0c 	call	0x1994	; 0x1994 <LCD_GoToLine>
}
    198e:	df 91       	pop	r29
    1990:	cf 91       	pop	r28
    1992:	08 95       	ret

00001994 <LCD_GoToLine>:
 C_LcdLineOne,
 C_LcdLineTwo,
 C_LcdLineThree,

 ****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8) {
    1994:	cf 93       	push	r28
    1996:	df 93       	push	r29
    1998:	1f 92       	push	r1
    199a:	cd b7       	in	r28, 0x3d	; 61
    199c:	de b7       	in	r29, 0x3e	; 62
    199e:	89 83       	std	Y+1, r24	; 0x01
	if (v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8) {
    19a0:	90 91 1c 01 	lds	r25, 0x011C
    19a4:	89 81       	ldd	r24, Y+1	; 0x01
    19a6:	89 17       	cp	r24, r25
    19a8:	70 f4       	brcc	.+28     	; 0x19c6 <LCD_GoToLine+0x32>
		/* If the line number is within range then
		 Move the Cursor to beginning of the specified line */
		v_LcdTrackCursorPos_U8 = 0x00;
    19aa:	10 92 2a 01 	sts	0x012A, r1
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
    19ae:	89 81       	ldd	r24, Y+1	; 0x01
    19b0:	80 93 2b 01 	sts	0x012B, r24
		LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
    19b4:	89 81       	ldd	r24, Y+1	; 0x01
    19b6:	88 2f       	mov	r24, r24
    19b8:	90 e0       	ldi	r25, 0x00	; 0
    19ba:	8a 59       	subi	r24, 0x9A	; 154
    19bc:	9f 4f       	sbci	r25, 0xFF	; 255
    19be:	fc 01       	movw	r30, r24
    19c0:	80 81       	ld	r24, Z
    19c2:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
	}
}
    19c6:	0f 90       	pop	r0
    19c8:	df 91       	pop	r29
    19ca:	cf 91       	pop	r28
    19cc:	08 95       	ret

000019ce <LCD_GoToNextLine>:

 * description  :This function moves the Cursor to beginning of the next line.
 If the cursor is on last line and NextLine command is issued then
 it will move the cursor to first line.
 ****************************************************************************************************/
void LCD_GoToNextLine(void) {
    19ce:	cf 93       	push	r28
    19d0:	df 93       	push	r29
    19d2:	cd b7       	in	r28, 0x3d	; 61
    19d4:	de b7       	in	r29, 0x3e	; 62
	/*Increment the current line number.
	 In case it exceeds the limit, rool it back to first line */
	v_LcdTrackLineNum_U8++;
    19d6:	80 91 2b 01 	lds	r24, 0x012B
    19da:	8f 5f       	subi	r24, 0xFF	; 255
    19dc:	80 93 2b 01 	sts	0x012B, r24
	v_LcdTrackCursorPos_U8 = 0x00;
    19e0:	10 92 2a 01 	sts	0x012A, r1
	if (v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
    19e4:	90 91 1c 01 	lds	r25, 0x011C
    19e8:	80 91 2b 01 	lds	r24, 0x012B
    19ec:	89 17       	cp	r24, r25
    19ee:	10 f0       	brcs	.+4      	; 0x19f4 <LCD_GoToNextLine+0x26>
		v_LcdTrackLineNum_U8 = C_LcdLineZero;
    19f0:	10 92 2b 01 	sts	0x012B, r1
	LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
    19f4:	80 91 2b 01 	lds	r24, 0x012B
    19f8:	88 2f       	mov	r24, r24
    19fa:	90 e0       	ldi	r25, 0x00	; 0
    19fc:	8a 59       	subi	r24, 0x9A	; 154
    19fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1a00:	fc 01       	movw	r30, r24
    1a02:	80 81       	ld	r24, Z
    1a04:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
}
    1a08:	df 91       	pop	r29
    1a0a:	cf 91       	pop	r28
    1a0c:	08 95       	ret

00001a0e <LCD_SetCursor>:

 Note:If the Input(Line/Char number) are out of range
 then no action will be taken
 ****************************************************************************************************/
#if ( Enable_LCD_SetCursor    == 1 )
void LCD_SetCursor(uint8_t v_lineNumber_u8, uint8_t v_charNumber_u8) {
    1a0e:	cf 93       	push	r28
    1a10:	df 93       	push	r29
    1a12:	00 d0       	rcall	.+0      	; 0x1a14 <LCD_SetCursor+0x6>
    1a14:	cd b7       	in	r28, 0x3d	; 61
    1a16:	de b7       	in	r29, 0x3e	; 62
    1a18:	89 83       	std	Y+1, r24	; 0x01
    1a1a:	6a 83       	std	Y+2, r22	; 0x02

	if ((v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
    1a1c:	90 91 1c 01 	lds	r25, 0x011C
    1a20:	89 81       	ldd	r24, Y+1	; 0x01
    1a22:	89 17       	cp	r24, r25
    1a24:	b0 f4       	brcc	.+44     	; 0x1a52 <LCD_SetCursor+0x44>
			&& (v_charNumber_u8 < LCDConfig.v_MaxSupportedChars_U8)) {
    1a26:	90 91 1d 01 	lds	r25, 0x011D
    1a2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a2c:	89 17       	cp	r24, r25
    1a2e:	88 f4       	brcc	.+34     	; 0x1a52 <LCD_SetCursor+0x44>
		/*If the line number and char are in range then
		 move the Cursor to specified Position*/
		v_LcdTrackCursorPos_U8 = v_charNumber_u8;
    1a30:	8a 81       	ldd	r24, Y+2	; 0x02
    1a32:	80 93 2a 01 	sts	0x012A, r24
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
    1a36:	89 81       	ldd	r24, Y+1	; 0x01
    1a38:	80 93 2b 01 	sts	0x012B, r24
		LCD_CmdWrite(
				ARR_LcdLineNumAddress_U8[v_lineNumber_u8] + v_charNumber_u8);
    1a3c:	89 81       	ldd	r24, Y+1	; 0x01
    1a3e:	88 2f       	mov	r24, r24
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	8a 59       	subi	r24, 0x9A	; 154
    1a44:	9f 4f       	sbci	r25, 0xFF	; 255
    1a46:	fc 01       	movw	r30, r24
    1a48:	90 81       	ld	r25, Z
			&& (v_charNumber_u8 < LCDConfig.v_MaxSupportedChars_U8)) {
		/*If the line number and char are in range then
		 move the Cursor to specified Position*/
		v_LcdTrackCursorPos_U8 = v_charNumber_u8;
		v_LcdTrackLineNum_U8 = v_lineNumber_u8;
		LCD_CmdWrite(
    1a4a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a4c:	89 0f       	add	r24, r25
    1a4e:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
				ARR_LcdLineNumAddress_U8[v_lineNumber_u8] + v_charNumber_u8);
	}
}
    1a52:	0f 90       	pop	r0
    1a54:	0f 90       	pop	r0
    1a56:	df 91       	pop	r29
    1a58:	cf 91       	pop	r28
    1a5a:	08 95       	ret

00001a5c <LCD_CmdWrite>:
 * description :This function sends a command to LCD.
 Some of the commonly used commands are defined in lcd.h.
 For more commands refer the data sheet and send the supported command.
 The behaviour is undefined if unsupported commands are sent.
 ****************************************************************************************************/
void LCD_CmdWrite(uint8_t v_lcdCmd_u8) {
    1a5c:	cf 93       	push	r28
    1a5e:	df 93       	push	r29
    1a60:	1f 92       	push	r1
    1a62:	cd b7       	in	r28, 0x3d	; 61
    1a64:	de b7       	in	r29, 0x3e	; 62
    1a66:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    1a68:	0e 94 54 18 	call	0x30a8	; 0x30a8 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    1a6c:	80 91 1e 01 	lds	r24, 0x011E
    1a70:	88 30       	cpi	r24, 0x08	; 8
    1a72:	21 f4       	brne	.+8      	; 0x1a7c <LCD_CmdWrite+0x20>
		lcd_SendLowerNibble(v_lcdCmd_u8);
    1a74:	89 81       	ldd	r24, Y+1	; 0x01
    1a76:	0e 94 17 19 	call	0x322e	; 0x322e <lcd_SendLowerNibble>
    1a7a:	09 c0       	rjmp	.+18     	; 0x1a8e <LCD_CmdWrite+0x32>
	} else {
		lcd_SendHigherNibble(v_lcdCmd_u8);
    1a7c:	89 81       	ldd	r24, Y+1	; 0x01
    1a7e:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
		lcd_SendCmdSignals();
    1a82:	0e 94 5d 19 	call	0x32ba	; 0x32ba <lcd_SendCmdSignals>
		v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
    1a86:	89 81       	ldd	r24, Y+1	; 0x01
    1a88:	82 95       	swap	r24
    1a8a:	80 7f       	andi	r24, 0xF0	; 240
    1a8c:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(v_lcdCmd_u8);
    1a8e:	89 81       	ldd	r24, Y+1	; 0x01
    1a90:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    1a94:	0e 94 5d 19 	call	0x32ba	; 0x32ba <lcd_SendCmdSignals>
}
    1a98:	0f 90       	pop	r0
    1a9a:	df 91       	pop	r29
    1a9c:	cf 91       	pop	r28
    1a9e:	08 95       	ret

00001aa0 <LCD_DisplayChar>:

 * description  : This function sends a character to be displayed on LCD.
 Any valid ascii value can be passed to display respective character

 ****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8) {
    1aa0:	cf 93       	push	r28
    1aa2:	df 93       	push	r29
    1aa4:	1f 92       	push	r1
    1aa6:	cd b7       	in	r28, 0x3d	; 61
    1aa8:	de b7       	in	r29, 0x3e	; 62
    1aaa:	89 83       	std	Y+1, r24	; 0x01
	if ((v_LcdTrackCursorPos_U8 >= LCDConfig.v_MaxSupportedChars_U8)
    1aac:	90 91 1d 01 	lds	r25, 0x011D
    1ab0:	80 91 2a 01 	lds	r24, 0x012A
    1ab4:	89 17       	cp	r24, r25
    1ab6:	18 f4       	brcc	.+6      	; 0x1abe <LCD_DisplayChar+0x1e>
			|| (v_lcdData_u8 == '\n')) {
    1ab8:	89 81       	ldd	r24, Y+1	; 0x01
    1aba:	8a 30       	cpi	r24, 0x0A	; 10
    1abc:	11 f4       	brne	.+4      	; 0x1ac2 <LCD_DisplayChar+0x22>
		/* If the cursor has reached to end of line on page1
		 OR NewLine command is issued Then Move the cursor to next line */
		LCD_GoToNextLine();
    1abe:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <LCD_GoToNextLine>
	}
	if (v_lcdData_u8 != '\n') /* Display the character if its not newLine Char */
    1ac2:	89 81       	ldd	r24, Y+1	; 0x01
    1ac4:	8a 30       	cpi	r24, 0x0A	; 10
    1ac6:	41 f0       	breq	.+16     	; 0x1ad8 <LCD_DisplayChar+0x38>
	{

		lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
    1ac8:	89 81       	ldd	r24, Y+1	; 0x01
    1aca:	0e 94 10 18 	call	0x3020	; 0x3020 <lcd_DataWrite>
		v_LcdTrackCursorPos_U8++;
    1ace:	80 91 2a 01 	lds	r24, 0x012A
    1ad2:	8f 5f       	subi	r24, 0xFF	; 255
    1ad4:	80 93 2a 01 	sts	0x012A, r24
	}
}
    1ad8:	0f 90       	pop	r0
    1ada:	df 91       	pop	r29
    1adc:	cf 91       	pop	r28
    1ade:	08 95       	ret

00001ae0 <LCD_DisplayString>:
 1.The ptr_stringPointer_u8 points to the first char of the string
 and traverses till the end(NULL CHAR)and displays a char each time.

 ****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8) {
    1ae0:	cf 93       	push	r28
    1ae2:	df 93       	push	r29
    1ae4:	00 d0       	rcall	.+0      	; 0x1ae6 <LCD_DisplayString+0x6>
    1ae6:	cd b7       	in	r28, 0x3d	; 61
    1ae8:	de b7       	in	r29, 0x3e	; 62
    1aea:	9a 83       	std	Y+2, r25	; 0x02
    1aec:	89 83       	std	Y+1, r24	; 0x01
	while ((*ptr_stringPointer_u8) != 0)
    1aee:	0b c0       	rjmp	.+22     	; 0x1b06 <LCD_DisplayString+0x26>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
    1af0:	89 81       	ldd	r24, Y+1	; 0x01
    1af2:	9a 81       	ldd	r25, Y+2	; 0x02
    1af4:	9c 01       	movw	r18, r24
    1af6:	2f 5f       	subi	r18, 0xFF	; 255
    1af8:	3f 4f       	sbci	r19, 0xFF	; 255
    1afa:	3a 83       	std	Y+2, r19	; 0x02
    1afc:	29 83       	std	Y+1, r18	; 0x01
    1afe:	fc 01       	movw	r30, r24
    1b00:	80 81       	ld	r24, Z
    1b02:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
 and traverses till the end(NULL CHAR)and displays a char each time.

 ****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8) {
	while ((*ptr_stringPointer_u8) != 0)
    1b06:	89 81       	ldd	r24, Y+1	; 0x01
    1b08:	9a 81       	ldd	r25, Y+2	; 0x02
    1b0a:	fc 01       	movw	r30, r24
    1b0c:	80 81       	ld	r24, Z
    1b0e:	88 23       	and	r24, r24
    1b10:	79 f7       	brne	.-34     	; 0x1af0 <LCD_DisplayString+0x10>
		LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
    1b12:	0f 90       	pop	r0
    1b14:	0f 90       	pop	r0
    1b16:	df 91       	pop	r29
    1b18:	cf 91       	pop	r28
    1b1a:	08 95       	ret

00001b1c <LCD_DisplayStringWithAddingToBuffor>:
#endif

#if (Enable_LCD_DisplayString==1)
void LCD_DisplayStringWithAddingToBuffor(const char *ptr_stringPointer_u8,
		int *x, int y) {
    1b1c:	cf 93       	push	r28
    1b1e:	df 93       	push	r29
    1b20:	cd b7       	in	r28, 0x3d	; 61
    1b22:	de b7       	in	r29, 0x3e	; 62
    1b24:	27 97       	sbiw	r28, 0x07	; 7
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	f8 94       	cli
    1b2a:	de bf       	out	0x3e, r29	; 62
    1b2c:	0f be       	out	0x3f, r0	; 63
    1b2e:	cd bf       	out	0x3d, r28	; 61
    1b30:	9b 83       	std	Y+3, r25	; 0x03
    1b32:	8a 83       	std	Y+2, r24	; 0x02
    1b34:	7d 83       	std	Y+5, r23	; 0x05
    1b36:	6c 83       	std	Y+4, r22	; 0x04
    1b38:	5f 83       	std	Y+7, r21	; 0x07
    1b3a:	4e 83       	std	Y+6, r20	; 0x06
	while ((*ptr_stringPointer_u8) != 0) {
    1b3c:	36 c2       	rjmp	.+1132   	; 0x1faa <LCD_DisplayStringWithAddingToBuffor+0x48e>
		char tmp = (*ptr_stringPointer_u8++);
    1b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b40:	9b 81       	ldd	r25, Y+3	; 0x03
    1b42:	9c 01       	movw	r18, r24
    1b44:	2f 5f       	subi	r18, 0xFF	; 255
    1b46:	3f 4f       	sbci	r19, 0xFF	; 255
    1b48:	3b 83       	std	Y+3, r19	; 0x03
    1b4a:	2a 83       	std	Y+2, r18	; 0x02
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	80 81       	ld	r24, Z
    1b50:	89 83       	std	Y+1, r24	; 0x01

		if (tmp == '%') {
    1b52:	89 81       	ldd	r24, Y+1	; 0x01
    1b54:	85 32       	cpi	r24, 0x25	; 37
    1b56:	09 f0       	breq	.+2      	; 0x1b5a <LCD_DisplayStringWithAddingToBuffor+0x3e>
    1b58:	04 c2       	rjmp	.+1032   	; 0x1f62 <LCD_DisplayStringWithAddingToBuffor+0x446>
			switch (*ptr_stringPointer_u8++) {
    1b5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b5c:	9b 81       	ldd	r25, Y+3	; 0x03
    1b5e:	9c 01       	movw	r18, r24
    1b60:	2f 5f       	subi	r18, 0xFF	; 255
    1b62:	3f 4f       	sbci	r19, 0xFF	; 255
    1b64:	3b 83       	std	Y+3, r19	; 0x03
    1b66:	2a 83       	std	Y+2, r18	; 0x02
    1b68:	fc 01       	movw	r30, r24
    1b6a:	80 81       	ld	r24, Z
    1b6c:	88 2f       	mov	r24, r24
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	aa 27       	eor	r26, r26
    1b72:	97 fd       	sbrc	r25, 7
    1b74:	a0 95       	com	r26
    1b76:	ba 2f       	mov	r27, r26
    1b78:	45 e2       	ldi	r20, 0x25	; 37
    1b7a:	50 e0       	ldi	r21, 0x00	; 0
    1b7c:	28 e5       	ldi	r18, 0x58	; 88
    1b7e:	30 e0       	ldi	r19, 0x00	; 0
    1b80:	84 1b       	sub	r24, r20
    1b82:	95 0b       	sbc	r25, r21
    1b84:	28 17       	cp	r18, r24
    1b86:	39 07       	cpc	r19, r25
    1b88:	08 f4       	brcc	.+2      	; 0x1b8c <LCD_DisplayStringWithAddingToBuffor+0x70>
    1b8a:	0f c2       	rjmp	.+1054   	; 0x1faa <LCD_DisplayStringWithAddingToBuffor+0x48e>
    1b8c:	86 5d       	subi	r24, 0xD6	; 214
    1b8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1b90:	fc 01       	movw	r30, r24
    1b92:	0c 94 2a 1f 	jmp	0x3e54	; 0x3e54 <__tablejump2__>
			case '%':
				LCD_DisplayChar('%');
    1b96:	85 e2       	ldi	r24, 0x25	; 37
    1b98:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
				LCD_BUFFOR[y][(*x)] = '%';
    1b9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b9e:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba0:	fc 01       	movw	r30, r24
    1ba2:	80 81       	ld	r24, Z
    1ba4:	91 81       	ldd	r25, Z+1	; 0x01
    1ba6:	2e 81       	ldd	r18, Y+6	; 0x06
    1ba8:	3f 81       	ldd	r19, Y+7	; 0x07
    1baa:	22 95       	swap	r18
    1bac:	32 95       	swap	r19
    1bae:	30 7f       	andi	r19, 0xF0	; 240
    1bb0:	32 27       	eor	r19, r18
    1bb2:	20 7f       	andi	r18, 0xF0	; 240
    1bb4:	32 27       	eor	r19, r18
    1bb6:	82 0f       	add	r24, r18
    1bb8:	93 1f       	adc	r25, r19
    1bba:	84 50       	subi	r24, 0x04	; 4
    1bbc:	9f 4f       	sbci	r25, 0xFF	; 255
    1bbe:	25 e2       	ldi	r18, 0x25	; 37
    1bc0:	fc 01       	movw	r30, r24
    1bc2:	20 83       	st	Z, r18
				(*x)++;
    1bc4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc6:	9d 81       	ldd	r25, Y+5	; 0x05
    1bc8:	fc 01       	movw	r30, r24
    1bca:	80 81       	ld	r24, Z
    1bcc:	91 81       	ldd	r25, Z+1	; 0x01
    1bce:	9c 01       	movw	r18, r24
    1bd0:	2f 5f       	subi	r18, 0xFF	; 255
    1bd2:	3f 4f       	sbci	r19, 0xFF	; 255
    1bd4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd6:	9d 81       	ldd	r25, Y+5	; 0x05
    1bd8:	fc 01       	movw	r30, r24
    1bda:	31 83       	std	Z+1, r19	; 0x01
    1bdc:	20 83       	st	Z, r18
				break;
    1bde:	c0 c1       	rjmp	.+896    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '>':
				LCD_PrintSymbol(1);
    1be0:	81 e0       	ldi	r24, 0x01	; 1
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '>';
    1be8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bea:	9d 81       	ldd	r25, Y+5	; 0x05
    1bec:	fc 01       	movw	r30, r24
    1bee:	80 81       	ld	r24, Z
    1bf0:	91 81       	ldd	r25, Z+1	; 0x01
    1bf2:	2e 81       	ldd	r18, Y+6	; 0x06
    1bf4:	3f 81       	ldd	r19, Y+7	; 0x07
    1bf6:	22 95       	swap	r18
    1bf8:	32 95       	swap	r19
    1bfa:	30 7f       	andi	r19, 0xF0	; 240
    1bfc:	32 27       	eor	r19, r18
    1bfe:	20 7f       	andi	r18, 0xF0	; 240
    1c00:	32 27       	eor	r19, r18
    1c02:	82 0f       	add	r24, r18
    1c04:	93 1f       	adc	r25, r19
    1c06:	84 50       	subi	r24, 0x04	; 4
    1c08:	9f 4f       	sbci	r25, 0xFF	; 255
    1c0a:	2e e3       	ldi	r18, 0x3E	; 62
    1c0c:	fc 01       	movw	r30, r24
    1c0e:	20 83       	st	Z, r18
				(*x)++;
    1c10:	8c 81       	ldd	r24, Y+4	; 0x04
    1c12:	9d 81       	ldd	r25, Y+5	; 0x05
    1c14:	fc 01       	movw	r30, r24
    1c16:	80 81       	ld	r24, Z
    1c18:	91 81       	ldd	r25, Z+1	; 0x01
    1c1a:	9c 01       	movw	r18, r24
    1c1c:	2f 5f       	subi	r18, 0xFF	; 255
    1c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c20:	8c 81       	ldd	r24, Y+4	; 0x04
    1c22:	9d 81       	ldd	r25, Y+5	; 0x05
    1c24:	fc 01       	movw	r30, r24
    1c26:	31 83       	std	Z+1, r19	; 0x01
    1c28:	20 83       	st	Z, r18
				break;
    1c2a:	9a c1       	rjmp	.+820    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '<':
				LCD_PrintSymbol(2);
    1c2c:	82 e0       	ldi	r24, 0x02	; 2
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '<';
    1c34:	8c 81       	ldd	r24, Y+4	; 0x04
    1c36:	9d 81       	ldd	r25, Y+5	; 0x05
    1c38:	fc 01       	movw	r30, r24
    1c3a:	80 81       	ld	r24, Z
    1c3c:	91 81       	ldd	r25, Z+1	; 0x01
    1c3e:	2e 81       	ldd	r18, Y+6	; 0x06
    1c40:	3f 81       	ldd	r19, Y+7	; 0x07
    1c42:	22 95       	swap	r18
    1c44:	32 95       	swap	r19
    1c46:	30 7f       	andi	r19, 0xF0	; 240
    1c48:	32 27       	eor	r19, r18
    1c4a:	20 7f       	andi	r18, 0xF0	; 240
    1c4c:	32 27       	eor	r19, r18
    1c4e:	82 0f       	add	r24, r18
    1c50:	93 1f       	adc	r25, r19
    1c52:	84 50       	subi	r24, 0x04	; 4
    1c54:	9f 4f       	sbci	r25, 0xFF	; 255
    1c56:	2c e3       	ldi	r18, 0x3C	; 60
    1c58:	fc 01       	movw	r30, r24
    1c5a:	20 83       	st	Z, r18
				(*x)++;
    1c5c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c5e:	9d 81       	ldd	r25, Y+5	; 0x05
    1c60:	fc 01       	movw	r30, r24
    1c62:	80 81       	ld	r24, Z
    1c64:	91 81       	ldd	r25, Z+1	; 0x01
    1c66:	9c 01       	movw	r18, r24
    1c68:	2f 5f       	subi	r18, 0xFF	; 255
    1c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c6c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c6e:	9d 81       	ldd	r25, Y+5	; 0x05
    1c70:	fc 01       	movw	r30, r24
    1c72:	31 83       	std	Z+1, r19	; 0x01
    1c74:	20 83       	st	Z, r18
				break;
    1c76:	74 c1       	rjmp	.+744    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '|':
				LCD_PrintSymbol(3);
    1c78:	83 e0       	ldi	r24, 0x03	; 3
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '|';
    1c80:	8c 81       	ldd	r24, Y+4	; 0x04
    1c82:	9d 81       	ldd	r25, Y+5	; 0x05
    1c84:	fc 01       	movw	r30, r24
    1c86:	80 81       	ld	r24, Z
    1c88:	91 81       	ldd	r25, Z+1	; 0x01
    1c8a:	2e 81       	ldd	r18, Y+6	; 0x06
    1c8c:	3f 81       	ldd	r19, Y+7	; 0x07
    1c8e:	22 95       	swap	r18
    1c90:	32 95       	swap	r19
    1c92:	30 7f       	andi	r19, 0xF0	; 240
    1c94:	32 27       	eor	r19, r18
    1c96:	20 7f       	andi	r18, 0xF0	; 240
    1c98:	32 27       	eor	r19, r18
    1c9a:	82 0f       	add	r24, r18
    1c9c:	93 1f       	adc	r25, r19
    1c9e:	84 50       	subi	r24, 0x04	; 4
    1ca0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ca2:	2c e7       	ldi	r18, 0x7C	; 124
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	20 83       	st	Z, r18
				(*x)++;
    1ca8:	8c 81       	ldd	r24, Y+4	; 0x04
    1caa:	9d 81       	ldd	r25, Y+5	; 0x05
    1cac:	fc 01       	movw	r30, r24
    1cae:	80 81       	ld	r24, Z
    1cb0:	91 81       	ldd	r25, Z+1	; 0x01
    1cb2:	9c 01       	movw	r18, r24
    1cb4:	2f 5f       	subi	r18, 0xFF	; 255
    1cb6:	3f 4f       	sbci	r19, 0xFF	; 255
    1cb8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cba:	9d 81       	ldd	r25, Y+5	; 0x05
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	31 83       	std	Z+1, r19	; 0x01
    1cc0:	20 83       	st	Z, r18
				break;
    1cc2:	4e c1       	rjmp	.+668    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '{':
				LCD_PrintSymbol(4);
    1cc4:	84 e0       	ldi	r24, 0x04	; 4
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '{';
    1ccc:	8c 81       	ldd	r24, Y+4	; 0x04
    1cce:	9d 81       	ldd	r25, Y+5	; 0x05
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	80 81       	ld	r24, Z
    1cd4:	91 81       	ldd	r25, Z+1	; 0x01
    1cd6:	2e 81       	ldd	r18, Y+6	; 0x06
    1cd8:	3f 81       	ldd	r19, Y+7	; 0x07
    1cda:	22 95       	swap	r18
    1cdc:	32 95       	swap	r19
    1cde:	30 7f       	andi	r19, 0xF0	; 240
    1ce0:	32 27       	eor	r19, r18
    1ce2:	20 7f       	andi	r18, 0xF0	; 240
    1ce4:	32 27       	eor	r19, r18
    1ce6:	82 0f       	add	r24, r18
    1ce8:	93 1f       	adc	r25, r19
    1cea:	84 50       	subi	r24, 0x04	; 4
    1cec:	9f 4f       	sbci	r25, 0xFF	; 255
    1cee:	2b e7       	ldi	r18, 0x7B	; 123
    1cf0:	fc 01       	movw	r30, r24
    1cf2:	20 83       	st	Z, r18
				(*x)++;
    1cf4:	8c 81       	ldd	r24, Y+4	; 0x04
    1cf6:	9d 81       	ldd	r25, Y+5	; 0x05
    1cf8:	fc 01       	movw	r30, r24
    1cfa:	80 81       	ld	r24, Z
    1cfc:	91 81       	ldd	r25, Z+1	; 0x01
    1cfe:	9c 01       	movw	r18, r24
    1d00:	2f 5f       	subi	r18, 0xFF	; 255
    1d02:	3f 4f       	sbci	r19, 0xFF	; 255
    1d04:	8c 81       	ldd	r24, Y+4	; 0x04
    1d06:	9d 81       	ldd	r25, Y+5	; 0x05
    1d08:	fc 01       	movw	r30, r24
    1d0a:	31 83       	std	Z+1, r19	; 0x01
    1d0c:	20 83       	st	Z, r18
				break;
    1d0e:	28 c1       	rjmp	.+592    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '}':
				LCD_PrintSymbol(5);
    1d10:	85 e0       	ldi	r24, 0x05	; 5
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = '}';
    1d18:	8c 81       	ldd	r24, Y+4	; 0x04
    1d1a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d1c:	fc 01       	movw	r30, r24
    1d1e:	80 81       	ld	r24, Z
    1d20:	91 81       	ldd	r25, Z+1	; 0x01
    1d22:	2e 81       	ldd	r18, Y+6	; 0x06
    1d24:	3f 81       	ldd	r19, Y+7	; 0x07
    1d26:	22 95       	swap	r18
    1d28:	32 95       	swap	r19
    1d2a:	30 7f       	andi	r19, 0xF0	; 240
    1d2c:	32 27       	eor	r19, r18
    1d2e:	20 7f       	andi	r18, 0xF0	; 240
    1d30:	32 27       	eor	r19, r18
    1d32:	82 0f       	add	r24, r18
    1d34:	93 1f       	adc	r25, r19
    1d36:	84 50       	subi	r24, 0x04	; 4
    1d38:	9f 4f       	sbci	r25, 0xFF	; 255
    1d3a:	2d e7       	ldi	r18, 0x7D	; 125
    1d3c:	fc 01       	movw	r30, r24
    1d3e:	20 83       	st	Z, r18
				(*x)++;
    1d40:	8c 81       	ldd	r24, Y+4	; 0x04
    1d42:	9d 81       	ldd	r25, Y+5	; 0x05
    1d44:	fc 01       	movw	r30, r24
    1d46:	80 81       	ld	r24, Z
    1d48:	91 81       	ldd	r25, Z+1	; 0x01
    1d4a:	9c 01       	movw	r18, r24
    1d4c:	2f 5f       	subi	r18, 0xFF	; 255
    1d4e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d50:	8c 81       	ldd	r24, Y+4	; 0x04
    1d52:	9d 81       	ldd	r25, Y+5	; 0x05
    1d54:	fc 01       	movw	r30, r24
    1d56:	31 83       	std	Z+1, r19	; 0x01
    1d58:	20 83       	st	Z, r18
				break;
    1d5a:	02 c1       	rjmp	.+516    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ',':
				LCD_PrintSymbol(6);
    1d5c:	86 e0       	ldi	r24, 0x06	; 6
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ',';
    1d64:	8c 81       	ldd	r24, Y+4	; 0x04
    1d66:	9d 81       	ldd	r25, Y+5	; 0x05
    1d68:	fc 01       	movw	r30, r24
    1d6a:	80 81       	ld	r24, Z
    1d6c:	91 81       	ldd	r25, Z+1	; 0x01
    1d6e:	2e 81       	ldd	r18, Y+6	; 0x06
    1d70:	3f 81       	ldd	r19, Y+7	; 0x07
    1d72:	22 95       	swap	r18
    1d74:	32 95       	swap	r19
    1d76:	30 7f       	andi	r19, 0xF0	; 240
    1d78:	32 27       	eor	r19, r18
    1d7a:	20 7f       	andi	r18, 0xF0	; 240
    1d7c:	32 27       	eor	r19, r18
    1d7e:	82 0f       	add	r24, r18
    1d80:	93 1f       	adc	r25, r19
    1d82:	84 50       	subi	r24, 0x04	; 4
    1d84:	9f 4f       	sbci	r25, 0xFF	; 255
    1d86:	2c e2       	ldi	r18, 0x2C	; 44
    1d88:	fc 01       	movw	r30, r24
    1d8a:	20 83       	st	Z, r18
				(*x)++;
    1d8c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d8e:	9d 81       	ldd	r25, Y+5	; 0x05
    1d90:	fc 01       	movw	r30, r24
    1d92:	80 81       	ld	r24, Z
    1d94:	91 81       	ldd	r25, Z+1	; 0x01
    1d96:	9c 01       	movw	r18, r24
    1d98:	2f 5f       	subi	r18, 0xFF	; 255
    1d9a:	3f 4f       	sbci	r19, 0xFF	; 255
    1d9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d9e:	9d 81       	ldd	r25, Y+5	; 0x05
    1da0:	fc 01       	movw	r30, r24
    1da2:	31 83       	std	Z+1, r19	; 0x01
    1da4:	20 83       	st	Z, r18
				break;
    1da6:	dc c0       	rjmp	.+440    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ':':
				LCD_PrintSymbol(7);
    1da8:	87 e0       	ldi	r24, 0x07	; 7
    1daa:	90 e0       	ldi	r25, 0x00	; 0
    1dac:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ':';
    1db0:	8c 81       	ldd	r24, Y+4	; 0x04
    1db2:	9d 81       	ldd	r25, Y+5	; 0x05
    1db4:	fc 01       	movw	r30, r24
    1db6:	80 81       	ld	r24, Z
    1db8:	91 81       	ldd	r25, Z+1	; 0x01
    1dba:	2e 81       	ldd	r18, Y+6	; 0x06
    1dbc:	3f 81       	ldd	r19, Y+7	; 0x07
    1dbe:	22 95       	swap	r18
    1dc0:	32 95       	swap	r19
    1dc2:	30 7f       	andi	r19, 0xF0	; 240
    1dc4:	32 27       	eor	r19, r18
    1dc6:	20 7f       	andi	r18, 0xF0	; 240
    1dc8:	32 27       	eor	r19, r18
    1dca:	82 0f       	add	r24, r18
    1dcc:	93 1f       	adc	r25, r19
    1dce:	84 50       	subi	r24, 0x04	; 4
    1dd0:	9f 4f       	sbci	r25, 0xFF	; 255
    1dd2:	2a e3       	ldi	r18, 0x3A	; 58
    1dd4:	fc 01       	movw	r30, r24
    1dd6:	20 83       	st	Z, r18
				(*x)++;
    1dd8:	8c 81       	ldd	r24, Y+4	; 0x04
    1dda:	9d 81       	ldd	r25, Y+5	; 0x05
    1ddc:	fc 01       	movw	r30, r24
    1dde:	80 81       	ld	r24, Z
    1de0:	91 81       	ldd	r25, Z+1	; 0x01
    1de2:	9c 01       	movw	r18, r24
    1de4:	2f 5f       	subi	r18, 0xFF	; 255
    1de6:	3f 4f       	sbci	r19, 0xFF	; 255
    1de8:	8c 81       	ldd	r24, Y+4	; 0x04
    1dea:	9d 81       	ldd	r25, Y+5	; 0x05
    1dec:	fc 01       	movw	r30, r24
    1dee:	31 83       	std	Z+1, r19	; 0x01
    1df0:	20 83       	st	Z, r18
				break;
    1df2:	b6 c0       	rjmp	.+364    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ';':
				LCD_PrintSymbol(8);
    1df4:	88 e0       	ldi	r24, 0x08	; 8
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][(*x)] = ';';
    1dfc:	8c 81       	ldd	r24, Y+4	; 0x04
    1dfe:	9d 81       	ldd	r25, Y+5	; 0x05
    1e00:	fc 01       	movw	r30, r24
    1e02:	80 81       	ld	r24, Z
    1e04:	91 81       	ldd	r25, Z+1	; 0x01
    1e06:	2e 81       	ldd	r18, Y+6	; 0x06
    1e08:	3f 81       	ldd	r19, Y+7	; 0x07
    1e0a:	22 95       	swap	r18
    1e0c:	32 95       	swap	r19
    1e0e:	30 7f       	andi	r19, 0xF0	; 240
    1e10:	32 27       	eor	r19, r18
    1e12:	20 7f       	andi	r18, 0xF0	; 240
    1e14:	32 27       	eor	r19, r18
    1e16:	82 0f       	add	r24, r18
    1e18:	93 1f       	adc	r25, r19
    1e1a:	84 50       	subi	r24, 0x04	; 4
    1e1c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e1e:	2b e3       	ldi	r18, 0x3B	; 59
    1e20:	fc 01       	movw	r30, r24
    1e22:	20 83       	st	Z, r18
				(*x)++;
    1e24:	8c 81       	ldd	r24, Y+4	; 0x04
    1e26:	9d 81       	ldd	r25, Y+5	; 0x05
    1e28:	fc 01       	movw	r30, r24
    1e2a:	80 81       	ld	r24, Z
    1e2c:	91 81       	ldd	r25, Z+1	; 0x01
    1e2e:	9c 01       	movw	r18, r24
    1e30:	2f 5f       	subi	r18, 0xFF	; 255
    1e32:	3f 4f       	sbci	r19, 0xFF	; 255
    1e34:	8c 81       	ldd	r24, Y+4	; 0x04
    1e36:	9d 81       	ldd	r25, Y+5	; 0x05
    1e38:	fc 01       	movw	r30, r24
    1e3a:	31 83       	std	Z+1, r19	; 0x01
    1e3c:	20 83       	st	Z, r18
				break;
    1e3e:	90 c0       	rjmp	.+288    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '?':
				LCD_PrintBlock();
    1e40:	0e 94 99 1a 	call	0x3532	; 0x3532 <LCD_PrintBlock>
				LCD_BUFFOR[y][(*x)] = '?';
    1e44:	8c 81       	ldd	r24, Y+4	; 0x04
    1e46:	9d 81       	ldd	r25, Y+5	; 0x05
    1e48:	fc 01       	movw	r30, r24
    1e4a:	80 81       	ld	r24, Z
    1e4c:	91 81       	ldd	r25, Z+1	; 0x01
    1e4e:	2e 81       	ldd	r18, Y+6	; 0x06
    1e50:	3f 81       	ldd	r19, Y+7	; 0x07
    1e52:	22 95       	swap	r18
    1e54:	32 95       	swap	r19
    1e56:	30 7f       	andi	r19, 0xF0	; 240
    1e58:	32 27       	eor	r19, r18
    1e5a:	20 7f       	andi	r18, 0xF0	; 240
    1e5c:	32 27       	eor	r19, r18
    1e5e:	82 0f       	add	r24, r18
    1e60:	93 1f       	adc	r25, r19
    1e62:	84 50       	subi	r24, 0x04	; 4
    1e64:	9f 4f       	sbci	r25, 0xFF	; 255
    1e66:	2f e3       	ldi	r18, 0x3F	; 63
    1e68:	fc 01       	movw	r30, r24
    1e6a:	20 83       	st	Z, r18
				(*x)++;
    1e6c:	8c 81       	ldd	r24, Y+4	; 0x04
    1e6e:	9d 81       	ldd	r25, Y+5	; 0x05
    1e70:	fc 01       	movw	r30, r24
    1e72:	80 81       	ld	r24, Z
    1e74:	91 81       	ldd	r25, Z+1	; 0x01
    1e76:	9c 01       	movw	r18, r24
    1e78:	2f 5f       	subi	r18, 0xFF	; 255
    1e7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1e7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1e80:	fc 01       	movw	r30, r24
    1e82:	31 83       	std	Z+1, r19	; 0x01
    1e84:	20 83       	st	Z, r18
				break;
    1e86:	6c c0       	rjmp	.+216    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '[':
				LCD_PrintLArrow();
    1e88:	0e 94 a3 1a 	call	0x3546	; 0x3546 <LCD_PrintLArrow>
				LCD_BUFFOR[y][(*x)] = '[';
    1e8c:	8c 81       	ldd	r24, Y+4	; 0x04
    1e8e:	9d 81       	ldd	r25, Y+5	; 0x05
    1e90:	fc 01       	movw	r30, r24
    1e92:	80 81       	ld	r24, Z
    1e94:	91 81       	ldd	r25, Z+1	; 0x01
    1e96:	2e 81       	ldd	r18, Y+6	; 0x06
    1e98:	3f 81       	ldd	r19, Y+7	; 0x07
    1e9a:	22 95       	swap	r18
    1e9c:	32 95       	swap	r19
    1e9e:	30 7f       	andi	r19, 0xF0	; 240
    1ea0:	32 27       	eor	r19, r18
    1ea2:	20 7f       	andi	r18, 0xF0	; 240
    1ea4:	32 27       	eor	r19, r18
    1ea6:	82 0f       	add	r24, r18
    1ea8:	93 1f       	adc	r25, r19
    1eaa:	84 50       	subi	r24, 0x04	; 4
    1eac:	9f 4f       	sbci	r25, 0xFF	; 255
    1eae:	2b e5       	ldi	r18, 0x5B	; 91
    1eb0:	fc 01       	movw	r30, r24
    1eb2:	20 83       	st	Z, r18
				(*x)++;
    1eb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1eb6:	9d 81       	ldd	r25, Y+5	; 0x05
    1eb8:	fc 01       	movw	r30, r24
    1eba:	80 81       	ld	r24, Z
    1ebc:	91 81       	ldd	r25, Z+1	; 0x01
    1ebe:	9c 01       	movw	r18, r24
    1ec0:	2f 5f       	subi	r18, 0xFF	; 255
    1ec2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ec6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ec8:	fc 01       	movw	r30, r24
    1eca:	31 83       	std	Z+1, r19	; 0x01
    1ecc:	20 83       	st	Z, r18
				break;
    1ece:	48 c0       	rjmp	.+144    	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case ']':
				LCD_PrintRArrow();
    1ed0:	0e 94 ad 1a 	call	0x355a	; 0x355a <LCD_PrintRArrow>
				LCD_BUFFOR[y][(*x)] = ']';
    1ed4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ed6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ed8:	fc 01       	movw	r30, r24
    1eda:	80 81       	ld	r24, Z
    1edc:	91 81       	ldd	r25, Z+1	; 0x01
    1ede:	2e 81       	ldd	r18, Y+6	; 0x06
    1ee0:	3f 81       	ldd	r19, Y+7	; 0x07
    1ee2:	22 95       	swap	r18
    1ee4:	32 95       	swap	r19
    1ee6:	30 7f       	andi	r19, 0xF0	; 240
    1ee8:	32 27       	eor	r19, r18
    1eea:	20 7f       	andi	r18, 0xF0	; 240
    1eec:	32 27       	eor	r19, r18
    1eee:	82 0f       	add	r24, r18
    1ef0:	93 1f       	adc	r25, r19
    1ef2:	84 50       	subi	r24, 0x04	; 4
    1ef4:	9f 4f       	sbci	r25, 0xFF	; 255
    1ef6:	2d e5       	ldi	r18, 0x5D	; 93
    1ef8:	fc 01       	movw	r30, r24
    1efa:	20 83       	st	Z, r18
				(*x)++;
    1efc:	8c 81       	ldd	r24, Y+4	; 0x04
    1efe:	9d 81       	ldd	r25, Y+5	; 0x05
    1f00:	fc 01       	movw	r30, r24
    1f02:	80 81       	ld	r24, Z
    1f04:	91 81       	ldd	r25, Z+1	; 0x01
    1f06:	9c 01       	movw	r18, r24
    1f08:	2f 5f       	subi	r18, 0xFF	; 255
    1f0a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f0c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f0e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f10:	fc 01       	movw	r30, r24
    1f12:	31 83       	std	Z+1, r19	; 0x01
    1f14:	20 83       	st	Z, r18
				break;
    1f16:	24 c0       	rjmp	.+72     	; 0x1f60 <LCD_DisplayStringWithAddingToBuffor+0x444>
			case '.':
				LCD_PrintDot();
    1f18:	0e 94 b7 1a 	call	0x356e	; 0x356e <LCD_PrintDot>
				LCD_BUFFOR[y][(*x)] = '.';
    1f1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f20:	fc 01       	movw	r30, r24
    1f22:	80 81       	ld	r24, Z
    1f24:	91 81       	ldd	r25, Z+1	; 0x01
    1f26:	2e 81       	ldd	r18, Y+6	; 0x06
    1f28:	3f 81       	ldd	r19, Y+7	; 0x07
    1f2a:	22 95       	swap	r18
    1f2c:	32 95       	swap	r19
    1f2e:	30 7f       	andi	r19, 0xF0	; 240
    1f30:	32 27       	eor	r19, r18
    1f32:	20 7f       	andi	r18, 0xF0	; 240
    1f34:	32 27       	eor	r19, r18
    1f36:	82 0f       	add	r24, r18
    1f38:	93 1f       	adc	r25, r19
    1f3a:	84 50       	subi	r24, 0x04	; 4
    1f3c:	9f 4f       	sbci	r25, 0xFF	; 255
    1f3e:	2e e2       	ldi	r18, 0x2E	; 46
    1f40:	fc 01       	movw	r30, r24
    1f42:	20 83       	st	Z, r18
				(*x)++;
    1f44:	8c 81       	ldd	r24, Y+4	; 0x04
    1f46:	9d 81       	ldd	r25, Y+5	; 0x05
    1f48:	fc 01       	movw	r30, r24
    1f4a:	80 81       	ld	r24, Z
    1f4c:	91 81       	ldd	r25, Z+1	; 0x01
    1f4e:	9c 01       	movw	r18, r24
    1f50:	2f 5f       	subi	r18, 0xFF	; 255
    1f52:	3f 4f       	sbci	r19, 0xFF	; 255
    1f54:	8c 81       	ldd	r24, Y+4	; 0x04
    1f56:	9d 81       	ldd	r25, Y+5	; 0x05
    1f58:	fc 01       	movw	r30, r24
    1f5a:	31 83       	std	Z+1, r19	; 0x01
    1f5c:	20 83       	st	Z, r18
				break;
    1f5e:	00 00       	nop
    1f60:	24 c0       	rjmp	.+72     	; 0x1faa <LCD_DisplayStringWithAddingToBuffor+0x48e>
			}
		} else {
			LCD_DisplayChar(tmp);
    1f62:	89 81       	ldd	r24, Y+1	; 0x01
    1f64:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = tmp;
    1f68:	8c 81       	ldd	r24, Y+4	; 0x04
    1f6a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f6c:	fc 01       	movw	r30, r24
    1f6e:	80 81       	ld	r24, Z
    1f70:	91 81       	ldd	r25, Z+1	; 0x01
    1f72:	2e 81       	ldd	r18, Y+6	; 0x06
    1f74:	3f 81       	ldd	r19, Y+7	; 0x07
    1f76:	22 95       	swap	r18
    1f78:	32 95       	swap	r19
    1f7a:	30 7f       	andi	r19, 0xF0	; 240
    1f7c:	32 27       	eor	r19, r18
    1f7e:	20 7f       	andi	r18, 0xF0	; 240
    1f80:	32 27       	eor	r19, r18
    1f82:	82 0f       	add	r24, r18
    1f84:	93 1f       	adc	r25, r19
    1f86:	84 50       	subi	r24, 0x04	; 4
    1f88:	9f 4f       	sbci	r25, 0xFF	; 255
    1f8a:	29 81       	ldd	r18, Y+1	; 0x01
    1f8c:	fc 01       	movw	r30, r24
    1f8e:	20 83       	st	Z, r18
			(*x)++;
    1f90:	8c 81       	ldd	r24, Y+4	; 0x04
    1f92:	9d 81       	ldd	r25, Y+5	; 0x05
    1f94:	fc 01       	movw	r30, r24
    1f96:	80 81       	ld	r24, Z
    1f98:	91 81       	ldd	r25, Z+1	; 0x01
    1f9a:	9c 01       	movw	r18, r24
    1f9c:	2f 5f       	subi	r18, 0xFF	; 255
    1f9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1fa0:	8c 81       	ldd	r24, Y+4	; 0x04
    1fa2:	9d 81       	ldd	r25, Y+5	; 0x05
    1fa4:	fc 01       	movw	r30, r24
    1fa6:	31 83       	std	Z+1, r19	; 0x01
    1fa8:	20 83       	st	Z, r18
#endif

#if (Enable_LCD_DisplayString==1)
void LCD_DisplayStringWithAddingToBuffor(const char *ptr_stringPointer_u8,
		int *x, int y) {
	while ((*ptr_stringPointer_u8) != 0) {
    1faa:	8a 81       	ldd	r24, Y+2	; 0x02
    1fac:	9b 81       	ldd	r25, Y+3	; 0x03
    1fae:	fc 01       	movw	r30, r24
    1fb0:	80 81       	ld	r24, Z
    1fb2:	88 23       	and	r24, r24
    1fb4:	09 f0       	breq	.+2      	; 0x1fb8 <LCD_DisplayStringWithAddingToBuffor+0x49c>
    1fb6:	c3 cd       	rjmp	.-1146   	; 0x1b3e <LCD_DisplayStringWithAddingToBuffor+0x22>
			LCD_DisplayChar(tmp);
			LCD_BUFFOR[y][(*x)] = tmp;
			(*x)++;
		}
	}
}
    1fb8:	27 96       	adiw	r28, 0x07	; 7
    1fba:	0f b6       	in	r0, 0x3f	; 63
    1fbc:	f8 94       	cli
    1fbe:	de bf       	out	0x3e, r29	; 62
    1fc0:	0f be       	out	0x3f, r0	; 63
    1fc2:	cd bf       	out	0x3d, r28	; 61
    1fc4:	df 91       	pop	r29
    1fc6:	cf 91       	pop	r28
    1fc8:	08 95       	ret

00001fca <LCD_ScrollMessage>:
 * description  :This function scrolls the given message on the specified line.
 If the specified line number is out of range then the message
 will be scrolled on first line
 ****************************************************************************************************/
#if ( Enable_LCD_ScrollMessage  == 1 )
void LCD_ScrollMessage(uint8_t v_lineNumber_u8, char *ptr_msgPointer_u8) {
    1fca:	cf 93       	push	r28
    1fcc:	df 93       	push	r29
    1fce:	00 d0       	rcall	.+0      	; 0x1fd0 <LCD_ScrollMessage+0x6>
    1fd0:	00 d0       	rcall	.+0      	; 0x1fd2 <LCD_ScrollMessage+0x8>
    1fd2:	1f 92       	push	r1
    1fd4:	cd b7       	in	r28, 0x3d	; 61
    1fd6:	de b7       	in	r29, 0x3e	; 62
    1fd8:	8b 83       	std	Y+3, r24	; 0x03
    1fda:	7d 83       	std	Y+5, r23	; 0x05
    1fdc:	6c 83       	std	Y+4, r22	; 0x04
	unsigned char i, j;

	if (v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
    1fde:	90 91 1c 01 	lds	r25, 0x011C
    1fe2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe4:	89 17       	cp	r24, r25
    1fe6:	08 f0       	brcs	.+2      	; 0x1fea <LCD_ScrollMessage+0x20>
		v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range
    1fe8:	1b 82       	std	Y+3, r1	; 0x03

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor
    1fea:	8c e0       	ldi	r24, 0x0C	; 12
    1fec:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>

	for (i = 0; ptr_msgPointer_u8[i]; i++) {
    1ff0:	19 82       	std	Y+1, r1	; 0x01
    1ff2:	40 c0       	rjmp	.+128    	; 0x2074 <LCD_ScrollMessage+0xaa>
		/* Loop to display the complete string,    each time 16 chars are displayed and
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line
    1ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff6:	0e 94 ca 0c 	call	0x1994	; 0x1994 <LCD_GoToLine>

		for (j = 0;
    1ffa:	1a 82       	std	Y+2, r1	; 0x02
    1ffc:	13 c0       	rjmp	.+38     	; 0x2024 <LCD_ScrollMessage+0x5a>
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
    1ffe:	89 81       	ldd	r24, Y+1	; 0x01
    2000:	28 2f       	mov	r18, r24
    2002:	30 e0       	ldi	r19, 0x00	; 0
    2004:	8a 81       	ldd	r24, Y+2	; 0x02
    2006:	88 2f       	mov	r24, r24
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	82 0f       	add	r24, r18
    200c:	93 1f       	adc	r25, r19
    200e:	2c 81       	ldd	r18, Y+4	; 0x04
    2010:	3d 81       	ldd	r19, Y+5	; 0x05
    2012:	82 0f       	add	r24, r18
    2014:	93 1f       	adc	r25, r19
    2016:	fc 01       	movw	r30, r24
    2018:	80 81       	ld	r24, Z
    201a:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
    201e:	8a 81       	ldd	r24, Y+2	; 0x02
    2020:	8f 5f       	subi	r24, 0xFF	; 255
    2022:	8a 83       	std	Y+2, r24	; 0x02
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
				(j < LCDConfig.v_MaxSupportedChars_U8)
    2024:	90 91 1d 01 	lds	r25, 0x011D
		/* Loop to display the complete string,    each time 16 chars are displayed and
		 pointer is incremented to point to next char */

		LCD_GoToLine(v_lineNumber_u8);     //Move the Cursor to first line

		for (j = 0;
    2028:	8a 81       	ldd	r24, Y+2	; 0x02
    202a:	89 17       	cp	r24, r25
    202c:	80 f4       	brcc	.+32     	; 0x204e <LCD_ScrollMessage+0x84>
				(j < LCDConfig.v_MaxSupportedChars_U8)
						&& (ptr_msgPointer_u8[i + j]); j++) {
    202e:	89 81       	ldd	r24, Y+1	; 0x01
    2030:	28 2f       	mov	r18, r24
    2032:	30 e0       	ldi	r19, 0x00	; 0
    2034:	8a 81       	ldd	r24, Y+2	; 0x02
    2036:	88 2f       	mov	r24, r24
    2038:	90 e0       	ldi	r25, 0x00	; 0
    203a:	82 0f       	add	r24, r18
    203c:	93 1f       	adc	r25, r19
    203e:	2c 81       	ldd	r18, Y+4	; 0x04
    2040:	3d 81       	ldd	r19, Y+5	; 0x05
    2042:	82 0f       	add	r24, r18
    2044:	93 1f       	adc	r25, r19
    2046:	fc 01       	movw	r30, r24
    2048:	80 81       	ld	r24, Z
    204a:	88 23       	and	r24, r24
    204c:	c1 f6       	brne	.-80     	; 0x1ffe <LCD_ScrollMessage+0x34>
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
		}

		while (j < LCDConfig.v_MaxSupportedChars_U8) {
    204e:	06 c0       	rjmp	.+12     	; 0x205c <LCD_ScrollMessage+0x92>
			/*If the chars to be scrolled are less than MaxLcdChars,
			 then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
    2050:	80 e2       	ldi	r24, 0x20	; 32
    2052:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
			j++;
    2056:	8a 81       	ldd	r24, Y+2	; 0x02
    2058:	8f 5f       	subi	r24, 0xFF	; 255
    205a:	8a 83       	std	Y+2, r24	; 0x02
						&& (ptr_msgPointer_u8[i + j]); j++) {
			//Display first 16 Chars or till Null char is reached
			LCD_DisplayChar(ptr_msgPointer_u8[i + j]);
		}

		while (j < LCDConfig.v_MaxSupportedChars_U8) {
    205c:	90 91 1d 01 	lds	r25, 0x011D
    2060:	8a 81       	ldd	r24, Y+2	; 0x02
    2062:	89 17       	cp	r24, r25
    2064:	a8 f3       	brcs	.-22     	; 0x2050 <LCD_ScrollMessage+0x86>
			 then display remaining chars with blank spaces*/
			LCD_DisplayChar(' ');
			j++;
		}

		DELAY_ms(C_ScrollDelayTime_U8);
    2066:	88 ec       	ldi	r24, 0xC8	; 200
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
	if (v_lineNumber_u8 >= LCDConfig.v_MaxSupportedLines_U8)
		v_lineNumber_u8 = C_LcdLineZero; // Select first line if the v_lineNumber_u8 is out of range

	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_OFF);             //Disable the Cursor

	for (i = 0; ptr_msgPointer_u8[i]; i++) {
    206e:	89 81       	ldd	r24, Y+1	; 0x01
    2070:	8f 5f       	subi	r24, 0xFF	; 255
    2072:	89 83       	std	Y+1, r24	; 0x01
    2074:	89 81       	ldd	r24, Y+1	; 0x01
    2076:	88 2f       	mov	r24, r24
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	2c 81       	ldd	r18, Y+4	; 0x04
    207c:	3d 81       	ldd	r19, Y+5	; 0x05
    207e:	82 0f       	add	r24, r18
    2080:	93 1f       	adc	r25, r19
    2082:	fc 01       	movw	r30, r24
    2084:	80 81       	ld	r24, Z
    2086:	88 23       	and	r24, r24
    2088:	09 f0       	breq	.+2      	; 0x208c <LCD_ScrollMessage+0xc2>
    208a:	b4 cf       	rjmp	.-152    	; 0x1ff4 <LCD_ScrollMessage+0x2a>
			j++;
		}

		DELAY_ms(C_ScrollDelayTime_U8);
	}
	LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);         // Finally enable the Cursor
    208c:	8e e0       	ldi	r24, 0x0E	; 14
    208e:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
}
    2092:	0f 90       	pop	r0
    2094:	0f 90       	pop	r0
    2096:	0f 90       	pop	r0
    2098:	0f 90       	pop	r0
    209a:	0f 90       	pop	r0
    209c:	df 91       	pop	r29
    209e:	cf 91       	pop	r28
    20a0:	08 95       	ret

000020a2 <LCD_DisplayNumber>:
 8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
 9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32,
		uint8_t v_numOfDigitsToDisplay_u8) {
    20a2:	ff 92       	push	r15
    20a4:	0f 93       	push	r16
    20a6:	1f 93       	push	r17
    20a8:	cf 93       	push	r28
    20aa:	df 93       	push	r29
    20ac:	cd b7       	in	r28, 0x3d	; 61
    20ae:	de b7       	in	r29, 0x3e	; 62
    20b0:	69 97       	sbiw	r28, 0x19	; 25
    20b2:	0f b6       	in	r0, 0x3f	; 63
    20b4:	f8 94       	cli
    20b6:	de bf       	out	0x3e, r29	; 62
    20b8:	0f be       	out	0x3f, r0	; 63
    20ba:	cd bf       	out	0x3d, r28	; 61
    20bc:	8c 87       	std	Y+12, r24	; 0x0c
    20be:	4d 87       	std	Y+13, r20	; 0x0d
    20c0:	5e 87       	std	Y+14, r21	; 0x0e
    20c2:	6f 87       	std	Y+15, r22	; 0x0f
    20c4:	78 8b       	std	Y+16, r23	; 0x10
    20c6:	29 8b       	std	Y+17, r18	; 0x11
	uint8_t i = 0, a[10];
    20c8:	19 82       	std	Y+1, r1	; 0x01

	if (C_BINARY_U8 == v_numericSystem_u8) {
    20ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    20cc:	82 30       	cpi	r24, 0x02	; 2
    20ce:	69 f5       	brne	.+90     	; 0x212a <LCD_DisplayNumber+0x88>
		while (v_numOfDigitsToDisplay_u8 != 0) {
    20d0:	28 c0       	rjmp	.+80     	; 0x2122 <LCD_DisplayNumber+0x80>
			/* Start Extracting the bits from the specified bit positions.
			 Get the Acsii values of the bits and display */
			i = util_GetBitStatus(v_number_u32,
    20d2:	89 89       	ldd	r24, Y+17	; 0x11
    20d4:	88 2f       	mov	r24, r24
    20d6:	90 e0       	ldi	r25, 0x00	; 0
    20d8:	9c 01       	movw	r18, r24
    20da:	21 50       	subi	r18, 0x01	; 1
    20dc:	31 09       	sbc	r19, r1
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	90 e0       	ldi	r25, 0x00	; 0
    20e2:	02 c0       	rjmp	.+4      	; 0x20e8 <LCD_DisplayNumber+0x46>
    20e4:	88 0f       	add	r24, r24
    20e6:	99 1f       	adc	r25, r25
    20e8:	2a 95       	dec	r18
    20ea:	e2 f7       	brpl	.-8      	; 0x20e4 <LCD_DisplayNumber+0x42>
    20ec:	9c 01       	movw	r18, r24
    20ee:	44 27       	eor	r20, r20
    20f0:	37 fd       	sbrc	r19, 7
    20f2:	40 95       	com	r20
    20f4:	54 2f       	mov	r21, r20
    20f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    20f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    20fa:	af 85       	ldd	r26, Y+15	; 0x0f
    20fc:	b8 89       	ldd	r27, Y+16	; 0x10
    20fe:	82 23       	and	r24, r18
    2100:	93 23       	and	r25, r19
    2102:	a4 23       	and	r26, r20
    2104:	b5 23       	and	r27, r21
    2106:	21 e0       	ldi	r18, 0x01	; 1
    2108:	00 97       	sbiw	r24, 0x00	; 0
    210a:	a1 05       	cpc	r26, r1
    210c:	b1 05       	cpc	r27, r1
    210e:	09 f4       	brne	.+2      	; 0x2112 <LCD_DisplayNumber+0x70>
    2110:	20 e0       	ldi	r18, 0x00	; 0
    2112:	29 83       	std	Y+1, r18	; 0x01
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
    2114:	89 81       	ldd	r24, Y+1	; 0x01
    2116:	80 5d       	subi	r24, 0xD0	; 208
    2118:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
			v_numOfDigitsToDisplay_u8--;
    211c:	89 89       	ldd	r24, Y+17	; 0x11
    211e:	81 50       	subi	r24, 0x01	; 1
    2120:	89 8b       	std	Y+17, r24	; 0x11
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32,
		uint8_t v_numOfDigitsToDisplay_u8) {
	uint8_t i = 0, a[10];

	if (C_BINARY_U8 == v_numericSystem_u8) {
		while (v_numOfDigitsToDisplay_u8 != 0) {
    2122:	89 89       	ldd	r24, Y+17	; 0x11
    2124:	88 23       	and	r24, r24
    2126:	a9 f6       	brne	.-86     	; 0x20d2 <LCD_DisplayNumber+0x30>
    2128:	91 c0       	rjmp	.+290    	; 0x224c <LCD_DisplayNumber+0x1aa>
			i = util_GetBitStatus(v_number_u32,
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
			v_numOfDigitsToDisplay_u8--;
		}
	} else if (v_number_u32 == 0) {
    212a:	8d 85       	ldd	r24, Y+13	; 0x0d
    212c:	9e 85       	ldd	r25, Y+14	; 0x0e
    212e:	af 85       	ldd	r26, Y+15	; 0x0f
    2130:	b8 89       	ldd	r27, Y+16	; 0x10
    2132:	00 97       	sbiw	r24, 0x00	; 0
    2134:	a1 05       	cpc	r26, r1
    2136:	b1 05       	cpc	r27, r1
    2138:	21 f4       	brne	.+8      	; 0x2142 <LCD_DisplayNumber+0xa0>
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
    213a:	80 e3       	ldi	r24, 0x30	; 48
    213c:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
    2140:	85 c0       	rjmp	.+266    	; 0x224c <LCD_DisplayNumber+0x1aa>
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    2142:	19 82       	std	Y+1, r1	; 0x01
    2144:	4f c0       	rjmp	.+158    	; 0x21e4 <LCD_DisplayNumber+0x142>
			/* Continue extracting the digits from right side
			 till the Specified v_numOfDigitsToDisplay_u8 */
			if (v_number_u32 != 0) {
    2146:	8d 85       	ldd	r24, Y+13	; 0x0d
    2148:	9e 85       	ldd	r25, Y+14	; 0x0e
    214a:	af 85       	ldd	r26, Y+15	; 0x0f
    214c:	b8 89       	ldd	r27, Y+16	; 0x10
    214e:	00 97       	sbiw	r24, 0x00	; 0
    2150:	a1 05       	cpc	r26, r1
    2152:	b1 05       	cpc	r27, r1
    2154:	a1 f1       	breq	.+104    	; 0x21be <LCD_DisplayNumber+0x11c>
				 First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.

				 example for Decimal number:
				 If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
				 The process continues till it becomes zero or max digits reached*/
				a[i] = util_GetMod32(v_number_u32, v_numericSystem_u8);
    2156:	89 81       	ldd	r24, Y+1	; 0x01
    2158:	08 2f       	mov	r16, r24
    215a:	10 e0       	ldi	r17, 0x00	; 0
    215c:	fd 84       	ldd	r15, Y+13	; 0x0d
    215e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2160:	28 2f       	mov	r18, r24
    2162:	30 e0       	ldi	r19, 0x00	; 0
    2164:	40 e0       	ldi	r20, 0x00	; 0
    2166:	50 e0       	ldi	r21, 0x00	; 0
    2168:	8d 85       	ldd	r24, Y+13	; 0x0d
    216a:	9e 85       	ldd	r25, Y+14	; 0x0e
    216c:	af 85       	ldd	r26, Y+15	; 0x0f
    216e:	b8 89       	ldd	r27, Y+16	; 0x10
    2170:	bc 01       	movw	r22, r24
    2172:	cd 01       	movw	r24, r26
    2174:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__udivmodsi4>
    2178:	da 01       	movw	r26, r20
    217a:	c9 01       	movw	r24, r18
    217c:	98 2f       	mov	r25, r24
    217e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2180:	98 9f       	mul	r25, r24
    2182:	80 2d       	mov	r24, r0
    2184:	11 24       	eor	r1, r1
    2186:	2f 2d       	mov	r18, r15
    2188:	28 1b       	sub	r18, r24
    218a:	ce 01       	movw	r24, r28
    218c:	02 96       	adiw	r24, 0x02	; 2
    218e:	80 0f       	add	r24, r16
    2190:	91 1f       	adc	r25, r17
    2192:	fc 01       	movw	r30, r24
    2194:	20 83       	st	Z, r18
				v_number_u32 = v_number_u32 / v_numericSystem_u8;
    2196:	8c 85       	ldd	r24, Y+12	; 0x0c
    2198:	28 2f       	mov	r18, r24
    219a:	30 e0       	ldi	r19, 0x00	; 0
    219c:	40 e0       	ldi	r20, 0x00	; 0
    219e:	50 e0       	ldi	r21, 0x00	; 0
    21a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    21a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    21a4:	af 85       	ldd	r26, Y+15	; 0x0f
    21a6:	b8 89       	ldd	r27, Y+16	; 0x10
    21a8:	bc 01       	movw	r22, r24
    21aa:	cd 01       	movw	r24, r26
    21ac:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__udivmodsi4>
    21b0:	da 01       	movw	r26, r20
    21b2:	c9 01       	movw	r24, r18
    21b4:	8d 87       	std	Y+13, r24	; 0x0d
    21b6:	9e 87       	std	Y+14, r25	; 0x0e
    21b8:	af 87       	std	Y+15, r26	; 0x0f
    21ba:	b8 8b       	std	Y+16, r27	; 0x10
    21bc:	10 c0       	rjmp	.+32     	; 0x21de <LCD_DisplayNumber+0x13c>
			} else if ((v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8)
    21be:	89 89       	ldd	r24, Y+17	; 0x11
    21c0:	8f 3f       	cpi	r24, 0xFF	; 255
    21c2:	a9 f0       	breq	.+42     	; 0x21ee <LCD_DisplayNumber+0x14c>
					|| (v_numOfDigitsToDisplay_u8 > C_MaxDigitsToDisplay_U8)) {
    21c4:	89 89       	ldd	r24, Y+17	; 0x11
    21c6:	8b 30       	cpi	r24, 0x0B	; 11
    21c8:	90 f4       	brcc	.+36     	; 0x21ee <LCD_DisplayNumber+0x14c>
				break;
			} else {
				/* In case user expects more digits to be displayed than the actual digits in number,
				 then update the remaining digits with zero.
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
    21ca:	89 81       	ldd	r24, Y+1	; 0x01
    21cc:	88 2f       	mov	r24, r24
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	9e 01       	movw	r18, r28
    21d2:	2e 5f       	subi	r18, 0xFE	; 254
    21d4:	3f 4f       	sbci	r19, 0xFF	; 255
    21d6:	82 0f       	add	r24, r18
    21d8:	93 1f       	adc	r25, r19
    21da:	fc 01       	movw	r30, r24
    21dc:	10 82       	st	Z, r1
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    21de:	89 81       	ldd	r24, Y+1	; 0x01
    21e0:	8f 5f       	subi	r24, 0xFF	; 255
    21e2:	89 83       	std	Y+1, r24	; 0x01
    21e4:	99 81       	ldd	r25, Y+1	; 0x01
    21e6:	89 89       	ldd	r24, Y+17	; 0x11
    21e8:	98 17       	cp	r25, r24
    21ea:	08 f4       	brcc	.+2      	; 0x21ee <LCD_DisplayNumber+0x14c>
    21ec:	ac cf       	rjmp	.-168    	; 0x2146 <LCD_DisplayNumber+0xa4>
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    21ee:	2b c0       	rjmp	.+86     	; 0x2246 <LCD_DisplayNumber+0x1a4>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
    21f0:	89 81       	ldd	r24, Y+1	; 0x01
    21f2:	88 2f       	mov	r24, r24
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	01 97       	sbiw	r24, 0x01	; 1
    21f8:	9e 01       	movw	r18, r28
    21fa:	2e 5f       	subi	r18, 0xFE	; 254
    21fc:	3f 4f       	sbci	r19, 0xFF	; 255
    21fe:	82 0f       	add	r24, r18
    2200:	93 1f       	adc	r25, r19
    2202:	fc 01       	movw	r30, r24
    2204:	80 81       	ld	r24, Z
    2206:	8a 30       	cpi	r24, 0x0A	; 10
    2208:	68 f0       	brcs	.+26     	; 0x2224 <LCD_DisplayNumber+0x182>
    220a:	89 81       	ldd	r24, Y+1	; 0x01
    220c:	88 2f       	mov	r24, r24
    220e:	90 e0       	ldi	r25, 0x00	; 0
    2210:	01 97       	sbiw	r24, 0x01	; 1
    2212:	9e 01       	movw	r18, r28
    2214:	2e 5f       	subi	r18, 0xFE	; 254
    2216:	3f 4f       	sbci	r19, 0xFF	; 255
    2218:	82 0f       	add	r24, r18
    221a:	93 1f       	adc	r25, r19
    221c:	fc 01       	movw	r30, r24
    221e:	80 81       	ld	r24, Z
    2220:	89 5c       	subi	r24, 0xC9	; 201
    2222:	0c c0       	rjmp	.+24     	; 0x223c <LCD_DisplayNumber+0x19a>
    2224:	89 81       	ldd	r24, Y+1	; 0x01
    2226:	88 2f       	mov	r24, r24
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	01 97       	sbiw	r24, 0x01	; 1
    222c:	9e 01       	movw	r18, r28
    222e:	2e 5f       	subi	r18, 0xFE	; 254
    2230:	3f 4f       	sbci	r19, 0xFF	; 255
    2232:	82 0f       	add	r24, r18
    2234:	93 1f       	adc	r25, r19
    2236:	fc 01       	movw	r30, r24
    2238:	80 81       	ld	r24, Z
    223a:	80 5d       	subi	r24, 0xD0	; 208
    223c:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
			i--;
    2240:	89 81       	ldd	r24, Y+1	; 0x01
    2242:	81 50       	subi	r24, 0x01	; 1
    2244:	89 83       	std	Y+1, r24	; 0x01
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    2246:	89 81       	ldd	r24, Y+1	; 0x01
    2248:	88 23       	and	r24, r24
    224a:	91 f6       	brne	.-92     	; 0x21f0 <LCD_DisplayNumber+0x14e>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
			i--;
		}
	}
}
    224c:	69 96       	adiw	r28, 0x19	; 25
    224e:	0f b6       	in	r0, 0x3f	; 63
    2250:	f8 94       	cli
    2252:	de bf       	out	0x3e, r29	; 62
    2254:	0f be       	out	0x3f, r0	; 63
    2256:	cd bf       	out	0x3d, r28	; 61
    2258:	df 91       	pop	r29
    225a:	cf 91       	pop	r28
    225c:	1f 91       	pop	r17
    225e:	0f 91       	pop	r16
    2260:	ff 90       	pop	r15
    2262:	08 95       	ret

00002264 <LCD_DisplayNumberWithAddingToBuffor>:
#endif

#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumberWithAddingToBuffor(uint8_t v_numericSystem_u8,
		uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8, int *x, int y) {
    2264:	ef 92       	push	r14
    2266:	ff 92       	push	r15
    2268:	0f 93       	push	r16
    226a:	1f 93       	push	r17
    226c:	cf 93       	push	r28
    226e:	df 93       	push	r29
    2270:	cd b7       	in	r28, 0x3d	; 61
    2272:	de b7       	in	r29, 0x3e	; 62
    2274:	6d 97       	sbiw	r28, 0x1d	; 29
    2276:	0f b6       	in	r0, 0x3f	; 63
    2278:	f8 94       	cli
    227a:	de bf       	out	0x3e, r29	; 62
    227c:	0f be       	out	0x3f, r0	; 63
    227e:	cd bf       	out	0x3d, r28	; 61
    2280:	8c 87       	std	Y+12, r24	; 0x0c
    2282:	4d 87       	std	Y+13, r20	; 0x0d
    2284:	5e 87       	std	Y+14, r21	; 0x0e
    2286:	6f 87       	std	Y+15, r22	; 0x0f
    2288:	78 8b       	std	Y+16, r23	; 0x10
    228a:	29 8b       	std	Y+17, r18	; 0x11
    228c:	1b 8b       	std	Y+19, r17	; 0x13
    228e:	0a 8b       	std	Y+18, r16	; 0x12
    2290:	fd 8a       	std	Y+21, r15	; 0x15
    2292:	ec 8a       	std	Y+20, r14	; 0x14
	uint8_t i = 0, a[10];
    2294:	19 82       	std	Y+1, r1	; 0x01

	if (C_BINARY_U8 == v_numericSystem_u8) {
    2296:	8c 85       	ldd	r24, Y+12	; 0x0c
    2298:	82 30       	cpi	r24, 0x02	; 2
    229a:	09 f0       	breq	.+2      	; 0x229e <LCD_DisplayNumberWithAddingToBuffor+0x3a>
    229c:	51 c0       	rjmp	.+162    	; 0x2340 <LCD_DisplayNumberWithAddingToBuffor+0xdc>
		while (v_numOfDigitsToDisplay_u8 != 0) {
    229e:	4b c0       	rjmp	.+150    	; 0x2336 <LCD_DisplayNumberWithAddingToBuffor+0xd2>
			/* Start Extracting the bits from the specified bit positions.
			 Get the Acsii values of the bits and display */
			i = util_GetBitStatus(v_number_u32,
    22a0:	89 89       	ldd	r24, Y+17	; 0x11
    22a2:	88 2f       	mov	r24, r24
    22a4:	90 e0       	ldi	r25, 0x00	; 0
    22a6:	9c 01       	movw	r18, r24
    22a8:	21 50       	subi	r18, 0x01	; 1
    22aa:	31 09       	sbc	r19, r1
    22ac:	81 e0       	ldi	r24, 0x01	; 1
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	02 c0       	rjmp	.+4      	; 0x22b6 <LCD_DisplayNumberWithAddingToBuffor+0x52>
    22b2:	88 0f       	add	r24, r24
    22b4:	99 1f       	adc	r25, r25
    22b6:	2a 95       	dec	r18
    22b8:	e2 f7       	brpl	.-8      	; 0x22b2 <LCD_DisplayNumberWithAddingToBuffor+0x4e>
    22ba:	9c 01       	movw	r18, r24
    22bc:	44 27       	eor	r20, r20
    22be:	37 fd       	sbrc	r19, 7
    22c0:	40 95       	com	r20
    22c2:	54 2f       	mov	r21, r20
    22c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    22c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    22c8:	af 85       	ldd	r26, Y+15	; 0x0f
    22ca:	b8 89       	ldd	r27, Y+16	; 0x10
    22cc:	82 23       	and	r24, r18
    22ce:	93 23       	and	r25, r19
    22d0:	a4 23       	and	r26, r20
    22d2:	b5 23       	and	r27, r21
    22d4:	21 e0       	ldi	r18, 0x01	; 1
    22d6:	00 97       	sbiw	r24, 0x00	; 0
    22d8:	a1 05       	cpc	r26, r1
    22da:	b1 05       	cpc	r27, r1
    22dc:	09 f4       	brne	.+2      	; 0x22e0 <LCD_DisplayNumberWithAddingToBuffor+0x7c>
    22de:	20 e0       	ldi	r18, 0x00	; 0
    22e0:	29 83       	std	Y+1, r18	; 0x01
					(v_numOfDigitsToDisplay_u8 - 1));
			LCD_DisplayChar(util_Dec2Ascii(i));
    22e2:	89 81       	ldd	r24, Y+1	; 0x01
    22e4:	80 5d       	subi	r24, 0xD0	; 208
    22e6:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = util_Dec2Ascii(i);
    22ea:	8a 89       	ldd	r24, Y+18	; 0x12
    22ec:	9b 89       	ldd	r25, Y+19	; 0x13
    22ee:	fc 01       	movw	r30, r24
    22f0:	80 81       	ld	r24, Z
    22f2:	91 81       	ldd	r25, Z+1	; 0x01
    22f4:	29 81       	ldd	r18, Y+1	; 0x01
    22f6:	40 e3       	ldi	r20, 0x30	; 48
    22f8:	42 0f       	add	r20, r18
    22fa:	2c 89       	ldd	r18, Y+20	; 0x14
    22fc:	3d 89       	ldd	r19, Y+21	; 0x15
    22fe:	22 95       	swap	r18
    2300:	32 95       	swap	r19
    2302:	30 7f       	andi	r19, 0xF0	; 240
    2304:	32 27       	eor	r19, r18
    2306:	20 7f       	andi	r18, 0xF0	; 240
    2308:	32 27       	eor	r19, r18
    230a:	82 0f       	add	r24, r18
    230c:	93 1f       	adc	r25, r19
    230e:	84 50       	subi	r24, 0x04	; 4
    2310:	9f 4f       	sbci	r25, 0xFF	; 255
    2312:	fc 01       	movw	r30, r24
    2314:	40 83       	st	Z, r20
			(*x)++;
    2316:	8a 89       	ldd	r24, Y+18	; 0x12
    2318:	9b 89       	ldd	r25, Y+19	; 0x13
    231a:	fc 01       	movw	r30, r24
    231c:	80 81       	ld	r24, Z
    231e:	91 81       	ldd	r25, Z+1	; 0x01
    2320:	9c 01       	movw	r18, r24
    2322:	2f 5f       	subi	r18, 0xFF	; 255
    2324:	3f 4f       	sbci	r19, 0xFF	; 255
    2326:	8a 89       	ldd	r24, Y+18	; 0x12
    2328:	9b 89       	ldd	r25, Y+19	; 0x13
    232a:	fc 01       	movw	r30, r24
    232c:	31 83       	std	Z+1, r19	; 0x01
    232e:	20 83       	st	Z, r18
			v_numOfDigitsToDisplay_u8--;
    2330:	89 89       	ldd	r24, Y+17	; 0x11
    2332:	81 50       	subi	r24, 0x01	; 1
    2334:	89 8b       	std	Y+17, r24	; 0x11
void LCD_DisplayNumberWithAddingToBuffor(uint8_t v_numericSystem_u8,
		uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8, int *x, int y) {
	uint8_t i = 0, a[10];

	if (C_BINARY_U8 == v_numericSystem_u8) {
		while (v_numOfDigitsToDisplay_u8 != 0) {
    2336:	89 89       	ldd	r24, Y+17	; 0x11
    2338:	88 23       	and	r24, r24
    233a:	09 f0       	breq	.+2      	; 0x233e <LCD_DisplayNumberWithAddingToBuffor+0xda>
    233c:	b1 cf       	rjmp	.-158    	; 0x22a0 <LCD_DisplayNumberWithAddingToBuffor+0x3c>
    233e:	fe c0       	rjmp	.+508    	; 0x253c <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
			LCD_DisplayChar(util_Dec2Ascii(i));
			LCD_BUFFOR[y][(*x)] = util_Dec2Ascii(i);
			(*x)++;
			v_numOfDigitsToDisplay_u8--;
		}
	} else if (v_number_u32 == 0) {
    2340:	8d 85       	ldd	r24, Y+13	; 0x0d
    2342:	9e 85       	ldd	r25, Y+14	; 0x0e
    2344:	af 85       	ldd	r26, Y+15	; 0x0f
    2346:	b8 89       	ldd	r27, Y+16	; 0x10
    2348:	00 97       	sbiw	r24, 0x00	; 0
    234a:	a1 05       	cpc	r26, r1
    234c:	b1 05       	cpc	r27, r1
    234e:	29 f5       	brne	.+74     	; 0x239a <LCD_DisplayNumberWithAddingToBuffor+0x136>
		/* If the number is zero then display Specified number of zeros*/
		/*: Display single zero or multiple. Currently single zero is displayed*/
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
    2350:	80 e3       	ldi	r24, 0x30	; 48
    2352:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
		LCD_BUFFOR[y][(*x)] = '0';
    2356:	8a 89       	ldd	r24, Y+18	; 0x12
    2358:	9b 89       	ldd	r25, Y+19	; 0x13
    235a:	fc 01       	movw	r30, r24
    235c:	80 81       	ld	r24, Z
    235e:	91 81       	ldd	r25, Z+1	; 0x01
    2360:	2c 89       	ldd	r18, Y+20	; 0x14
    2362:	3d 89       	ldd	r19, Y+21	; 0x15
    2364:	22 95       	swap	r18
    2366:	32 95       	swap	r19
    2368:	30 7f       	andi	r19, 0xF0	; 240
    236a:	32 27       	eor	r19, r18
    236c:	20 7f       	andi	r18, 0xF0	; 240
    236e:	32 27       	eor	r19, r18
    2370:	82 0f       	add	r24, r18
    2372:	93 1f       	adc	r25, r19
    2374:	84 50       	subi	r24, 0x04	; 4
    2376:	9f 4f       	sbci	r25, 0xFF	; 255
    2378:	20 e3       	ldi	r18, 0x30	; 48
    237a:	fc 01       	movw	r30, r24
    237c:	20 83       	st	Z, r18
		(*x)++;
    237e:	8a 89       	ldd	r24, Y+18	; 0x12
    2380:	9b 89       	ldd	r25, Y+19	; 0x13
    2382:	fc 01       	movw	r30, r24
    2384:	80 81       	ld	r24, Z
    2386:	91 81       	ldd	r25, Z+1	; 0x01
    2388:	9c 01       	movw	r18, r24
    238a:	2f 5f       	subi	r18, 0xFF	; 255
    238c:	3f 4f       	sbci	r19, 0xFF	; 255
    238e:	8a 89       	ldd	r24, Y+18	; 0x12
    2390:	9b 89       	ldd	r25, Y+19	; 0x13
    2392:	fc 01       	movw	r30, r24
    2394:	31 83       	std	Z+1, r19	; 0x01
    2396:	20 83       	st	Z, r18
    2398:	d1 c0       	rjmp	.+418    	; 0x253c <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    239a:	19 82       	std	Y+1, r1	; 0x01
    239c:	4f c0       	rjmp	.+158    	; 0x243c <LCD_DisplayNumberWithAddingToBuffor+0x1d8>
			/* Continue extracting the digits from right side
			 till the Specified v_numOfDigitsToDisplay_u8 */
			if (v_number_u32 != 0) {
    239e:	8d 85       	ldd	r24, Y+13	; 0x0d
    23a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    23a2:	af 85       	ldd	r26, Y+15	; 0x0f
    23a4:	b8 89       	ldd	r27, Y+16	; 0x10
    23a6:	00 97       	sbiw	r24, 0x00	; 0
    23a8:	a1 05       	cpc	r26, r1
    23aa:	b1 05       	cpc	r27, r1
    23ac:	a1 f1       	breq	.+104    	; 0x2416 <LCD_DisplayNumberWithAddingToBuffor+0x1b2>
				 First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.

				 example for Decimal number:
				 If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
				 The process continues till it becomes zero or max digits reached*/
				a[i] = util_GetMod32(v_number_u32, v_numericSystem_u8);
    23ae:	89 81       	ldd	r24, Y+1	; 0x01
    23b0:	08 2f       	mov	r16, r24
    23b2:	10 e0       	ldi	r17, 0x00	; 0
    23b4:	fd 84       	ldd	r15, Y+13	; 0x0d
    23b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    23b8:	28 2f       	mov	r18, r24
    23ba:	30 e0       	ldi	r19, 0x00	; 0
    23bc:	40 e0       	ldi	r20, 0x00	; 0
    23be:	50 e0       	ldi	r21, 0x00	; 0
    23c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    23c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    23c4:	af 85       	ldd	r26, Y+15	; 0x0f
    23c6:	b8 89       	ldd	r27, Y+16	; 0x10
    23c8:	bc 01       	movw	r22, r24
    23ca:	cd 01       	movw	r24, r26
    23cc:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__udivmodsi4>
    23d0:	da 01       	movw	r26, r20
    23d2:	c9 01       	movw	r24, r18
    23d4:	98 2f       	mov	r25, r24
    23d6:	8c 85       	ldd	r24, Y+12	; 0x0c
    23d8:	98 9f       	mul	r25, r24
    23da:	80 2d       	mov	r24, r0
    23dc:	11 24       	eor	r1, r1
    23de:	2f 2d       	mov	r18, r15
    23e0:	28 1b       	sub	r18, r24
    23e2:	ce 01       	movw	r24, r28
    23e4:	02 96       	adiw	r24, 0x02	; 2
    23e6:	80 0f       	add	r24, r16
    23e8:	91 1f       	adc	r25, r17
    23ea:	fc 01       	movw	r30, r24
    23ec:	20 83       	st	Z, r18
				v_number_u32 = v_number_u32 / v_numericSystem_u8;
    23ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    23f0:	28 2f       	mov	r18, r24
    23f2:	30 e0       	ldi	r19, 0x00	; 0
    23f4:	40 e0       	ldi	r20, 0x00	; 0
    23f6:	50 e0       	ldi	r21, 0x00	; 0
    23f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    23fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    23fc:	af 85       	ldd	r26, Y+15	; 0x0f
    23fe:	b8 89       	ldd	r27, Y+16	; 0x10
    2400:	bc 01       	movw	r22, r24
    2402:	cd 01       	movw	r24, r26
    2404:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__udivmodsi4>
    2408:	da 01       	movw	r26, r20
    240a:	c9 01       	movw	r24, r18
    240c:	8d 87       	std	Y+13, r24	; 0x0d
    240e:	9e 87       	std	Y+14, r25	; 0x0e
    2410:	af 87       	std	Y+15, r26	; 0x0f
    2412:	b8 8b       	std	Y+16, r27	; 0x10
    2414:	10 c0       	rjmp	.+32     	; 0x2436 <LCD_DisplayNumberWithAddingToBuffor+0x1d2>
			} else if ((v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8)
    2416:	89 89       	ldd	r24, Y+17	; 0x11
    2418:	8f 3f       	cpi	r24, 0xFF	; 255
    241a:	a9 f0       	breq	.+42     	; 0x2446 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
					|| (v_numOfDigitsToDisplay_u8 > C_MaxDigitsToDisplay_U8)) {
    241c:	89 89       	ldd	r24, Y+17	; 0x11
    241e:	8b 30       	cpi	r24, 0x0B	; 11
    2420:	90 f4       	brcc	.+36     	; 0x2446 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
				break;
			} else {
				/* In case user expects more digits to be displayed than the actual digits in number,
				 then update the remaining digits with zero.
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
    2422:	89 81       	ldd	r24, Y+1	; 0x01
    2424:	88 2f       	mov	r24, r24
    2426:	90 e0       	ldi	r25, 0x00	; 0
    2428:	9e 01       	movw	r18, r28
    242a:	2e 5f       	subi	r18, 0xFE	; 254
    242c:	3f 4f       	sbci	r19, 0xFF	; 255
    242e:	82 0f       	add	r24, r18
    2430:	93 1f       	adc	r25, r19
    2432:	fc 01       	movw	r30, r24
    2434:	10 82       	st	Z, r1
		//for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
		LCD_DisplayChar('0');
		LCD_BUFFOR[y][(*x)] = '0';
		(*x)++;
	} else {
		for (i = 0; i < v_numOfDigitsToDisplay_u8; i++) {
    2436:	89 81       	ldd	r24, Y+1	; 0x01
    2438:	8f 5f       	subi	r24, 0xFF	; 255
    243a:	89 83       	std	Y+1, r24	; 0x01
    243c:	99 81       	ldd	r25, Y+1	; 0x01
    243e:	89 89       	ldd	r24, Y+17	; 0x11
    2440:	98 17       	cp	r25, r24
    2442:	08 f4       	brcc	.+2      	; 0x2446 <LCD_DisplayNumberWithAddingToBuffor+0x1e2>
    2444:	ac cf       	rjmp	.-168    	; 0x239e <LCD_DisplayNumberWithAddingToBuffor+0x13a>
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    2446:	76 c0       	rjmp	.+236    	; 0x2534 <LCD_DisplayNumberWithAddingToBuffor+0x2d0>
			/* Finally get the ascii values of the digits and display*/
			LCD_DisplayChar(util_Hex2Ascii(a[i - 1]));
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	88 2f       	mov	r24, r24
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	01 97       	sbiw	r24, 0x01	; 1
    2450:	9e 01       	movw	r18, r28
    2452:	2e 5f       	subi	r18, 0xFE	; 254
    2454:	3f 4f       	sbci	r19, 0xFF	; 255
    2456:	82 0f       	add	r24, r18
    2458:	93 1f       	adc	r25, r19
    245a:	fc 01       	movw	r30, r24
    245c:	80 81       	ld	r24, Z
    245e:	8a 30       	cpi	r24, 0x0A	; 10
    2460:	68 f0       	brcs	.+26     	; 0x247c <LCD_DisplayNumberWithAddingToBuffor+0x218>
    2462:	89 81       	ldd	r24, Y+1	; 0x01
    2464:	88 2f       	mov	r24, r24
    2466:	90 e0       	ldi	r25, 0x00	; 0
    2468:	01 97       	sbiw	r24, 0x01	; 1
    246a:	9e 01       	movw	r18, r28
    246c:	2e 5f       	subi	r18, 0xFE	; 254
    246e:	3f 4f       	sbci	r19, 0xFF	; 255
    2470:	82 0f       	add	r24, r18
    2472:	93 1f       	adc	r25, r19
    2474:	fc 01       	movw	r30, r24
    2476:	80 81       	ld	r24, Z
    2478:	89 5c       	subi	r24, 0xC9	; 201
    247a:	0c c0       	rjmp	.+24     	; 0x2494 <LCD_DisplayNumberWithAddingToBuffor+0x230>
    247c:	89 81       	ldd	r24, Y+1	; 0x01
    247e:	88 2f       	mov	r24, r24
    2480:	90 e0       	ldi	r25, 0x00	; 0
    2482:	01 97       	sbiw	r24, 0x01	; 1
    2484:	9e 01       	movw	r18, r28
    2486:	2e 5f       	subi	r18, 0xFE	; 254
    2488:	3f 4f       	sbci	r19, 0xFF	; 255
    248a:	82 0f       	add	r24, r18
    248c:	93 1f       	adc	r25, r19
    248e:	fc 01       	movw	r30, r24
    2490:	80 81       	ld	r24, Z
    2492:	80 5d       	subi	r24, 0xD0	; 208
    2494:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
			LCD_BUFFOR[y][(*x)] = util_Hex2Ascii(a[i - 1]);
    2498:	8a 89       	ldd	r24, Y+18	; 0x12
    249a:	9b 89       	ldd	r25, Y+19	; 0x13
    249c:	fc 01       	movw	r30, r24
    249e:	80 81       	ld	r24, Z
    24a0:	91 81       	ldd	r25, Z+1	; 0x01
    24a2:	29 81       	ldd	r18, Y+1	; 0x01
    24a4:	22 2f       	mov	r18, r18
    24a6:	30 e0       	ldi	r19, 0x00	; 0
    24a8:	21 50       	subi	r18, 0x01	; 1
    24aa:	31 09       	sbc	r19, r1
    24ac:	ae 01       	movw	r20, r28
    24ae:	4e 5f       	subi	r20, 0xFE	; 254
    24b0:	5f 4f       	sbci	r21, 0xFF	; 255
    24b2:	24 0f       	add	r18, r20
    24b4:	35 1f       	adc	r19, r21
    24b6:	f9 01       	movw	r30, r18
    24b8:	20 81       	ld	r18, Z
    24ba:	2a 30       	cpi	r18, 0x0A	; 10
    24bc:	78 f0       	brcs	.+30     	; 0x24dc <LCD_DisplayNumberWithAddingToBuffor+0x278>
    24be:	29 81       	ldd	r18, Y+1	; 0x01
    24c0:	22 2f       	mov	r18, r18
    24c2:	30 e0       	ldi	r19, 0x00	; 0
    24c4:	21 50       	subi	r18, 0x01	; 1
    24c6:	31 09       	sbc	r19, r1
    24c8:	ae 01       	movw	r20, r28
    24ca:	4e 5f       	subi	r20, 0xFE	; 254
    24cc:	5f 4f       	sbci	r21, 0xFF	; 255
    24ce:	24 0f       	add	r18, r20
    24d0:	35 1f       	adc	r19, r21
    24d2:	f9 01       	movw	r30, r18
    24d4:	20 81       	ld	r18, Z
    24d6:	47 e3       	ldi	r20, 0x37	; 55
    24d8:	42 0f       	add	r20, r18
    24da:	0e c0       	rjmp	.+28     	; 0x24f8 <LCD_DisplayNumberWithAddingToBuffor+0x294>
    24dc:	29 81       	ldd	r18, Y+1	; 0x01
    24de:	22 2f       	mov	r18, r18
    24e0:	30 e0       	ldi	r19, 0x00	; 0
    24e2:	21 50       	subi	r18, 0x01	; 1
    24e4:	31 09       	sbc	r19, r1
    24e6:	ae 01       	movw	r20, r28
    24e8:	4e 5f       	subi	r20, 0xFE	; 254
    24ea:	5f 4f       	sbci	r21, 0xFF	; 255
    24ec:	24 0f       	add	r18, r20
    24ee:	35 1f       	adc	r19, r21
    24f0:	f9 01       	movw	r30, r18
    24f2:	20 81       	ld	r18, Z
    24f4:	40 e3       	ldi	r20, 0x30	; 48
    24f6:	42 0f       	add	r20, r18
    24f8:	2c 89       	ldd	r18, Y+20	; 0x14
    24fa:	3d 89       	ldd	r19, Y+21	; 0x15
    24fc:	22 95       	swap	r18
    24fe:	32 95       	swap	r19
    2500:	30 7f       	andi	r19, 0xF0	; 240
    2502:	32 27       	eor	r19, r18
    2504:	20 7f       	andi	r18, 0xF0	; 240
    2506:	32 27       	eor	r19, r18
    2508:	82 0f       	add	r24, r18
    250a:	93 1f       	adc	r25, r19
    250c:	84 50       	subi	r24, 0x04	; 4
    250e:	9f 4f       	sbci	r25, 0xFF	; 255
    2510:	fc 01       	movw	r30, r24
    2512:	40 83       	st	Z, r20
			(*x)++;
    2514:	8a 89       	ldd	r24, Y+18	; 0x12
    2516:	9b 89       	ldd	r25, Y+19	; 0x13
    2518:	fc 01       	movw	r30, r24
    251a:	80 81       	ld	r24, Z
    251c:	91 81       	ldd	r25, Z+1	; 0x01
    251e:	9c 01       	movw	r18, r24
    2520:	2f 5f       	subi	r18, 0xFF	; 255
    2522:	3f 4f       	sbci	r19, 0xFF	; 255
    2524:	8a 89       	ldd	r24, Y+18	; 0x12
    2526:	9b 89       	ldd	r25, Y+19	; 0x13
    2528:	fc 01       	movw	r30, r24
    252a:	31 83       	std	Z+1, r19	; 0x01
    252c:	20 83       	st	Z, r18
			i--;
    252e:	89 81       	ldd	r24, Y+1	; 0x01
    2530:	81 50       	subi	r24, 0x01	; 1
    2532:	89 83       	std	Y+1, r24	; 0x01
				 Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
				a[i] = 0;
			}
		}

		while (i != 0) {
    2534:	89 81       	ldd	r24, Y+1	; 0x01
    2536:	88 23       	and	r24, r24
    2538:	09 f0       	breq	.+2      	; 0x253c <LCD_DisplayNumberWithAddingToBuffor+0x2d8>
    253a:	86 cf       	rjmp	.-244    	; 0x2448 <LCD_DisplayNumberWithAddingToBuffor+0x1e4>
			LCD_BUFFOR[y][(*x)] = util_Hex2Ascii(a[i - 1]);
			(*x)++;
			i--;
		}
	}
}
    253c:	6d 96       	adiw	r28, 0x1d	; 29
    253e:	0f b6       	in	r0, 0x3f	; 63
    2540:	f8 94       	cli
    2542:	de bf       	out	0x3e, r29	; 62
    2544:	0f be       	out	0x3f, r0	; 63
    2546:	cd bf       	out	0x3d, r28	; 61
    2548:	df 91       	pop	r29
    254a:	cf 91       	pop	r28
    254c:	1f 91       	pop	r17
    254e:	0f 91       	pop	r16
    2550:	ff 90       	pop	r15
    2552:	ef 90       	pop	r14
    2554:	08 95       	ret

00002556 <LCD_XYPrintf>:
 #####: In case of printing the 8-bit variables, it is recommended to type cast and promote them to uint16_t.
 uint8_t v_Num_u8;
 LCD_Printf("num1:%u",(uint16_t)v_Num_u8);
 **************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_XYPrintf(int x, int y, const char *argList, ...) {
    2556:	ef 92       	push	r14
    2558:	ff 92       	push	r15
    255a:	0f 93       	push	r16
    255c:	1f 93       	push	r17
    255e:	cf 93       	push	r28
    2560:	df 93       	push	r29
    2562:	cd b7       	in	r28, 0x3d	; 61
    2564:	de b7       	in	r29, 0x3e	; 62
    2566:	66 97       	sbiw	r28, 0x16	; 22
    2568:	0f b6       	in	r0, 0x3f	; 63
    256a:	f8 94       	cli
    256c:	de bf       	out	0x3e, r29	; 62
    256e:	0f be       	out	0x3f, r0	; 63
    2570:	cd bf       	out	0x3d, r28	; 61
	LCD_SetCursor(y, x);
    2572:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2574:	89 a1       	ldd	r24, Y+33	; 0x21
    2576:	69 2f       	mov	r22, r25
    2578:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <LCD_SetCursor>
	int tmpX = x;
    257c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    257e:	98 a1       	ldd	r25, Y+32	; 0x20
    2580:	9c 8b       	std	Y+20, r25	; 0x14
    2582:	8b 8b       	std	Y+19, r24	; 0x13
	uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)  
    double v_floatNum_f32;
#endif

	va_start(argp, argList);
    2584:	ce 01       	movw	r24, r28
    2586:	85 96       	adiw	r24, 0x25	; 37
    2588:	9e 8b       	std	Y+22, r25	; 0x16
    258a:	8d 8b       	std	Y+21, r24	; 0x15

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    258c:	8b a1       	ldd	r24, Y+35	; 0x23
    258e:	9c a1       	ldd	r25, Y+36	; 0x24
    2590:	9a 83       	std	Y+2, r25	; 0x02
    2592:	89 83       	std	Y+1, r24	; 0x01
    2594:	61 c3       	rjmp	.+1730   	; 0x2c58 <LCD_XYPrintf+0x702>
		ch = *ptr;
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	9a 81       	ldd	r25, Y+2	; 0x02
    259a:	fc 01       	movw	r30, r24
    259c:	80 81       	ld	r24, Z
    259e:	89 87       	std	Y+9, r24	; 0x09
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
    25a0:	89 85       	ldd	r24, Y+9	; 0x09
    25a2:	85 32       	cpi	r24, 0x25	; 37
    25a4:	09 f0       	breq	.+2      	; 0x25a8 <LCD_XYPrintf+0x52>
    25a6:	3a c3       	rjmp	.+1652   	; 0x2c1c <LCD_XYPrintf+0x6c6>
		{
			ptr++;
    25a8:	89 81       	ldd	r24, Y+1	; 0x01
    25aa:	9a 81       	ldd	r25, Y+2	; 0x02
    25ac:	01 96       	adiw	r24, 0x01	; 1
    25ae:	9a 83       	std	Y+2, r25	; 0x02
    25b0:	89 83       	std	Y+1, r24	; 0x01
			ch = *ptr;
    25b2:	89 81       	ldd	r24, Y+1	; 0x01
    25b4:	9a 81       	ldd	r25, Y+2	; 0x02
    25b6:	fc 01       	movw	r30, r24
    25b8:	80 81       	ld	r24, Z
    25ba:	89 87       	std	Y+9, r24	; 0x09
			if ((ch >= 0x30) && (ch <= 0x39)) {
    25bc:	89 85       	ldd	r24, Y+9	; 0x09
    25be:	80 33       	cpi	r24, 0x30	; 48
    25c0:	00 f1       	brcs	.+64     	; 0x2602 <LCD_XYPrintf+0xac>
    25c2:	89 85       	ldd	r24, Y+9	; 0x09
    25c4:	8a 33       	cpi	r24, 0x3A	; 58
    25c6:	e8 f4       	brcc	.+58     	; 0x2602 <LCD_XYPrintf+0xac>
				v_numOfDigitsToDisp_u8 = 0;
    25c8:	1a 86       	std	Y+10, r1	; 0x0a
				while ((ch >= 0x30) && (ch <= 0x39)) {
    25ca:	14 c0       	rjmp	.+40     	; 0x25f4 <LCD_XYPrintf+0x9e>
					v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10)
    25cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    25ce:	88 0f       	add	r24, r24
    25d0:	98 2f       	mov	r25, r24
    25d2:	99 0f       	add	r25, r25
    25d4:	99 0f       	add	r25, r25
    25d6:	98 0f       	add	r25, r24
    25d8:	89 85       	ldd	r24, Y+9	; 0x09
    25da:	89 0f       	add	r24, r25
    25dc:	80 53       	subi	r24, 0x30	; 48
    25de:	8a 87       	std	Y+10, r24	; 0x0a
							+ (ch - 0x30);
					ptr++;
    25e0:	89 81       	ldd	r24, Y+1	; 0x01
    25e2:	9a 81       	ldd	r25, Y+2	; 0x02
    25e4:	01 96       	adiw	r24, 0x01	; 1
    25e6:	9a 83       	std	Y+2, r25	; 0x02
    25e8:	89 83       	std	Y+1, r24	; 0x01
					ch = *ptr;
    25ea:	89 81       	ldd	r24, Y+1	; 0x01
    25ec:	9a 81       	ldd	r25, Y+2	; 0x02
    25ee:	fc 01       	movw	r30, r24
    25f0:	80 81       	ld	r24, Z
    25f2:	89 87       	std	Y+9, r24	; 0x09
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
				v_numOfDigitsToDisp_u8 = 0;
				while ((ch >= 0x30) && (ch <= 0x39)) {
    25f4:	89 85       	ldd	r24, Y+9	; 0x09
    25f6:	80 33       	cpi	r24, 0x30	; 48
    25f8:	18 f0       	brcs	.+6      	; 0x2600 <LCD_XYPrintf+0xaa>
    25fa:	89 85       	ldd	r24, Y+9	; 0x09
    25fc:	8a 33       	cpi	r24, 0x3A	; 58
    25fe:	30 f3       	brcs	.-52     	; 0x25cc <LCD_XYPrintf+0x76>
		ch = *ptr;
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
    2600:	02 c0       	rjmp	.+4      	; 0x2606 <LCD_XYPrintf+0xb0>
							+ (ch - 0x30);
					ptr++;
					ch = *ptr;
				}
			} else {
				v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    2602:	8f ef       	ldi	r24, 0xFF	; 255
    2604:	8a 87       	std	Y+10, r24	; 0x0a
			}

			switch (ch) /* Decode the type of the argument */
    2606:	89 85       	ldd	r24, Y+9	; 0x09
    2608:	88 2f       	mov	r24, r24
    260a:	90 e0       	ldi	r25, 0x00	; 0
    260c:	aa 27       	eor	r26, r26
    260e:	97 fd       	sbrc	r25, 7
    2610:	a0 95       	com	r26
    2612:	ba 2f       	mov	r27, r26
    2614:	45 e2       	ldi	r20, 0x25	; 37
    2616:	50 e0       	ldi	r21, 0x00	; 0
    2618:	28 e5       	ldi	r18, 0x58	; 88
    261a:	30 e0       	ldi	r19, 0x00	; 0
    261c:	84 1b       	sub	r24, r20
    261e:	95 0b       	sbc	r25, r21
    2620:	28 17       	cp	r18, r24
    2622:	39 07       	cpc	r19, r25
    2624:	08 f4       	brcc	.+2      	; 0x2628 <LCD_XYPrintf+0xd2>
    2626:	13 c3       	rjmp	.+1574   	; 0x2c4e <LCD_XYPrintf+0x6f8>
    2628:	8d 57       	subi	r24, 0x7D	; 125
    262a:	9f 4f       	sbci	r25, 0xFF	; 255
    262c:	fc 01       	movw	r30, r24
    262e:	0c 94 2a 1f 	jmp	0x3e54	; 0x3e54 <__tablejump2__>
			{
			case '>':
				LCD_PrintSymbol(1);
    2632:	81 e0       	ldi	r24, 0x01	; 1
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '>';
    263a:	8b 89       	ldd	r24, Y+19	; 0x13
    263c:	9c 89       	ldd	r25, Y+20	; 0x14
    263e:	29 a1       	ldd	r18, Y+33	; 0x21
    2640:	3a a1       	ldd	r19, Y+34	; 0x22
    2642:	22 95       	swap	r18
    2644:	32 95       	swap	r19
    2646:	30 7f       	andi	r19, 0xF0	; 240
    2648:	32 27       	eor	r19, r18
    264a:	20 7f       	andi	r18, 0xF0	; 240
    264c:	32 27       	eor	r19, r18
    264e:	82 0f       	add	r24, r18
    2650:	93 1f       	adc	r25, r19
    2652:	84 50       	subi	r24, 0x04	; 4
    2654:	9f 4f       	sbci	r25, 0xFF	; 255
    2656:	2e e3       	ldi	r18, 0x3E	; 62
    2658:	fc 01       	movw	r30, r24
    265a:	20 83       	st	Z, r18
				tmpX++;
    265c:	8b 89       	ldd	r24, Y+19	; 0x13
    265e:	9c 89       	ldd	r25, Y+20	; 0x14
    2660:	01 96       	adiw	r24, 0x01	; 1
    2662:	9c 8b       	std	Y+20, r25	; 0x14
    2664:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2666:	d9 c2       	rjmp	.+1458   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case '<':
				LCD_PrintSymbol(2);
    2668:	82 e0       	ldi	r24, 0x02	; 2
    266a:	90 e0       	ldi	r25, 0x00	; 0
    266c:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '<';
    2670:	8b 89       	ldd	r24, Y+19	; 0x13
    2672:	9c 89       	ldd	r25, Y+20	; 0x14
    2674:	29 a1       	ldd	r18, Y+33	; 0x21
    2676:	3a a1       	ldd	r19, Y+34	; 0x22
    2678:	22 95       	swap	r18
    267a:	32 95       	swap	r19
    267c:	30 7f       	andi	r19, 0xF0	; 240
    267e:	32 27       	eor	r19, r18
    2680:	20 7f       	andi	r18, 0xF0	; 240
    2682:	32 27       	eor	r19, r18
    2684:	82 0f       	add	r24, r18
    2686:	93 1f       	adc	r25, r19
    2688:	84 50       	subi	r24, 0x04	; 4
    268a:	9f 4f       	sbci	r25, 0xFF	; 255
    268c:	2c e3       	ldi	r18, 0x3C	; 60
    268e:	fc 01       	movw	r30, r24
    2690:	20 83       	st	Z, r18
				tmpX++;
    2692:	8b 89       	ldd	r24, Y+19	; 0x13
    2694:	9c 89       	ldd	r25, Y+20	; 0x14
    2696:	01 96       	adiw	r24, 0x01	; 1
    2698:	9c 8b       	std	Y+20, r25	; 0x14
    269a:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    269c:	be c2       	rjmp	.+1404   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case '|':
				LCD_PrintSymbol(3);
    269e:	83 e0       	ldi	r24, 0x03	; 3
    26a0:	90 e0       	ldi	r25, 0x00	; 0
    26a2:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '|';
    26a6:	8b 89       	ldd	r24, Y+19	; 0x13
    26a8:	9c 89       	ldd	r25, Y+20	; 0x14
    26aa:	29 a1       	ldd	r18, Y+33	; 0x21
    26ac:	3a a1       	ldd	r19, Y+34	; 0x22
    26ae:	22 95       	swap	r18
    26b0:	32 95       	swap	r19
    26b2:	30 7f       	andi	r19, 0xF0	; 240
    26b4:	32 27       	eor	r19, r18
    26b6:	20 7f       	andi	r18, 0xF0	; 240
    26b8:	32 27       	eor	r19, r18
    26ba:	82 0f       	add	r24, r18
    26bc:	93 1f       	adc	r25, r19
    26be:	84 50       	subi	r24, 0x04	; 4
    26c0:	9f 4f       	sbci	r25, 0xFF	; 255
    26c2:	2c e7       	ldi	r18, 0x7C	; 124
    26c4:	fc 01       	movw	r30, r24
    26c6:	20 83       	st	Z, r18
				tmpX++;
    26c8:	8b 89       	ldd	r24, Y+19	; 0x13
    26ca:	9c 89       	ldd	r25, Y+20	; 0x14
    26cc:	01 96       	adiw	r24, 0x01	; 1
    26ce:	9c 8b       	std	Y+20, r25	; 0x14
    26d0:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    26d2:	a3 c2       	rjmp	.+1350   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case '{':
				LCD_PrintSymbol(4);
    26d4:	84 e0       	ldi	r24, 0x04	; 4
    26d6:	90 e0       	ldi	r25, 0x00	; 0
    26d8:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '{';
    26dc:	8b 89       	ldd	r24, Y+19	; 0x13
    26de:	9c 89       	ldd	r25, Y+20	; 0x14
    26e0:	29 a1       	ldd	r18, Y+33	; 0x21
    26e2:	3a a1       	ldd	r19, Y+34	; 0x22
    26e4:	22 95       	swap	r18
    26e6:	32 95       	swap	r19
    26e8:	30 7f       	andi	r19, 0xF0	; 240
    26ea:	32 27       	eor	r19, r18
    26ec:	20 7f       	andi	r18, 0xF0	; 240
    26ee:	32 27       	eor	r19, r18
    26f0:	82 0f       	add	r24, r18
    26f2:	93 1f       	adc	r25, r19
    26f4:	84 50       	subi	r24, 0x04	; 4
    26f6:	9f 4f       	sbci	r25, 0xFF	; 255
    26f8:	2b e7       	ldi	r18, 0x7B	; 123
    26fa:	fc 01       	movw	r30, r24
    26fc:	20 83       	st	Z, r18
				tmpX++;
    26fe:	8b 89       	ldd	r24, Y+19	; 0x13
    2700:	9c 89       	ldd	r25, Y+20	; 0x14
    2702:	01 96       	adiw	r24, 0x01	; 1
    2704:	9c 8b       	std	Y+20, r25	; 0x14
    2706:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2708:	88 c2       	rjmp	.+1296   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case '}':
				LCD_PrintSymbol(5);
    270a:	85 e0       	ldi	r24, 0x05	; 5
    270c:	90 e0       	ldi	r25, 0x00	; 0
    270e:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = '}';
    2712:	8b 89       	ldd	r24, Y+19	; 0x13
    2714:	9c 89       	ldd	r25, Y+20	; 0x14
    2716:	29 a1       	ldd	r18, Y+33	; 0x21
    2718:	3a a1       	ldd	r19, Y+34	; 0x22
    271a:	22 95       	swap	r18
    271c:	32 95       	swap	r19
    271e:	30 7f       	andi	r19, 0xF0	; 240
    2720:	32 27       	eor	r19, r18
    2722:	20 7f       	andi	r18, 0xF0	; 240
    2724:	32 27       	eor	r19, r18
    2726:	82 0f       	add	r24, r18
    2728:	93 1f       	adc	r25, r19
    272a:	84 50       	subi	r24, 0x04	; 4
    272c:	9f 4f       	sbci	r25, 0xFF	; 255
    272e:	2d e7       	ldi	r18, 0x7D	; 125
    2730:	fc 01       	movw	r30, r24
    2732:	20 83       	st	Z, r18
				tmpX++;
    2734:	8b 89       	ldd	r24, Y+19	; 0x13
    2736:	9c 89       	ldd	r25, Y+20	; 0x14
    2738:	01 96       	adiw	r24, 0x01	; 1
    273a:	9c 8b       	std	Y+20, r25	; 0x14
    273c:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    273e:	6d c2       	rjmp	.+1242   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case ',':
				LCD_PrintSymbol(6);
    2740:	86 e0       	ldi	r24, 0x06	; 6
    2742:	90 e0       	ldi	r25, 0x00	; 0
    2744:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ',';
    2748:	8b 89       	ldd	r24, Y+19	; 0x13
    274a:	9c 89       	ldd	r25, Y+20	; 0x14
    274c:	29 a1       	ldd	r18, Y+33	; 0x21
    274e:	3a a1       	ldd	r19, Y+34	; 0x22
    2750:	22 95       	swap	r18
    2752:	32 95       	swap	r19
    2754:	30 7f       	andi	r19, 0xF0	; 240
    2756:	32 27       	eor	r19, r18
    2758:	20 7f       	andi	r18, 0xF0	; 240
    275a:	32 27       	eor	r19, r18
    275c:	82 0f       	add	r24, r18
    275e:	93 1f       	adc	r25, r19
    2760:	84 50       	subi	r24, 0x04	; 4
    2762:	9f 4f       	sbci	r25, 0xFF	; 255
    2764:	2c e2       	ldi	r18, 0x2C	; 44
    2766:	fc 01       	movw	r30, r24
    2768:	20 83       	st	Z, r18
				tmpX++;
    276a:	8b 89       	ldd	r24, Y+19	; 0x13
    276c:	9c 89       	ldd	r25, Y+20	; 0x14
    276e:	01 96       	adiw	r24, 0x01	; 1
    2770:	9c 8b       	std	Y+20, r25	; 0x14
    2772:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2774:	52 c2       	rjmp	.+1188   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case ':':
				LCD_PrintSymbol(7);
    2776:	87 e0       	ldi	r24, 0x07	; 7
    2778:	90 e0       	ldi	r25, 0x00	; 0
    277a:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ':';
    277e:	8b 89       	ldd	r24, Y+19	; 0x13
    2780:	9c 89       	ldd	r25, Y+20	; 0x14
    2782:	29 a1       	ldd	r18, Y+33	; 0x21
    2784:	3a a1       	ldd	r19, Y+34	; 0x22
    2786:	22 95       	swap	r18
    2788:	32 95       	swap	r19
    278a:	30 7f       	andi	r19, 0xF0	; 240
    278c:	32 27       	eor	r19, r18
    278e:	20 7f       	andi	r18, 0xF0	; 240
    2790:	32 27       	eor	r19, r18
    2792:	82 0f       	add	r24, r18
    2794:	93 1f       	adc	r25, r19
    2796:	84 50       	subi	r24, 0x04	; 4
    2798:	9f 4f       	sbci	r25, 0xFF	; 255
    279a:	2a e3       	ldi	r18, 0x3A	; 58
    279c:	fc 01       	movw	r30, r24
    279e:	20 83       	st	Z, r18
				tmpX++;
    27a0:	8b 89       	ldd	r24, Y+19	; 0x13
    27a2:	9c 89       	ldd	r25, Y+20	; 0x14
    27a4:	01 96       	adiw	r24, 0x01	; 1
    27a6:	9c 8b       	std	Y+20, r25	; 0x14
    27a8:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    27aa:	37 c2       	rjmp	.+1134   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case ';':
				LCD_PrintSymbol(8);
    27ac:	88 e0       	ldi	r24, 0x08	; 8
    27ae:	90 e0       	ldi	r25, 0x00	; 0
    27b0:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				LCD_BUFFOR[y][tmpX] = ';';
    27b4:	8b 89       	ldd	r24, Y+19	; 0x13
    27b6:	9c 89       	ldd	r25, Y+20	; 0x14
    27b8:	29 a1       	ldd	r18, Y+33	; 0x21
    27ba:	3a a1       	ldd	r19, Y+34	; 0x22
    27bc:	22 95       	swap	r18
    27be:	32 95       	swap	r19
    27c0:	30 7f       	andi	r19, 0xF0	; 240
    27c2:	32 27       	eor	r19, r18
    27c4:	20 7f       	andi	r18, 0xF0	; 240
    27c6:	32 27       	eor	r19, r18
    27c8:	82 0f       	add	r24, r18
    27ca:	93 1f       	adc	r25, r19
    27cc:	84 50       	subi	r24, 0x04	; 4
    27ce:	9f 4f       	sbci	r25, 0xFF	; 255
    27d0:	2b e3       	ldi	r18, 0x3B	; 59
    27d2:	fc 01       	movw	r30, r24
    27d4:	20 83       	st	Z, r18
				tmpX++;
    27d6:	8b 89       	ldd	r24, Y+19	; 0x13
    27d8:	9c 89       	ldd	r25, Y+20	; 0x14
    27da:	01 96       	adiw	r24, 0x01	; 1
    27dc:	9c 8b       	std	Y+20, r25	; 0x14
    27de:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    27e0:	1c c2       	rjmp	.+1080   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case '?':
				LCD_PrintBlock();
    27e2:	0e 94 99 1a 	call	0x3532	; 0x3532 <LCD_PrintBlock>
				LCD_BUFFOR[y][tmpX] = '?';
    27e6:	8b 89       	ldd	r24, Y+19	; 0x13
    27e8:	9c 89       	ldd	r25, Y+20	; 0x14
    27ea:	29 a1       	ldd	r18, Y+33	; 0x21
    27ec:	3a a1       	ldd	r19, Y+34	; 0x22
    27ee:	22 95       	swap	r18
    27f0:	32 95       	swap	r19
    27f2:	30 7f       	andi	r19, 0xF0	; 240
    27f4:	32 27       	eor	r19, r18
    27f6:	20 7f       	andi	r18, 0xF0	; 240
    27f8:	32 27       	eor	r19, r18
    27fa:	82 0f       	add	r24, r18
    27fc:	93 1f       	adc	r25, r19
    27fe:	84 50       	subi	r24, 0x04	; 4
    2800:	9f 4f       	sbci	r25, 0xFF	; 255
    2802:	2f e3       	ldi	r18, 0x3F	; 63
    2804:	fc 01       	movw	r30, r24
    2806:	20 83       	st	Z, r18
				tmpX++;
    2808:	8b 89       	ldd	r24, Y+19	; 0x13
    280a:	9c 89       	ldd	r25, Y+20	; 0x14
    280c:	01 96       	adiw	r24, 0x01	; 1
    280e:	9c 8b       	std	Y+20, r25	; 0x14
    2810:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2812:	03 c2       	rjmp	.+1030   	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case '[':
				LCD_PrintLArrow();
    2814:	0e 94 a3 1a 	call	0x3546	; 0x3546 <LCD_PrintLArrow>
				LCD_BUFFOR[y][tmpX] = '[';
    2818:	8b 89       	ldd	r24, Y+19	; 0x13
    281a:	9c 89       	ldd	r25, Y+20	; 0x14
    281c:	29 a1       	ldd	r18, Y+33	; 0x21
    281e:	3a a1       	ldd	r19, Y+34	; 0x22
    2820:	22 95       	swap	r18
    2822:	32 95       	swap	r19
    2824:	30 7f       	andi	r19, 0xF0	; 240
    2826:	32 27       	eor	r19, r18
    2828:	20 7f       	andi	r18, 0xF0	; 240
    282a:	32 27       	eor	r19, r18
    282c:	82 0f       	add	r24, r18
    282e:	93 1f       	adc	r25, r19
    2830:	84 50       	subi	r24, 0x04	; 4
    2832:	9f 4f       	sbci	r25, 0xFF	; 255
    2834:	2b e5       	ldi	r18, 0x5B	; 91
    2836:	fc 01       	movw	r30, r24
    2838:	20 83       	st	Z, r18
				tmpX++;
    283a:	8b 89       	ldd	r24, Y+19	; 0x13
    283c:	9c 89       	ldd	r25, Y+20	; 0x14
    283e:	01 96       	adiw	r24, 0x01	; 1
    2840:	9c 8b       	std	Y+20, r25	; 0x14
    2842:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2844:	ea c1       	rjmp	.+980    	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case ']':
				LCD_PrintRArrow();
    2846:	0e 94 ad 1a 	call	0x355a	; 0x355a <LCD_PrintRArrow>
				LCD_BUFFOR[y][tmpX] = ']';
    284a:	8b 89       	ldd	r24, Y+19	; 0x13
    284c:	9c 89       	ldd	r25, Y+20	; 0x14
    284e:	29 a1       	ldd	r18, Y+33	; 0x21
    2850:	3a a1       	ldd	r19, Y+34	; 0x22
    2852:	22 95       	swap	r18
    2854:	32 95       	swap	r19
    2856:	30 7f       	andi	r19, 0xF0	; 240
    2858:	32 27       	eor	r19, r18
    285a:	20 7f       	andi	r18, 0xF0	; 240
    285c:	32 27       	eor	r19, r18
    285e:	82 0f       	add	r24, r18
    2860:	93 1f       	adc	r25, r19
    2862:	84 50       	subi	r24, 0x04	; 4
    2864:	9f 4f       	sbci	r25, 0xFF	; 255
    2866:	2d e5       	ldi	r18, 0x5D	; 93
    2868:	fc 01       	movw	r30, r24
    286a:	20 83       	st	Z, r18
				tmpX++;
    286c:	8b 89       	ldd	r24, Y+19	; 0x13
    286e:	9c 89       	ldd	r25, Y+20	; 0x14
    2870:	01 96       	adiw	r24, 0x01	; 1
    2872:	9c 8b       	std	Y+20, r25	; 0x14
    2874:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2876:	d1 c1       	rjmp	.+930    	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case '.':
				LCD_PrintDot();
    2878:	0e 94 b7 1a 	call	0x356e	; 0x356e <LCD_PrintDot>
				LCD_BUFFOR[y][tmpX] = '.';
    287c:	8b 89       	ldd	r24, Y+19	; 0x13
    287e:	9c 89       	ldd	r25, Y+20	; 0x14
    2880:	29 a1       	ldd	r18, Y+33	; 0x21
    2882:	3a a1       	ldd	r19, Y+34	; 0x22
    2884:	22 95       	swap	r18
    2886:	32 95       	swap	r19
    2888:	30 7f       	andi	r19, 0xF0	; 240
    288a:	32 27       	eor	r19, r18
    288c:	20 7f       	andi	r18, 0xF0	; 240
    288e:	32 27       	eor	r19, r18
    2890:	82 0f       	add	r24, r18
    2892:	93 1f       	adc	r25, r19
    2894:	84 50       	subi	r24, 0x04	; 4
    2896:	9f 4f       	sbci	r25, 0xFF	; 255
    2898:	2e e2       	ldi	r18, 0x2E	; 46
    289a:	fc 01       	movw	r30, r24
    289c:	20 83       	st	Z, r18
				tmpX++;
    289e:	8b 89       	ldd	r24, Y+19	; 0x13
    28a0:	9c 89       	ldd	r25, Y+20	; 0x14
    28a2:	01 96       	adiw	r24, 0x01	; 1
    28a4:	9c 8b       	std	Y+20, r25	; 0x14
    28a6:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    28a8:	b8 c1       	rjmp	.+880    	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case 'C':
			case 'c': /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    28aa:	8d 89       	ldd	r24, Y+21	; 0x15
    28ac:	9e 89       	ldd	r25, Y+22	; 0x16
    28ae:	9c 01       	movw	r18, r24
    28b0:	2e 5f       	subi	r18, 0xFE	; 254
    28b2:	3f 4f       	sbci	r19, 0xFF	; 255
    28b4:	3e 8b       	std	Y+22, r19	; 0x16
    28b6:	2d 8b       	std	Y+21, r18	; 0x15
    28b8:	fc 01       	movw	r30, r24
    28ba:	80 81       	ld	r24, Z
    28bc:	91 81       	ldd	r25, Z+1	; 0x01
    28be:	89 87       	std	Y+9, r24	; 0x09
				LCD_DisplayChar(ch);
    28c0:	89 85       	ldd	r24, Y+9	; 0x09
    28c2:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
				LCD_BUFFOR[y][tmpX] = ch;
    28c6:	8b 89       	ldd	r24, Y+19	; 0x13
    28c8:	9c 89       	ldd	r25, Y+20	; 0x14
    28ca:	29 a1       	ldd	r18, Y+33	; 0x21
    28cc:	3a a1       	ldd	r19, Y+34	; 0x22
    28ce:	22 95       	swap	r18
    28d0:	32 95       	swap	r19
    28d2:	30 7f       	andi	r19, 0xF0	; 240
    28d4:	32 27       	eor	r19, r18
    28d6:	20 7f       	andi	r18, 0xF0	; 240
    28d8:	32 27       	eor	r19, r18
    28da:	82 0f       	add	r24, r18
    28dc:	93 1f       	adc	r25, r19
    28de:	84 50       	subi	r24, 0x04	; 4
    28e0:	9f 4f       	sbci	r25, 0xFF	; 255
    28e2:	29 85       	ldd	r18, Y+9	; 0x09
    28e4:	fc 01       	movw	r30, r24
    28e6:	20 83       	st	Z, r18
				tmpX++;
    28e8:	8b 89       	ldd	r24, Y+19	; 0x13
    28ea:	9c 89       	ldd	r25, Y+20	; 0x14
    28ec:	01 96       	adiw	r24, 0x01	; 1
    28ee:	9c 8b       	std	Y+20, r25	; 0x14
    28f0:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    28f2:	93 c1       	rjmp	.+806    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'd': /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, int);
    28f4:	8d 89       	ldd	r24, Y+21	; 0x15
    28f6:	9e 89       	ldd	r25, Y+22	; 0x16
    28f8:	9c 01       	movw	r18, r24
    28fa:	2e 5f       	subi	r18, 0xFE	; 254
    28fc:	3f 4f       	sbci	r19, 0xFF	; 255
    28fe:	3e 8b       	std	Y+22, r19	; 0x16
    2900:	2d 8b       	std	Y+21, r18	; 0x15
    2902:	fc 01       	movw	r30, r24
    2904:	80 81       	ld	r24, Z
    2906:	91 81       	ldd	r25, Z+1	; 0x01
    2908:	9c 83       	std	Y+4, r25	; 0x04
    290a:	8b 83       	std	Y+3, r24	; 0x03
				if (v_num_s16 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    290c:	8b 81       	ldd	r24, Y+3	; 0x03
    290e:	9c 81       	ldd	r25, Y+4	; 0x04
    2910:	99 23       	and	r25, r25
    2912:	04 f5       	brge	.+64     	; 0x2954 <LCD_XYPrintf+0x3fe>
					v_num_s16 = -v_num_s16;
    2914:	8b 81       	ldd	r24, Y+3	; 0x03
    2916:	9c 81       	ldd	r25, Y+4	; 0x04
    2918:	91 95       	neg	r25
    291a:	81 95       	neg	r24
    291c:	91 09       	sbc	r25, r1
    291e:	9c 83       	std	Y+4, r25	; 0x04
    2920:	8b 83       	std	Y+3, r24	; 0x03
					LCD_DisplayChar('-');
    2922:	8d e2       	ldi	r24, 0x2D	; 45
    2924:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
					LCD_BUFFOR[y][tmpX] = '-';
    2928:	8b 89       	ldd	r24, Y+19	; 0x13
    292a:	9c 89       	ldd	r25, Y+20	; 0x14
    292c:	29 a1       	ldd	r18, Y+33	; 0x21
    292e:	3a a1       	ldd	r19, Y+34	; 0x22
    2930:	22 95       	swap	r18
    2932:	32 95       	swap	r19
    2934:	30 7f       	andi	r19, 0xF0	; 240
    2936:	32 27       	eor	r19, r18
    2938:	20 7f       	andi	r18, 0xF0	; 240
    293a:	32 27       	eor	r19, r18
    293c:	82 0f       	add	r24, r18
    293e:	93 1f       	adc	r25, r19
    2940:	84 50       	subi	r24, 0x04	; 4
    2942:	9f 4f       	sbci	r25, 0xFF	; 255
    2944:	2d e2       	ldi	r18, 0x2D	; 45
    2946:	fc 01       	movw	r30, r24
    2948:	20 83       	st	Z, r18
					tmpX++;
    294a:	8b 89       	ldd	r24, Y+19	; 0x13
    294c:	9c 89       	ldd	r25, Y+20	; 0x14
    294e:	01 96       	adiw	r24, 0x01	; 1
    2950:	9c 8b       	std	Y+20, r25	; 0x14
    2952:	8b 8b       	std	Y+19, r24	; 0x13
				}
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_s16,
    2954:	8b 81       	ldd	r24, Y+3	; 0x03
    2956:	9c 81       	ldd	r25, Y+4	; 0x04
    2958:	aa 27       	eor	r26, r26
    295a:	97 fd       	sbrc	r25, 7
    295c:	a0 95       	com	r26
    295e:	ba 2f       	mov	r27, r26
    2960:	49 a1       	ldd	r20, Y+33	; 0x21
    2962:	5a a1       	ldd	r21, Y+34	; 0x22
    2964:	9e 01       	movw	r18, r28
    2966:	2d 5e       	subi	r18, 0xED	; 237
    2968:	3f 4f       	sbci	r19, 0xFF	; 255
    296a:	7a 01       	movw	r14, r20
    296c:	89 01       	movw	r16, r18
    296e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2970:	ac 01       	movw	r20, r24
    2972:	bd 01       	movw	r22, r26
    2974:	8a e0       	ldi	r24, 0x0A	; 10
    2976:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    297a:	4f c1       	rjmp	.+670    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'D': /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);
    297c:	8d 89       	ldd	r24, Y+21	; 0x15
    297e:	9e 89       	ldd	r25, Y+22	; 0x16
    2980:	9c 01       	movw	r18, r24
    2982:	2c 5f       	subi	r18, 0xFC	; 252
    2984:	3f 4f       	sbci	r19, 0xFF	; 255
    2986:	3e 8b       	std	Y+22, r19	; 0x16
    2988:	2d 8b       	std	Y+21, r18	; 0x15
    298a:	fc 01       	movw	r30, r24
    298c:	80 81       	ld	r24, Z
    298e:	91 81       	ldd	r25, Z+1	; 0x01
    2990:	a2 81       	ldd	r26, Z+2	; 0x02
    2992:	b3 81       	ldd	r27, Z+3	; 0x03
    2994:	8d 83       	std	Y+5, r24	; 0x05
    2996:	9e 83       	std	Y+6, r25	; 0x06
    2998:	af 83       	std	Y+7, r26	; 0x07
    299a:	b8 87       	std	Y+8, r27	; 0x08
				if (v_num_s32 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    299c:	8d 81       	ldd	r24, Y+5	; 0x05
    299e:	9e 81       	ldd	r25, Y+6	; 0x06
    29a0:	af 81       	ldd	r26, Y+7	; 0x07
    29a2:	b8 85       	ldd	r27, Y+8	; 0x08
    29a4:	bb 23       	and	r27, r27
    29a6:	44 f5       	brge	.+80     	; 0x29f8 <LCD_XYPrintf+0x4a2>
					v_num_s32 = -v_num_s32;
    29a8:	8d 81       	ldd	r24, Y+5	; 0x05
    29aa:	9e 81       	ldd	r25, Y+6	; 0x06
    29ac:	af 81       	ldd	r26, Y+7	; 0x07
    29ae:	b8 85       	ldd	r27, Y+8	; 0x08
    29b0:	b0 95       	com	r27
    29b2:	a0 95       	com	r26
    29b4:	90 95       	com	r25
    29b6:	81 95       	neg	r24
    29b8:	9f 4f       	sbci	r25, 0xFF	; 255
    29ba:	af 4f       	sbci	r26, 0xFF	; 255
    29bc:	bf 4f       	sbci	r27, 0xFF	; 255
    29be:	8d 83       	std	Y+5, r24	; 0x05
    29c0:	9e 83       	std	Y+6, r25	; 0x06
    29c2:	af 83       	std	Y+7, r26	; 0x07
    29c4:	b8 87       	std	Y+8, r27	; 0x08
					LCD_DisplayChar('-');
    29c6:	8d e2       	ldi	r24, 0x2D	; 45
    29c8:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
					LCD_BUFFOR[y][tmpX] = '-';
    29cc:	8b 89       	ldd	r24, Y+19	; 0x13
    29ce:	9c 89       	ldd	r25, Y+20	; 0x14
    29d0:	29 a1       	ldd	r18, Y+33	; 0x21
    29d2:	3a a1       	ldd	r19, Y+34	; 0x22
    29d4:	22 95       	swap	r18
    29d6:	32 95       	swap	r19
    29d8:	30 7f       	andi	r19, 0xF0	; 240
    29da:	32 27       	eor	r19, r18
    29dc:	20 7f       	andi	r18, 0xF0	; 240
    29de:	32 27       	eor	r19, r18
    29e0:	82 0f       	add	r24, r18
    29e2:	93 1f       	adc	r25, r19
    29e4:	84 50       	subi	r24, 0x04	; 4
    29e6:	9f 4f       	sbci	r25, 0xFF	; 255
    29e8:	2d e2       	ldi	r18, 0x2D	; 45
    29ea:	fc 01       	movw	r30, r24
    29ec:	20 83       	st	Z, r18
					tmpX++;
    29ee:	8b 89       	ldd	r24, Y+19	; 0x13
    29f0:	9c 89       	ldd	r25, Y+20	; 0x14
    29f2:	01 96       	adiw	r24, 0x01	; 1
    29f4:	9c 8b       	std	Y+20, r25	; 0x14
    29f6:	8b 8b       	std	Y+19, r24	; 0x13
				}
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_s32,
    29f8:	8d 81       	ldd	r24, Y+5	; 0x05
    29fa:	9e 81       	ldd	r25, Y+6	; 0x06
    29fc:	af 81       	ldd	r26, Y+7	; 0x07
    29fe:	b8 85       	ldd	r27, Y+8	; 0x08
    2a00:	49 a1       	ldd	r20, Y+33	; 0x21
    2a02:	5a a1       	ldd	r21, Y+34	; 0x22
    2a04:	9e 01       	movw	r18, r28
    2a06:	2d 5e       	subi	r18, 0xED	; 237
    2a08:	3f 4f       	sbci	r19, 0xFF	; 255
    2a0a:	7a 01       	movw	r14, r20
    2a0c:	89 01       	movw	r16, r18
    2a0e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2a10:	ac 01       	movw	r20, r24
    2a12:	bd 01       	movw	r22, r26
    2a14:	8a e0       	ldi	r24, 0x0A	; 10
    2a16:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2a1a:	ff c0       	rjmp	.+510    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'u': /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, int);
    2a1c:	8d 89       	ldd	r24, Y+21	; 0x15
    2a1e:	9e 89       	ldd	r25, Y+22	; 0x16
    2a20:	9c 01       	movw	r18, r24
    2a22:	2e 5f       	subi	r18, 0xFE	; 254
    2a24:	3f 4f       	sbci	r19, 0xFF	; 255
    2a26:	3e 8b       	std	Y+22, r19	; 0x16
    2a28:	2d 8b       	std	Y+21, r18	; 0x15
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	80 81       	ld	r24, Z
    2a2e:	91 81       	ldd	r25, Z+1	; 0x01
    2a30:	9c 87       	std	Y+12, r25	; 0x0c
    2a32:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_u16,
    2a34:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a36:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a38:	cc 01       	movw	r24, r24
    2a3a:	a0 e0       	ldi	r26, 0x00	; 0
    2a3c:	b0 e0       	ldi	r27, 0x00	; 0
    2a3e:	49 a1       	ldd	r20, Y+33	; 0x21
    2a40:	5a a1       	ldd	r21, Y+34	; 0x22
    2a42:	9e 01       	movw	r18, r28
    2a44:	2d 5e       	subi	r18, 0xED	; 237
    2a46:	3f 4f       	sbci	r19, 0xFF	; 255
    2a48:	7a 01       	movw	r14, r20
    2a4a:	89 01       	movw	r16, r18
    2a4c:	2a 85       	ldd	r18, Y+10	; 0x0a
    2a4e:	ac 01       	movw	r20, r24
    2a50:	bd 01       	movw	r22, r26
    2a52:	8a e0       	ldi	r24, 0x0A	; 10
    2a54:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2a58:	e0 c0       	rjmp	.+448    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'U': /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);
    2a5a:	8d 89       	ldd	r24, Y+21	; 0x15
    2a5c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a5e:	9c 01       	movw	r18, r24
    2a60:	2c 5f       	subi	r18, 0xFC	; 252
    2a62:	3f 4f       	sbci	r19, 0xFF	; 255
    2a64:	3e 8b       	std	Y+22, r19	; 0x16
    2a66:	2d 8b       	std	Y+21, r18	; 0x15
    2a68:	fc 01       	movw	r30, r24
    2a6a:	80 81       	ld	r24, Z
    2a6c:	91 81       	ldd	r25, Z+1	; 0x01
    2a6e:	a2 81       	ldd	r26, Z+2	; 0x02
    2a70:	b3 81       	ldd	r27, Z+3	; 0x03
    2a72:	8d 87       	std	Y+13, r24	; 0x0d
    2a74:	9e 87       	std	Y+14, r25	; 0x0e
    2a76:	af 87       	std	Y+15, r26	; 0x0f
    2a78:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumberWithAddingToBuffor(C_DECIMAL_U8, v_num_u32,
    2a7a:	49 a1       	ldd	r20, Y+33	; 0x21
    2a7c:	5a a1       	ldd	r21, Y+34	; 0x22
    2a7e:	9e 01       	movw	r18, r28
    2a80:	2d 5e       	subi	r18, 0xED	; 237
    2a82:	3f 4f       	sbci	r19, 0xFF	; 255
    2a84:	8d 85       	ldd	r24, Y+13	; 0x0d
    2a86:	9e 85       	ldd	r25, Y+14	; 0x0e
    2a88:	af 85       	ldd	r26, Y+15	; 0x0f
    2a8a:	b8 89       	ldd	r27, Y+16	; 0x10
    2a8c:	7a 01       	movw	r14, r20
    2a8e:	89 01       	movw	r16, r18
    2a90:	2a 85       	ldd	r18, Y+10	; 0x0a
    2a92:	ac 01       	movw	r20, r24
    2a94:	bd 01       	movw	r22, r26
    2a96:	8a e0       	ldi	r24, 0x0A	; 10
    2a98:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2a9c:	be c0       	rjmp	.+380    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'x': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, int);
    2a9e:	8d 89       	ldd	r24, Y+21	; 0x15
    2aa0:	9e 89       	ldd	r25, Y+22	; 0x16
    2aa2:	9c 01       	movw	r18, r24
    2aa4:	2e 5f       	subi	r18, 0xFE	; 254
    2aa6:	3f 4f       	sbci	r19, 0xFF	; 255
    2aa8:	3e 8b       	std	Y+22, r19	; 0x16
    2aaa:	2d 8b       	std	Y+21, r18	; 0x15
    2aac:	fc 01       	movw	r30, r24
    2aae:	80 81       	ld	r24, Z
    2ab0:	91 81       	ldd	r25, Z+1	; 0x01
    2ab2:	9c 87       	std	Y+12, r25	; 0x0c
    2ab4:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumberWithAddingToBuffor(C_HEX_U8, v_num_u16,
    2ab6:	8b 85       	ldd	r24, Y+11	; 0x0b
    2ab8:	9c 85       	ldd	r25, Y+12	; 0x0c
    2aba:	cc 01       	movw	r24, r24
    2abc:	a0 e0       	ldi	r26, 0x00	; 0
    2abe:	b0 e0       	ldi	r27, 0x00	; 0
    2ac0:	49 a1       	ldd	r20, Y+33	; 0x21
    2ac2:	5a a1       	ldd	r21, Y+34	; 0x22
    2ac4:	9e 01       	movw	r18, r28
    2ac6:	2d 5e       	subi	r18, 0xED	; 237
    2ac8:	3f 4f       	sbci	r19, 0xFF	; 255
    2aca:	7a 01       	movw	r14, r20
    2acc:	89 01       	movw	r16, r18
    2ace:	2a 85       	ldd	r18, Y+10	; 0x0a
    2ad0:	ac 01       	movw	r20, r24
    2ad2:	bd 01       	movw	r22, r26
    2ad4:	80 e1       	ldi	r24, 0x10	; 16
    2ad6:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2ada:	9f c0       	rjmp	.+318    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'X': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);
    2adc:	8d 89       	ldd	r24, Y+21	; 0x15
    2ade:	9e 89       	ldd	r25, Y+22	; 0x16
    2ae0:	9c 01       	movw	r18, r24
    2ae2:	2c 5f       	subi	r18, 0xFC	; 252
    2ae4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ae6:	3e 8b       	std	Y+22, r19	; 0x16
    2ae8:	2d 8b       	std	Y+21, r18	; 0x15
    2aea:	fc 01       	movw	r30, r24
    2aec:	80 81       	ld	r24, Z
    2aee:	91 81       	ldd	r25, Z+1	; 0x01
    2af0:	a2 81       	ldd	r26, Z+2	; 0x02
    2af2:	b3 81       	ldd	r27, Z+3	; 0x03
    2af4:	8d 87       	std	Y+13, r24	; 0x0d
    2af6:	9e 87       	std	Y+14, r25	; 0x0e
    2af8:	af 87       	std	Y+15, r26	; 0x0f
    2afa:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumberWithAddingToBuffor(C_HEX_U8, v_num_u32,
    2afc:	49 a1       	ldd	r20, Y+33	; 0x21
    2afe:	5a a1       	ldd	r21, Y+34	; 0x22
    2b00:	9e 01       	movw	r18, r28
    2b02:	2d 5e       	subi	r18, 0xED	; 237
    2b04:	3f 4f       	sbci	r19, 0xFF	; 255
    2b06:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b08:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b0a:	af 85       	ldd	r26, Y+15	; 0x0f
    2b0c:	b8 89       	ldd	r27, Y+16	; 0x10
    2b0e:	7a 01       	movw	r14, r20
    2b10:	89 01       	movw	r16, r18
    2b12:	2a 85       	ldd	r18, Y+10	; 0x0a
    2b14:	ac 01       	movw	r20, r24
    2b16:	bd 01       	movw	r22, r26
    2b18:	80 e1       	ldi	r24, 0x10	; 16
    2b1a:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2b1e:	7d c0       	rjmp	.+250    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'b': /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, int);
    2b20:	8d 89       	ldd	r24, Y+21	; 0x15
    2b22:	9e 89       	ldd	r25, Y+22	; 0x16
    2b24:	9c 01       	movw	r18, r24
    2b26:	2e 5f       	subi	r18, 0xFE	; 254
    2b28:	3f 4f       	sbci	r19, 0xFF	; 255
    2b2a:	3e 8b       	std	Y+22, r19	; 0x16
    2b2c:	2d 8b       	std	Y+21, r18	; 0x15
    2b2e:	fc 01       	movw	r30, r24
    2b30:	80 81       	ld	r24, Z
    2b32:	91 81       	ldd	r25, Z+1	; 0x01
    2b34:	9c 87       	std	Y+12, r25	; 0x0c
    2b36:	8b 87       	std	Y+11, r24	; 0x0b
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    2b38:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b3a:	8f 3f       	cpi	r24, 0xFF	; 255
    2b3c:	11 f4       	brne	.+4      	; 0x2b42 <LCD_XYPrintf+0x5ec>
					v_numOfDigitsToDisp_u8 = 16;
    2b3e:	80 e1       	ldi	r24, 0x10	; 16
    2b40:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumberWithAddingToBuffor(C_BINARY_U8, v_num_u16,
    2b42:	8b 85       	ldd	r24, Y+11	; 0x0b
    2b44:	9c 85       	ldd	r25, Y+12	; 0x0c
    2b46:	cc 01       	movw	r24, r24
    2b48:	a0 e0       	ldi	r26, 0x00	; 0
    2b4a:	b0 e0       	ldi	r27, 0x00	; 0
    2b4c:	49 a1       	ldd	r20, Y+33	; 0x21
    2b4e:	5a a1       	ldd	r21, Y+34	; 0x22
    2b50:	9e 01       	movw	r18, r28
    2b52:	2d 5e       	subi	r18, 0xED	; 237
    2b54:	3f 4f       	sbci	r19, 0xFF	; 255
    2b56:	7a 01       	movw	r14, r20
    2b58:	89 01       	movw	r16, r18
    2b5a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2b5c:	ac 01       	movw	r20, r24
    2b5e:	bd 01       	movw	r22, r26
    2b60:	82 e0       	ldi	r24, 0x02	; 2
    2b62:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2b66:	59 c0       	rjmp	.+178    	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case 'B': /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);
    2b68:	8d 89       	ldd	r24, Y+21	; 0x15
    2b6a:	9e 89       	ldd	r25, Y+22	; 0x16
    2b6c:	9c 01       	movw	r18, r24
    2b6e:	2c 5f       	subi	r18, 0xFC	; 252
    2b70:	3f 4f       	sbci	r19, 0xFF	; 255
    2b72:	3e 8b       	std	Y+22, r19	; 0x16
    2b74:	2d 8b       	std	Y+21, r18	; 0x15
    2b76:	fc 01       	movw	r30, r24
    2b78:	80 81       	ld	r24, Z
    2b7a:	91 81       	ldd	r25, Z+1	; 0x01
    2b7c:	a2 81       	ldd	r26, Z+2	; 0x02
    2b7e:	b3 81       	ldd	r27, Z+3	; 0x03
    2b80:	8d 87       	std	Y+13, r24	; 0x0d
    2b82:	9e 87       	std	Y+14, r25	; 0x0e
    2b84:	af 87       	std	Y+15, r26	; 0x0f
    2b86:	b8 8b       	std	Y+16, r27	; 0x10
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    2b88:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b8a:	8f 3f       	cpi	r24, 0xFF	; 255
    2b8c:	11 f4       	brne	.+4      	; 0x2b92 <LCD_XYPrintf+0x63c>
					v_numOfDigitsToDisp_u8 = 16;
    2b8e:	80 e1       	ldi	r24, 0x10	; 16
    2b90:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumberWithAddingToBuffor(C_BINARY_U8, v_num_u32,
    2b92:	49 a1       	ldd	r20, Y+33	; 0x21
    2b94:	5a a1       	ldd	r21, Y+34	; 0x22
    2b96:	9e 01       	movw	r18, r28
    2b98:	2d 5e       	subi	r18, 0xED	; 237
    2b9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2b9c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b9e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ba0:	af 85       	ldd	r26, Y+15	; 0x0f
    2ba2:	b8 89       	ldd	r27, Y+16	; 0x10
    2ba4:	7a 01       	movw	r14, r20
    2ba6:	89 01       	movw	r16, r18
    2ba8:	2a 85       	ldd	r18, Y+10	; 0x0a
    2baa:	ac 01       	movw	r20, r24
    2bac:	bd 01       	movw	r22, r26
    2bae:	82 e0       	ldi	r24, 0x02	; 2
    2bb0:	0e 94 32 11 	call	0x2264	; 0x2264 <LCD_DisplayNumberWithAddingToBuffor>
						v_numOfDigitsToDisp_u8, &tmpX, y);
				break;
    2bb4:	32 c0       	rjmp	.+100    	; 0x2c1a <LCD_XYPrintf+0x6c4>
#endif
				break;

			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char*);
    2bb6:	8d 89       	ldd	r24, Y+21	; 0x15
    2bb8:	9e 89       	ldd	r25, Y+22	; 0x16
    2bba:	9c 01       	movw	r18, r24
    2bbc:	2e 5f       	subi	r18, 0xFE	; 254
    2bbe:	3f 4f       	sbci	r19, 0xFF	; 255
    2bc0:	3e 8b       	std	Y+22, r19	; 0x16
    2bc2:	2d 8b       	std	Y+21, r18	; 0x15
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	80 81       	ld	r24, Z
    2bc8:	91 81       	ldd	r25, Z+1	; 0x01
    2bca:	9a 8b       	std	Y+18, r25	; 0x12
    2bcc:	89 8b       	std	Y+17, r24	; 0x11
				LCD_DisplayStringWithAddingToBuffor(str, &tmpX, y);
    2bce:	49 a1       	ldd	r20, Y+33	; 0x21
    2bd0:	5a a1       	ldd	r21, Y+34	; 0x22
    2bd2:	9e 01       	movw	r18, r28
    2bd4:	2d 5e       	subi	r18, 0xED	; 237
    2bd6:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd8:	89 89       	ldd	r24, Y+17	; 0x11
    2bda:	9a 89       	ldd	r25, Y+18	; 0x12
    2bdc:	b9 01       	movw	r22, r18
    2bde:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <LCD_DisplayStringWithAddingToBuffor>
				break;
    2be2:	1b c0       	rjmp	.+54     	; 0x2c1a <LCD_XYPrintf+0x6c4>

			case '%':
				LCD_DisplayChar('%');
    2be4:	85 e2       	ldi	r24, 0x25	; 37
    2be6:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
				LCD_BUFFOR[y][tmpX] = '%';
    2bea:	8b 89       	ldd	r24, Y+19	; 0x13
    2bec:	9c 89       	ldd	r25, Y+20	; 0x14
    2bee:	29 a1       	ldd	r18, Y+33	; 0x21
    2bf0:	3a a1       	ldd	r19, Y+34	; 0x22
    2bf2:	22 95       	swap	r18
    2bf4:	32 95       	swap	r19
    2bf6:	30 7f       	andi	r19, 0xF0	; 240
    2bf8:	32 27       	eor	r19, r18
    2bfa:	20 7f       	andi	r18, 0xF0	; 240
    2bfc:	32 27       	eor	r19, r18
    2bfe:	82 0f       	add	r24, r18
    2c00:	93 1f       	adc	r25, r19
    2c02:	84 50       	subi	r24, 0x04	; 4
    2c04:	9f 4f       	sbci	r25, 0xFF	; 255
    2c06:	25 e2       	ldi	r18, 0x25	; 37
    2c08:	fc 01       	movw	r30, r24
    2c0a:	20 83       	st	Z, r18
				tmpX++;
    2c0c:	8b 89       	ldd	r24, Y+19	; 0x13
    2c0e:	9c 89       	ldd	r25, Y+20	; 0x14
    2c10:	01 96       	adiw	r24, 0x01	; 1
    2c12:	9c 8b       	std	Y+20, r25	; 0x14
    2c14:	8b 8b       	std	Y+19, r24	; 0x13
				break;
    2c16:	01 c0       	rjmp	.+2      	; 0x2c1a <LCD_XYPrintf+0x6c4>
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)  
                v_floatNum_f32 = va_arg(argp, double);              
                LCD_DisplayFloatNumber(v_floatNum_f32);
#endif
				break;
    2c18:	00 00       	nop
    2c1a:	19 c0       	rjmp	.+50     	; 0x2c4e <LCD_XYPrintf+0x6f8>
				tmpX++;
				break;
			}
		} else {
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
    2c1c:	89 85       	ldd	r24, Y+9	; 0x09
    2c1e:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
			LCD_BUFFOR[y][tmpX] = ch;
    2c22:	8b 89       	ldd	r24, Y+19	; 0x13
    2c24:	9c 89       	ldd	r25, Y+20	; 0x14
    2c26:	29 a1       	ldd	r18, Y+33	; 0x21
    2c28:	3a a1       	ldd	r19, Y+34	; 0x22
    2c2a:	22 95       	swap	r18
    2c2c:	32 95       	swap	r19
    2c2e:	30 7f       	andi	r19, 0xF0	; 240
    2c30:	32 27       	eor	r19, r18
    2c32:	20 7f       	andi	r18, 0xF0	; 240
    2c34:	32 27       	eor	r19, r18
    2c36:	82 0f       	add	r24, r18
    2c38:	93 1f       	adc	r25, r19
    2c3a:	84 50       	subi	r24, 0x04	; 4
    2c3c:	9f 4f       	sbci	r25, 0xFF	; 255
    2c3e:	29 85       	ldd	r18, Y+9	; 0x09
    2c40:	fc 01       	movw	r30, r24
    2c42:	20 83       	st	Z, r18
			tmpX++;
    2c44:	8b 89       	ldd	r24, Y+19	; 0x13
    2c46:	9c 89       	ldd	r25, Y+20	; 0x14
    2c48:	01 96       	adiw	r24, 0x01	; 1
    2c4a:	9c 8b       	std	Y+20, r25	; 0x14
    2c4c:	8b 8b       	std	Y+19, r24	; 0x13
#endif

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    2c4e:	89 81       	ldd	r24, Y+1	; 0x01
    2c50:	9a 81       	ldd	r25, Y+2	; 0x02
    2c52:	01 96       	adiw	r24, 0x01	; 1
    2c54:	9a 83       	std	Y+2, r25	; 0x02
    2c56:	89 83       	std	Y+1, r24	; 0x01
    2c58:	89 81       	ldd	r24, Y+1	; 0x01
    2c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5c:	fc 01       	movw	r30, r24
    2c5e:	80 81       	ld	r24, Z
    2c60:	88 23       	and	r24, r24
    2c62:	09 f0       	breq	.+2      	; 0x2c66 <LCD_XYPrintf+0x710>
    2c64:	98 cc       	rjmp	.-1744   	; 0x2596 <LCD_XYPrintf+0x40>
			tmpX++;
		}
	}

	va_end(argp);
}
    2c66:	66 96       	adiw	r28, 0x16	; 22
    2c68:	0f b6       	in	r0, 0x3f	; 63
    2c6a:	f8 94       	cli
    2c6c:	de bf       	out	0x3e, r29	; 62
    2c6e:	0f be       	out	0x3f, r0	; 63
    2c70:	cd bf       	out	0x3d, r28	; 61
    2c72:	df 91       	pop	r29
    2c74:	cf 91       	pop	r28
    2c76:	1f 91       	pop	r17
    2c78:	0f 91       	pop	r16
    2c7a:	ff 90       	pop	r15
    2c7c:	ef 90       	pop	r14
    2c7e:	08 95       	ret

00002c80 <LCD_Printf>:
#endif

#if ( Enable_LCD_Printf   == 1 )
void LCD_Printf(const char *argList, ...) {
    2c80:	cf 93       	push	r28
    2c82:	df 93       	push	r29
    2c84:	cd b7       	in	r28, 0x3d	; 61
    2c86:	de b7       	in	r29, 0x3e	; 62
    2c88:	64 97       	sbiw	r28, 0x14	; 20
    2c8a:	0f b6       	in	r0, 0x3f	; 63
    2c8c:	f8 94       	cli
    2c8e:	de bf       	out	0x3e, r29	; 62
    2c90:	0f be       	out	0x3f, r0	; 63
    2c92:	cd bf       	out	0x3d, r28	; 61
	uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)
    double v_floatNum_f32;
#endif

	va_start(argp, argList);
    2c94:	ce 01       	movw	r24, r28
    2c96:	4b 96       	adiw	r24, 0x1b	; 27
    2c98:	9c 8b       	std	Y+20, r25	; 0x14
    2c9a:	8b 8b       	std	Y+19, r24	; 0x13

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    2c9c:	89 8d       	ldd	r24, Y+25	; 0x19
    2c9e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2ca0:	9a 83       	std	Y+2, r25	; 0x02
    2ca2:	89 83       	std	Y+1, r24	; 0x01
    2ca4:	ad c1       	rjmp	.+858    	; 0x3000 <LCD_Printf+0x380>

		ch = *ptr;
    2ca6:	89 81       	ldd	r24, Y+1	; 0x01
    2ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    2caa:	fc 01       	movw	r30, r24
    2cac:	80 81       	ld	r24, Z
    2cae:	89 87       	std	Y+9, r24	; 0x09
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
    2cb0:	89 85       	ldd	r24, Y+9	; 0x09
    2cb2:	85 32       	cpi	r24, 0x25	; 37
    2cb4:	09 f0       	breq	.+2      	; 0x2cb8 <LCD_Printf+0x38>
    2cb6:	9c c1       	rjmp	.+824    	; 0x2ff0 <LCD_Printf+0x370>
		{
			ptr++;
    2cb8:	89 81       	ldd	r24, Y+1	; 0x01
    2cba:	9a 81       	ldd	r25, Y+2	; 0x02
    2cbc:	01 96       	adiw	r24, 0x01	; 1
    2cbe:	9a 83       	std	Y+2, r25	; 0x02
    2cc0:	89 83       	std	Y+1, r24	; 0x01
			ch = *ptr;
    2cc2:	89 81       	ldd	r24, Y+1	; 0x01
    2cc4:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc6:	fc 01       	movw	r30, r24
    2cc8:	80 81       	ld	r24, Z
    2cca:	89 87       	std	Y+9, r24	; 0x09
			if ((ch >= 0x30) && (ch <= 0x39)) {
    2ccc:	89 85       	ldd	r24, Y+9	; 0x09
    2cce:	80 33       	cpi	r24, 0x30	; 48
    2cd0:	00 f1       	brcs	.+64     	; 0x2d12 <LCD_Printf+0x92>
    2cd2:	89 85       	ldd	r24, Y+9	; 0x09
    2cd4:	8a 33       	cpi	r24, 0x3A	; 58
    2cd6:	e8 f4       	brcc	.+58     	; 0x2d12 <LCD_Printf+0x92>
				v_numOfDigitsToDisp_u8 = 0;
    2cd8:	1a 86       	std	Y+10, r1	; 0x0a
				while ((ch >= 0x30) && (ch <= 0x39)) {
    2cda:	14 c0       	rjmp	.+40     	; 0x2d04 <LCD_Printf+0x84>
					v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10)
    2cdc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cde:	88 0f       	add	r24, r24
    2ce0:	98 2f       	mov	r25, r24
    2ce2:	99 0f       	add	r25, r25
    2ce4:	99 0f       	add	r25, r25
    2ce6:	98 0f       	add	r25, r24
    2ce8:	89 85       	ldd	r24, Y+9	; 0x09
    2cea:	89 0f       	add	r24, r25
    2cec:	80 53       	subi	r24, 0x30	; 48
    2cee:	8a 87       	std	Y+10, r24	; 0x0a
							+ (ch - 0x30);
					ptr++;
    2cf0:	89 81       	ldd	r24, Y+1	; 0x01
    2cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf4:	01 96       	adiw	r24, 0x01	; 1
    2cf6:	9a 83       	std	Y+2, r25	; 0x02
    2cf8:	89 83       	std	Y+1, r24	; 0x01
					ch = *ptr;
    2cfa:	89 81       	ldd	r24, Y+1	; 0x01
    2cfc:	9a 81       	ldd	r25, Y+2	; 0x02
    2cfe:	fc 01       	movw	r30, r24
    2d00:	80 81       	ld	r24, Z
    2d02:	89 87       	std	Y+9, r24	; 0x09
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
				v_numOfDigitsToDisp_u8 = 0;
				while ((ch >= 0x30) && (ch <= 0x39)) {
    2d04:	89 85       	ldd	r24, Y+9	; 0x09
    2d06:	80 33       	cpi	r24, 0x30	; 48
    2d08:	18 f0       	brcs	.+6      	; 0x2d10 <LCD_Printf+0x90>
    2d0a:	89 85       	ldd	r24, Y+9	; 0x09
    2d0c:	8a 33       	cpi	r24, 0x3A	; 58
    2d0e:	30 f3       	brcs	.-52     	; 0x2cdc <LCD_Printf+0x5c>
		ch = *ptr;
		if (ch == '%') /*Check for '%' as there will be format specifier after it */
		{
			ptr++;
			ch = *ptr;
			if ((ch >= 0x30) && (ch <= 0x39)) {
    2d10:	02 c0       	rjmp	.+4      	; 0x2d16 <LCD_Printf+0x96>
							+ (ch - 0x30);
					ptr++;
					ch = *ptr;
				}
			} else {
				v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
    2d12:	8f ef       	ldi	r24, 0xFF	; 255
    2d14:	8a 87       	std	Y+10, r24	; 0x0a
			}

			switch (ch) /* Decode the type of the argument */
    2d16:	89 85       	ldd	r24, Y+9	; 0x09
    2d18:	88 2f       	mov	r24, r24
    2d1a:	90 e0       	ldi	r25, 0x00	; 0
    2d1c:	aa 27       	eor	r26, r26
    2d1e:	97 fd       	sbrc	r25, 7
    2d20:	a0 95       	com	r26
    2d22:	ba 2f       	mov	r27, r26
    2d24:	45 e2       	ldi	r20, 0x25	; 37
    2d26:	50 e0       	ldi	r21, 0x00	; 0
    2d28:	28 e5       	ldi	r18, 0x58	; 88
    2d2a:	30 e0       	ldi	r19, 0x00	; 0
    2d2c:	84 1b       	sub	r24, r20
    2d2e:	95 0b       	sbc	r25, r21
    2d30:	28 17       	cp	r18, r24
    2d32:	39 07       	cpc	r19, r25
    2d34:	08 f4       	brcc	.+2      	; 0x2d38 <LCD_Printf+0xb8>
    2d36:	5f c1       	rjmp	.+702    	; 0x2ff6 <LCD_Printf+0x376>
    2d38:	84 52       	subi	r24, 0x24	; 36
    2d3a:	9f 4f       	sbci	r25, 0xFF	; 255
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	0c 94 2a 1f 	jmp	0x3e54	; 0x3e54 <__tablejump2__>
			{
			case '>':
				LCD_PrintSymbol(1);
    2d42:	81 e0       	ldi	r24, 0x01	; 1
    2d44:	90 e0       	ldi	r25, 0x00	; 0
    2d46:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d4a:	51 c1       	rjmp	.+674    	; 0x2fee <LCD_Printf+0x36e>
			case '<':
				LCD_PrintSymbol(2);
    2d4c:	82 e0       	ldi	r24, 0x02	; 2
    2d4e:	90 e0       	ldi	r25, 0x00	; 0
    2d50:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d54:	4c c1       	rjmp	.+664    	; 0x2fee <LCD_Printf+0x36e>
			case '|':
				LCD_PrintSymbol(3);
    2d56:	83 e0       	ldi	r24, 0x03	; 3
    2d58:	90 e0       	ldi	r25, 0x00	; 0
    2d5a:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d5e:	47 c1       	rjmp	.+654    	; 0x2fee <LCD_Printf+0x36e>
			case '{':
				LCD_PrintSymbol(4);
    2d60:	84 e0       	ldi	r24, 0x04	; 4
    2d62:	90 e0       	ldi	r25, 0x00	; 0
    2d64:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d68:	42 c1       	rjmp	.+644    	; 0x2fee <LCD_Printf+0x36e>
			case '}':
				LCD_PrintSymbol(5);
    2d6a:	85 e0       	ldi	r24, 0x05	; 5
    2d6c:	90 e0       	ldi	r25, 0x00	; 0
    2d6e:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d72:	3d c1       	rjmp	.+634    	; 0x2fee <LCD_Printf+0x36e>
			case ',':
				LCD_PrintSymbol(6);
    2d74:	86 e0       	ldi	r24, 0x06	; 6
    2d76:	90 e0       	ldi	r25, 0x00	; 0
    2d78:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d7c:	38 c1       	rjmp	.+624    	; 0x2fee <LCD_Printf+0x36e>
			case ':':
				LCD_PrintSymbol(7);
    2d7e:	87 e0       	ldi	r24, 0x07	; 7
    2d80:	90 e0       	ldi	r25, 0x00	; 0
    2d82:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d86:	33 c1       	rjmp	.+614    	; 0x2fee <LCD_Printf+0x36e>
			case ';':
				LCD_PrintSymbol(8);
    2d88:	88 e0       	ldi	r24, 0x08	; 8
    2d8a:	90 e0       	ldi	r25, 0x00	; 0
    2d8c:	0e 94 46 1a 	call	0x348c	; 0x348c <LCD_PrintSymbol>
				break;
    2d90:	2e c1       	rjmp	.+604    	; 0x2fee <LCD_Printf+0x36e>
			case '?':
				LCD_PrintBlock();
    2d92:	0e 94 99 1a 	call	0x3532	; 0x3532 <LCD_PrintBlock>
				break;
    2d96:	2b c1       	rjmp	.+598    	; 0x2fee <LCD_Printf+0x36e>
			case '[':
				LCD_PrintLArrow();
    2d98:	0e 94 a3 1a 	call	0x3546	; 0x3546 <LCD_PrintLArrow>
				break;
    2d9c:	28 c1       	rjmp	.+592    	; 0x2fee <LCD_Printf+0x36e>
			case ']':
				LCD_PrintRArrow();
    2d9e:	0e 94 ad 1a 	call	0x355a	; 0x355a <LCD_PrintRArrow>
				break;
    2da2:	25 c1       	rjmp	.+586    	; 0x2fee <LCD_Printf+0x36e>
			case '.':
				LCD_PrintDot();
    2da4:	0e 94 b7 1a 	call	0x356e	; 0x356e <LCD_PrintDot>
				break;
    2da8:	22 c1       	rjmp	.+580    	; 0x2fee <LCD_Printf+0x36e>
			case 'C':
			case 'c': /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    2daa:	8b 89       	ldd	r24, Y+19	; 0x13
    2dac:	9c 89       	ldd	r25, Y+20	; 0x14
    2dae:	9c 01       	movw	r18, r24
    2db0:	2e 5f       	subi	r18, 0xFE	; 254
    2db2:	3f 4f       	sbci	r19, 0xFF	; 255
    2db4:	3c 8b       	std	Y+20, r19	; 0x14
    2db6:	2b 8b       	std	Y+19, r18	; 0x13
    2db8:	fc 01       	movw	r30, r24
    2dba:	80 81       	ld	r24, Z
    2dbc:	91 81       	ldd	r25, Z+1	; 0x01
    2dbe:	89 87       	std	Y+9, r24	; 0x09
				LCD_DisplayChar(ch);
    2dc0:	89 85       	ldd	r24, Y+9	; 0x09
    2dc2:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
				break;
    2dc6:	13 c1       	rjmp	.+550    	; 0x2fee <LCD_Printf+0x36e>

			case 'd': /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, int);
    2dc8:	8b 89       	ldd	r24, Y+19	; 0x13
    2dca:	9c 89       	ldd	r25, Y+20	; 0x14
    2dcc:	9c 01       	movw	r18, r24
    2dce:	2e 5f       	subi	r18, 0xFE	; 254
    2dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    2dd2:	3c 8b       	std	Y+20, r19	; 0x14
    2dd4:	2b 8b       	std	Y+19, r18	; 0x13
    2dd6:	fc 01       	movw	r30, r24
    2dd8:	80 81       	ld	r24, Z
    2dda:	91 81       	ldd	r25, Z+1	; 0x01
    2ddc:	9c 83       	std	Y+4, r25	; 0x04
    2dde:	8b 83       	std	Y+3, r24	; 0x03
				if (v_num_s16 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    2de0:	8b 81       	ldd	r24, Y+3	; 0x03
    2de2:	9c 81       	ldd	r25, Y+4	; 0x04
    2de4:	99 23       	and	r25, r25
    2de6:	54 f4       	brge	.+20     	; 0x2dfc <LCD_Printf+0x17c>
					v_num_s16 = -v_num_s16;
    2de8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dea:	9c 81       	ldd	r25, Y+4	; 0x04
    2dec:	91 95       	neg	r25
    2dee:	81 95       	neg	r24
    2df0:	91 09       	sbc	r25, r1
    2df2:	9c 83       	std	Y+4, r25	; 0x04
    2df4:	8b 83       	std	Y+3, r24	; 0x03
					LCD_DisplayChar('-');
    2df6:	8d e2       	ldi	r24, 0x2D	; 45
    2df8:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
				}
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_s16,
    2dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2e00:	aa 27       	eor	r26, r26
    2e02:	97 fd       	sbrc	r25, 7
    2e04:	a0 95       	com	r26
    2e06:	ba 2f       	mov	r27, r26
    2e08:	2a 85       	ldd	r18, Y+10	; 0x0a
    2e0a:	ac 01       	movw	r20, r24
    2e0c:	bd 01       	movw	r22, r26
    2e0e:	8a e0       	ldi	r24, 0x0A	; 10
    2e10:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    2e14:	ec c0       	rjmp	.+472    	; 0x2fee <LCD_Printf+0x36e>

			case 'D': /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);
    2e16:	8b 89       	ldd	r24, Y+19	; 0x13
    2e18:	9c 89       	ldd	r25, Y+20	; 0x14
    2e1a:	9c 01       	movw	r18, r24
    2e1c:	2c 5f       	subi	r18, 0xFC	; 252
    2e1e:	3f 4f       	sbci	r19, 0xFF	; 255
    2e20:	3c 8b       	std	Y+20, r19	; 0x14
    2e22:	2b 8b       	std	Y+19, r18	; 0x13
    2e24:	fc 01       	movw	r30, r24
    2e26:	80 81       	ld	r24, Z
    2e28:	91 81       	ldd	r25, Z+1	; 0x01
    2e2a:	a2 81       	ldd	r26, Z+2	; 0x02
    2e2c:	b3 81       	ldd	r27, Z+3	; 0x03
    2e2e:	8d 83       	std	Y+5, r24	; 0x05
    2e30:	9e 83       	std	Y+6, r25	; 0x06
    2e32:	af 83       	std	Y+7, r26	; 0x07
    2e34:	b8 87       	std	Y+8, r27	; 0x08
				if (v_num_s32 < 0) { /* If the number is -ve then display the 2's complement along with '-' sign */
    2e36:	8d 81       	ldd	r24, Y+5	; 0x05
    2e38:	9e 81       	ldd	r25, Y+6	; 0x06
    2e3a:	af 81       	ldd	r26, Y+7	; 0x07
    2e3c:	b8 85       	ldd	r27, Y+8	; 0x08
    2e3e:	bb 23       	and	r27, r27
    2e40:	94 f4       	brge	.+36     	; 0x2e66 <LCD_Printf+0x1e6>
					v_num_s32 = -v_num_s32;
    2e42:	8d 81       	ldd	r24, Y+5	; 0x05
    2e44:	9e 81       	ldd	r25, Y+6	; 0x06
    2e46:	af 81       	ldd	r26, Y+7	; 0x07
    2e48:	b8 85       	ldd	r27, Y+8	; 0x08
    2e4a:	b0 95       	com	r27
    2e4c:	a0 95       	com	r26
    2e4e:	90 95       	com	r25
    2e50:	81 95       	neg	r24
    2e52:	9f 4f       	sbci	r25, 0xFF	; 255
    2e54:	af 4f       	sbci	r26, 0xFF	; 255
    2e56:	bf 4f       	sbci	r27, 0xFF	; 255
    2e58:	8d 83       	std	Y+5, r24	; 0x05
    2e5a:	9e 83       	std	Y+6, r25	; 0x06
    2e5c:	af 83       	std	Y+7, r26	; 0x07
    2e5e:	b8 87       	std	Y+8, r27	; 0x08
					LCD_DisplayChar('-');
    2e60:	8d e2       	ldi	r24, 0x2D	; 45
    2e62:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
				}
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_s32,
    2e66:	8d 81       	ldd	r24, Y+5	; 0x05
    2e68:	9e 81       	ldd	r25, Y+6	; 0x06
    2e6a:	af 81       	ldd	r26, Y+7	; 0x07
    2e6c:	b8 85       	ldd	r27, Y+8	; 0x08
    2e6e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2e70:	ac 01       	movw	r20, r24
    2e72:	bd 01       	movw	r22, r26
    2e74:	8a e0       	ldi	r24, 0x0A	; 10
    2e76:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    2e7a:	b9 c0       	rjmp	.+370    	; 0x2fee <LCD_Printf+0x36e>

			case 'u': /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, int);
    2e7c:	8b 89       	ldd	r24, Y+19	; 0x13
    2e7e:	9c 89       	ldd	r25, Y+20	; 0x14
    2e80:	9c 01       	movw	r18, r24
    2e82:	2e 5f       	subi	r18, 0xFE	; 254
    2e84:	3f 4f       	sbci	r19, 0xFF	; 255
    2e86:	3c 8b       	std	Y+20, r19	; 0x14
    2e88:	2b 8b       	std	Y+19, r18	; 0x13
    2e8a:	fc 01       	movw	r30, r24
    2e8c:	80 81       	ld	r24, Z
    2e8e:	91 81       	ldd	r25, Z+1	; 0x01
    2e90:	9c 87       	std	Y+12, r25	; 0x0c
    2e92:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_u16,
    2e94:	8b 85       	ldd	r24, Y+11	; 0x0b
    2e96:	9c 85       	ldd	r25, Y+12	; 0x0c
    2e98:	cc 01       	movw	r24, r24
    2e9a:	a0 e0       	ldi	r26, 0x00	; 0
    2e9c:	b0 e0       	ldi	r27, 0x00	; 0
    2e9e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2ea0:	ac 01       	movw	r20, r24
    2ea2:	bd 01       	movw	r22, r26
    2ea4:	8a e0       	ldi	r24, 0x0A	; 10
    2ea6:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    2eaa:	a1 c0       	rjmp	.+322    	; 0x2fee <LCD_Printf+0x36e>

			case 'U': /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);
    2eac:	8b 89       	ldd	r24, Y+19	; 0x13
    2eae:	9c 89       	ldd	r25, Y+20	; 0x14
    2eb0:	9c 01       	movw	r18, r24
    2eb2:	2c 5f       	subi	r18, 0xFC	; 252
    2eb4:	3f 4f       	sbci	r19, 0xFF	; 255
    2eb6:	3c 8b       	std	Y+20, r19	; 0x14
    2eb8:	2b 8b       	std	Y+19, r18	; 0x13
    2eba:	fc 01       	movw	r30, r24
    2ebc:	80 81       	ld	r24, Z
    2ebe:	91 81       	ldd	r25, Z+1	; 0x01
    2ec0:	a2 81       	ldd	r26, Z+2	; 0x02
    2ec2:	b3 81       	ldd	r27, Z+3	; 0x03
    2ec4:	8d 87       	std	Y+13, r24	; 0x0d
    2ec6:	9e 87       	std	Y+14, r25	; 0x0e
    2ec8:	af 87       	std	Y+15, r26	; 0x0f
    2eca:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumber(C_DECIMAL_U8, v_num_u32,
    2ecc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ece:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ed0:	af 85       	ldd	r26, Y+15	; 0x0f
    2ed2:	b8 89       	ldd	r27, Y+16	; 0x10
    2ed4:	2a 85       	ldd	r18, Y+10	; 0x0a
    2ed6:	ac 01       	movw	r20, r24
    2ed8:	bd 01       	movw	r22, r26
    2eda:	8a e0       	ldi	r24, 0x0A	; 10
    2edc:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    2ee0:	86 c0       	rjmp	.+268    	; 0x2fee <LCD_Printf+0x36e>

			case 'x': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, int);
    2ee2:	8b 89       	ldd	r24, Y+19	; 0x13
    2ee4:	9c 89       	ldd	r25, Y+20	; 0x14
    2ee6:	9c 01       	movw	r18, r24
    2ee8:	2e 5f       	subi	r18, 0xFE	; 254
    2eea:	3f 4f       	sbci	r19, 0xFF	; 255
    2eec:	3c 8b       	std	Y+20, r19	; 0x14
    2eee:	2b 8b       	std	Y+19, r18	; 0x13
    2ef0:	fc 01       	movw	r30, r24
    2ef2:	80 81       	ld	r24, Z
    2ef4:	91 81       	ldd	r25, Z+1	; 0x01
    2ef6:	9c 87       	std	Y+12, r25	; 0x0c
    2ef8:	8b 87       	std	Y+11, r24	; 0x0b
				LCD_DisplayNumber(C_HEX_U8, v_num_u16, v_numOfDigitsToDisp_u8);
    2efa:	8b 85       	ldd	r24, Y+11	; 0x0b
    2efc:	9c 85       	ldd	r25, Y+12	; 0x0c
    2efe:	cc 01       	movw	r24, r24
    2f00:	a0 e0       	ldi	r26, 0x00	; 0
    2f02:	b0 e0       	ldi	r27, 0x00	; 0
    2f04:	2a 85       	ldd	r18, Y+10	; 0x0a
    2f06:	ac 01       	movw	r20, r24
    2f08:	bd 01       	movw	r22, r26
    2f0a:	80 e1       	ldi	r24, 0x10	; 16
    2f0c:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
				break;
    2f10:	6e c0       	rjmp	.+220    	; 0x2fee <LCD_Printf+0x36e>

			case 'X': /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);
    2f12:	8b 89       	ldd	r24, Y+19	; 0x13
    2f14:	9c 89       	ldd	r25, Y+20	; 0x14
    2f16:	9c 01       	movw	r18, r24
    2f18:	2c 5f       	subi	r18, 0xFC	; 252
    2f1a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f1c:	3c 8b       	std	Y+20, r19	; 0x14
    2f1e:	2b 8b       	std	Y+19, r18	; 0x13
    2f20:	fc 01       	movw	r30, r24
    2f22:	80 81       	ld	r24, Z
    2f24:	91 81       	ldd	r25, Z+1	; 0x01
    2f26:	a2 81       	ldd	r26, Z+2	; 0x02
    2f28:	b3 81       	ldd	r27, Z+3	; 0x03
    2f2a:	8d 87       	std	Y+13, r24	; 0x0d
    2f2c:	9e 87       	std	Y+14, r25	; 0x0e
    2f2e:	af 87       	std	Y+15, r26	; 0x0f
    2f30:	b8 8b       	std	Y+16, r27	; 0x10
				LCD_DisplayNumber(C_HEX_U8, v_num_u32, v_numOfDigitsToDisp_u8);
    2f32:	8d 85       	ldd	r24, Y+13	; 0x0d
    2f34:	9e 85       	ldd	r25, Y+14	; 0x0e
    2f36:	af 85       	ldd	r26, Y+15	; 0x0f
    2f38:	b8 89       	ldd	r27, Y+16	; 0x10
    2f3a:	2a 85       	ldd	r18, Y+10	; 0x0a
    2f3c:	ac 01       	movw	r20, r24
    2f3e:	bd 01       	movw	r22, r26
    2f40:	80 e1       	ldi	r24, 0x10	; 16
    2f42:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
				break;
    2f46:	53 c0       	rjmp	.+166    	; 0x2fee <LCD_Printf+0x36e>

			case 'b': /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, int);
    2f48:	8b 89       	ldd	r24, Y+19	; 0x13
    2f4a:	9c 89       	ldd	r25, Y+20	; 0x14
    2f4c:	9c 01       	movw	r18, r24
    2f4e:	2e 5f       	subi	r18, 0xFE	; 254
    2f50:	3f 4f       	sbci	r19, 0xFF	; 255
    2f52:	3c 8b       	std	Y+20, r19	; 0x14
    2f54:	2b 8b       	std	Y+19, r18	; 0x13
    2f56:	fc 01       	movw	r30, r24
    2f58:	80 81       	ld	r24, Z
    2f5a:	91 81       	ldd	r25, Z+1	; 0x01
    2f5c:	9c 87       	std	Y+12, r25	; 0x0c
    2f5e:	8b 87       	std	Y+11, r24	; 0x0b
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    2f60:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f62:	8f 3f       	cpi	r24, 0xFF	; 255
    2f64:	11 f4       	brne	.+4      	; 0x2f6a <LCD_Printf+0x2ea>
					v_numOfDigitsToDisp_u8 = 16;
    2f66:	80 e1       	ldi	r24, 0x10	; 16
    2f68:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumber(C_BINARY_U8, v_num_u16,
    2f6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2f6c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2f6e:	cc 01       	movw	r24, r24
    2f70:	a0 e0       	ldi	r26, 0x00	; 0
    2f72:	b0 e0       	ldi	r27, 0x00	; 0
    2f74:	2a 85       	ldd	r18, Y+10	; 0x0a
    2f76:	ac 01       	movw	r20, r24
    2f78:	bd 01       	movw	r22, r26
    2f7a:	82 e0       	ldi	r24, 0x02	; 2
    2f7c:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    2f80:	36 c0       	rjmp	.+108    	; 0x2fee <LCD_Printf+0x36e>

			case 'B': /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);
    2f82:	8b 89       	ldd	r24, Y+19	; 0x13
    2f84:	9c 89       	ldd	r25, Y+20	; 0x14
    2f86:	9c 01       	movw	r18, r24
    2f88:	2c 5f       	subi	r18, 0xFC	; 252
    2f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f8c:	3c 8b       	std	Y+20, r19	; 0x14
    2f8e:	2b 8b       	std	Y+19, r18	; 0x13
    2f90:	fc 01       	movw	r30, r24
    2f92:	80 81       	ld	r24, Z
    2f94:	91 81       	ldd	r25, Z+1	; 0x01
    2f96:	a2 81       	ldd	r26, Z+2	; 0x02
    2f98:	b3 81       	ldd	r27, Z+3	; 0x03
    2f9a:	8d 87       	std	Y+13, r24	; 0x0d
    2f9c:	9e 87       	std	Y+14, r25	; 0x0e
    2f9e:	af 87       	std	Y+15, r26	; 0x0f
    2fa0:	b8 8b       	std	Y+16, r27	; 0x10
				if (v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
    2fa2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fa4:	8f 3f       	cpi	r24, 0xFF	; 255
    2fa6:	11 f4       	brne	.+4      	; 0x2fac <LCD_Printf+0x32c>
					v_numOfDigitsToDisp_u8 = 16;
    2fa8:	80 e1       	ldi	r24, 0x10	; 16
    2faa:	8a 87       	std	Y+10, r24	; 0x0a
				LCD_DisplayNumber(C_BINARY_U8, v_num_u32,
    2fac:	8d 85       	ldd	r24, Y+13	; 0x0d
    2fae:	9e 85       	ldd	r25, Y+14	; 0x0e
    2fb0:	af 85       	ldd	r26, Y+15	; 0x0f
    2fb2:	b8 89       	ldd	r27, Y+16	; 0x10
    2fb4:	2a 85       	ldd	r18, Y+10	; 0x0a
    2fb6:	ac 01       	movw	r20, r24
    2fb8:	bd 01       	movw	r22, r26
    2fba:	82 e0       	ldi	r24, 0x02	; 2
    2fbc:	0e 94 51 10 	call	0x20a2	; 0x20a2 <LCD_DisplayNumber>
						v_numOfDigitsToDisp_u8);
				break;
    2fc0:	16 c0       	rjmp	.+44     	; 0x2fee <LCD_Printf+0x36e>
#endif
				break;

			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char*);
    2fc2:	8b 89       	ldd	r24, Y+19	; 0x13
    2fc4:	9c 89       	ldd	r25, Y+20	; 0x14
    2fc6:	9c 01       	movw	r18, r24
    2fc8:	2e 5f       	subi	r18, 0xFE	; 254
    2fca:	3f 4f       	sbci	r19, 0xFF	; 255
    2fcc:	3c 8b       	std	Y+20, r19	; 0x14
    2fce:	2b 8b       	std	Y+19, r18	; 0x13
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	80 81       	ld	r24, Z
    2fd4:	91 81       	ldd	r25, Z+1	; 0x01
    2fd6:	9a 8b       	std	Y+18, r25	; 0x12
    2fd8:	89 8b       	std	Y+17, r24	; 0x11
				LCD_DisplayString(str);
    2fda:	89 89       	ldd	r24, Y+17	; 0x11
    2fdc:	9a 89       	ldd	r25, Y+18	; 0x12
    2fde:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <LCD_DisplayString>
				break;
    2fe2:	05 c0       	rjmp	.+10     	; 0x2fee <LCD_Printf+0x36e>

			case '%':
				LCD_DisplayChar('%');
    2fe4:	85 e2       	ldi	r24, 0x25	; 37
    2fe6:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
				break;
    2fea:	01 c0       	rjmp	.+2      	; 0x2fee <LCD_Printf+0x36e>
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)
                v_floatNum_f32 = va_arg(argp, double);
                LCD_DisplayFloatNumber(v_floatNum_f32);
#endif
				break;
    2fec:	00 00       	nop
    2fee:	03 c0       	rjmp	.+6      	; 0x2ff6 <LCD_Printf+0x376>
				LCD_DisplayChar('%');
				break;
			}
		} else {
			/* As '%' is not detected display/transmit the char passed */
			LCD_DisplayChar(ch);
    2ff0:	89 85       	ldd	r24, Y+9	; 0x09
    2ff2:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <LCD_DisplayChar>
#endif

	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for (ptr = argList; *ptr != '\0'; ptr++) {
    2ff6:	89 81       	ldd	r24, Y+1	; 0x01
    2ff8:	9a 81       	ldd	r25, Y+2	; 0x02
    2ffa:	01 96       	adiw	r24, 0x01	; 1
    2ffc:	9a 83       	std	Y+2, r25	; 0x02
    2ffe:	89 83       	std	Y+1, r24	; 0x01
    3000:	89 81       	ldd	r24, Y+1	; 0x01
    3002:	9a 81       	ldd	r25, Y+2	; 0x02
    3004:	fc 01       	movw	r30, r24
    3006:	80 81       	ld	r24, Z
    3008:	88 23       	and	r24, r24
    300a:	09 f0       	breq	.+2      	; 0x300e <LCD_Printf+0x38e>
    300c:	4c ce       	rjmp	.-872    	; 0x2ca6 <LCD_Printf+0x26>
			LCD_DisplayChar(ch);
		}
	}

	va_end(argp);
}
    300e:	64 96       	adiw	r28, 0x14	; 20
    3010:	0f b6       	in	r0, 0x3f	; 63
    3012:	f8 94       	cli
    3014:	de bf       	out	0x3e, r29	; 62
    3016:	0f be       	out	0x3f, r0	; 63
    3018:	cd bf       	out	0x3d, r28	; 61
    301a:	df 91       	pop	r29
    301c:	cf 91       	pop	r28
    301e:	08 95       	ret

00003020 <lcd_DataWrite>:
 * I/P Arguments: uint8_t: 8-bit value to be sent to LCD.
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .    
 **************************************************************************************************/
static void lcd_DataWrite(uint8_t dataByte) {
    3020:	cf 93       	push	r28
    3022:	df 93       	push	r29
    3024:	1f 92       	push	r1
    3026:	cd b7       	in	r28, 0x3d	; 61
    3028:	de b7       	in	r29, 0x3e	; 62
    302a:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    302c:	0e 94 54 18 	call	0x30a8	; 0x30a8 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    3030:	80 91 1e 01 	lds	r24, 0x011E
    3034:	88 30       	cpi	r24, 0x08	; 8
    3036:	21 f4       	brne	.+8      	; 0x3040 <lcd_DataWrite+0x20>
		lcd_SendLowerNibble(dataByte);
    3038:	89 81       	ldd	r24, Y+1	; 0x01
    303a:	0e 94 17 19 	call	0x322e	; 0x322e <lcd_SendLowerNibble>
    303e:	09 c0       	rjmp	.+18     	; 0x3052 <lcd_DataWrite+0x32>
	} else {
		lcd_SendHigherNibble(dataByte);
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
		lcd_SendDataSignals();
    3046:	0e 94 7c 19 	call	0x32f8	; 0x32f8 <lcd_SendDataSignals>
		dataByte = dataByte << 4;
    304a:	89 81       	ldd	r24, Y+1	; 0x01
    304c:	82 95       	swap	r24
    304e:	80 7f       	andi	r24, 0xF0	; 240
    3050:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(dataByte);
    3052:	89 81       	ldd	r24, Y+1	; 0x01
    3054:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
	lcd_SendDataSignals();
    3058:	0e 94 7c 19 	call	0x32f8	; 0x32f8 <lcd_SendDataSignals>
}
    305c:	0f 90       	pop	r0
    305e:	df 91       	pop	r29
    3060:	cf 91       	pop	r28
    3062:	08 95       	ret

00003064 <LCD_DataWrite>:
 * I/P Arguments: uint8_t: 8-bit value to be sent to LCD.
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .
 **************************************************************************************************/
void LCD_DataWrite(uint8_t dataByte) {
    3064:	cf 93       	push	r28
    3066:	df 93       	push	r29
    3068:	1f 92       	push	r1
    306a:	cd b7       	in	r28, 0x3d	; 61
    306c:	de b7       	in	r29, 0x3e	; 62
    306e:	89 83       	std	Y+1, r24	; 0x01
	lcd_BusyCheck();
    3070:	0e 94 54 18 	call	0x30a8	; 0x30a8 <lcd_BusyCheck>
	if (LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8) {
    3074:	80 91 1e 01 	lds	r24, 0x011E
    3078:	88 30       	cpi	r24, 0x08	; 8
    307a:	21 f4       	brne	.+8      	; 0x3084 <LCD_DataWrite+0x20>
		lcd_SendLowerNibble(dataByte);
    307c:	89 81       	ldd	r24, Y+1	; 0x01
    307e:	0e 94 17 19 	call	0x322e	; 0x322e <lcd_SendLowerNibble>
    3082:	09 c0       	rjmp	.+18     	; 0x3096 <LCD_DataWrite+0x32>
	} else {
		lcd_SendHigherNibble(dataByte);
    3084:	89 81       	ldd	r24, Y+1	; 0x01
    3086:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
		lcd_SendDataSignals();
    308a:	0e 94 7c 19 	call	0x32f8	; 0x32f8 <lcd_SendDataSignals>
		dataByte = dataByte << 4;
    308e:	89 81       	ldd	r24, Y+1	; 0x01
    3090:	82 95       	swap	r24
    3092:	80 7f       	andi	r24, 0xF0	; 240
    3094:	89 83       	std	Y+1, r24	; 0x01
	}

	lcd_SendHigherNibble(dataByte);
    3096:	89 81       	ldd	r24, Y+1	; 0x01
    3098:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
	lcd_SendDataSignals();
    309c:	0e 94 7c 19 	call	0x32f8	; 0x32f8 <lcd_SendDataSignals>
}
    30a0:	0f 90       	pop	r0
    30a2:	df 91       	pop	r29
    30a4:	cf 91       	pop	r28
    30a6:	08 95       	ret

000030a8 <lcd_BusyCheck>:

 * description : This functions is used check whether LCD is busy.
 It waits till the LCD is busy by polling the LCD busy flag.
 After completing the previous operation, LCDs clears its internal busy flag.
 **************************************************************************************************/
static void lcd_BusyCheck(void) {
    30a8:	cf 93       	push	r28
    30aa:	df 93       	push	r29
    30ac:	1f 92       	push	r1
    30ae:	cd b7       	in	r28, 0x3d	; 61
    30b0:	de b7       	in	r29, 0x3e	; 62
	uint8_t busyflag;

	if (LCDConfig.RW != P_NC)             //Perform Busy check if RW pin is used
    30b2:	80 91 20 01 	lds	r24, 0x0120
    30b6:	8f 3f       	cpi	r24, 0xFF	; 255
    30b8:	09 f4       	brne	.+2      	; 0x30bc <lcd_BusyCheck+0x14>
    30ba:	45 c0       	rjmp	.+138    	; 0x3146 <lcd_BusyCheck+0x9e>
			{
		GPIO_PinDirection(LCDConfig.D7, INPUT); // Configure busy pin as input
    30bc:	80 91 29 01 	lds	r24, 0x0129
    30c0:	60 e0       	ldi	r22, 0x00	; 0
    30c2:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
		GPIO_PinWrite(LCDConfig.RS, 0); // Select the Command Register by pulling RS LOW
    30c6:	80 91 1f 01 	lds	r24, 0x011F
    30ca:	60 e0       	ldi	r22, 0x00	; 0
    30cc:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
		GPIO_PinWrite(LCDConfig.RW, 1); // Select the Read Operation for busy flag by setting RW
    30d0:	80 91 20 01 	lds	r24, 0x0120
    30d4:	61 e0       	ldi	r22, 0x01	; 1
    30d6:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
		do {

			GPIO_PinWrite(LCDConfig.EN, 0);
    30da:	80 91 21 01 	lds	r24, 0x0121
    30de:	60 e0       	ldi	r22, 0x00	; 0
    30e0:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
			DELAY_us(10);
    30e4:	8a e0       	ldi	r24, 0x0A	; 10
    30e6:	90 e0       	ldi	r25, 0x00	; 0
    30e8:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
			GPIO_PinWrite(LCDConfig.EN, 1);
    30ec:	80 91 21 01 	lds	r24, 0x0121
    30f0:	61 e0       	ldi	r22, 0x01	; 1
    30f2:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
			DELAY_us(10);
    30f6:	8a e0       	ldi	r24, 0x0A	; 10
    30f8:	90 e0       	ldi	r25, 0x00	; 0
    30fa:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
			busyflag = GPIO_PinRead(LCDConfig.D7);
    30fe:	80 91 29 01 	lds	r24, 0x0129
    3102:	0e 94 7b 0b 	call	0x16f6	; 0x16f6 <GPIO_PinRead>
    3106:	89 83       	std	Y+1, r24	; 0x01

			if (LCDConfig.v_LcdMode_U8 == 4) {
    3108:	80 91 1e 01 	lds	r24, 0x011E
    310c:	84 30       	cpi	r24, 0x04	; 4
    310e:	91 f4       	brne	.+36     	; 0x3134 <lcd_BusyCheck+0x8c>
				/* Perform extra dummy read for 4-bit */
				GPIO_PinWrite(LCDConfig.EN, 0);
    3110:	80 91 21 01 	lds	r24, 0x0121
    3114:	60 e0       	ldi	r22, 0x00	; 0
    3116:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
				DELAY_us(10);
    311a:	8a e0       	ldi	r24, 0x0A	; 10
    311c:	90 e0       	ldi	r25, 0x00	; 0
    311e:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
				GPIO_PinWrite(LCDConfig.EN, 1);
    3122:	80 91 21 01 	lds	r24, 0x0121
    3126:	61 e0       	ldi	r22, 0x01	; 1
    3128:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
				DELAY_us(10);
    312c:	8a e0       	ldi	r24, 0x0A	; 10
    312e:	90 e0       	ldi	r25, 0x00	; 0
    3130:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
			}
		} while (busyflag != 0);
    3134:	89 81       	ldd	r24, Y+1	; 0x01
    3136:	88 23       	and	r24, r24
    3138:	81 f6       	brne	.-96     	; 0x30da <lcd_BusyCheck+0x32>

		GPIO_PinDirection(LCDConfig.D7, OUTPUT); // Configure busy pin as Output
    313a:	80 91 29 01 	lds	r24, 0x0129
    313e:	61 e0       	ldi	r22, 0x01	; 1
    3140:	0e 94 a3 09 	call	0x1346	; 0x1346 <GPIO_PinDirection>
    3144:	04 c0       	rjmp	.+8      	; 0x314e <lcd_BusyCheck+0xa6>
	} else {
		/* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added
		 to ensure the LCD completes previous operation and ready to receive new commands/data */
		DELAY_ms(1);
    3146:	81 e0       	ldi	r24, 0x01	; 1
    3148:	90 e0       	ldi	r25, 0x00	; 0
    314a:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
	}
}
    314e:	0f 90       	pop	r0
    3150:	df 91       	pop	r29
    3152:	cf 91       	pop	r28
    3154:	08 95       	ret

00003156 <lcd_Reset>:
 * Return value    : none

 * description : This functions is used to reset the LCD. 
 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
 ----------------------------------------------------------------------------------*/
static void lcd_Reset(void) {
    3156:	cf 93       	push	r28
    3158:	df 93       	push	r29
    315a:	cd b7       	in	r28, 0x3d	; 61
    315c:	de b7       	in	r29, 0x3e	; 62
	/* LCD reset sequence for 4-bit mode, refer data sheet for more info */
	lcd_SendHigherNibble(0x30);
    315e:	80 e3       	ldi	r24, 0x30	; 48
    3160:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    3164:	0e 94 5d 19 	call	0x32ba	; 0x32ba <lcd_SendCmdSignals>
	DELAY_ms(100);
    3168:	84 e6       	ldi	r24, 0x64	; 100
    316a:	90 e0       	ldi	r25, 0x00	; 0
    316c:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <DELAY_ms>
	lcd_SendHigherNibble(0x30);
    3170:	80 e3       	ldi	r24, 0x30	; 48
    3172:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    3176:	0e 94 5d 19 	call	0x32ba	; 0x32ba <lcd_SendCmdSignals>
	DELAY_us(200);
    317a:	88 ec       	ldi	r24, 0xC8	; 200
    317c:	90 e0       	ldi	r25, 0x00	; 0
    317e:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
	lcd_SendHigherNibble(0x30);
    3182:	80 e3       	ldi	r24, 0x30	; 48
    3184:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    3188:	0e 94 5d 19 	call	0x32ba	; 0x32ba <lcd_SendCmdSignals>
	DELAY_us(200);
    318c:	88 ec       	ldi	r24, 0xC8	; 200
    318e:	90 e0       	ldi	r25, 0x00	; 0
    3190:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
	lcd_SendHigherNibble(0x20);
    3194:	80 e2       	ldi	r24, 0x20	; 32
    3196:	0e 94 d6 18 	call	0x31ac	; 0x31ac <lcd_SendHigherNibble>
	lcd_SendCmdSignals();
    319a:	0e 94 5d 19 	call	0x32ba	; 0x32ba <lcd_SendCmdSignals>
	DELAY_us(200);
    319e:	88 ec       	ldi	r24, 0xC8	; 200
    31a0:	90 e0       	ldi	r25, 0x00	; 0
    31a2:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
}
    31a6:	df 91       	pop	r29
    31a8:	cf 91       	pop	r28
    31aa:	08 95       	ret

000031ac <lcd_SendHigherNibble>:
 * I/P Arguments: uint8_t: Higher nibble of the data to be send on LCD4-LCD7 data lines
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
 **************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte) {
    31ac:	cf 93       	push	r28
    31ae:	df 93       	push	r29
    31b0:	1f 92       	push	r1
    31b2:	cd b7       	in	r28, 0x3d	; 61
    31b4:	de b7       	in	r29, 0x3e	; 62
    31b6:	89 83       	std	Y+1, r24	; 0x01
	GPIO_PinWrite(LCDConfig.D4, util_IsBitSet(dataByte, 4));
    31b8:	89 81       	ldd	r24, Y+1	; 0x01
    31ba:	88 2f       	mov	r24, r24
    31bc:	90 e0       	ldi	r25, 0x00	; 0
    31be:	80 71       	andi	r24, 0x10	; 16
    31c0:	99 27       	eor	r25, r25
    31c2:	21 e0       	ldi	r18, 0x01	; 1
    31c4:	00 97       	sbiw	r24, 0x00	; 0
    31c6:	09 f4       	brne	.+2      	; 0x31ca <lcd_SendHigherNibble+0x1e>
    31c8:	20 e0       	ldi	r18, 0x00	; 0
    31ca:	92 2f       	mov	r25, r18
    31cc:	80 91 26 01 	lds	r24, 0x0126
    31d0:	69 2f       	mov	r22, r25
    31d2:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D5, util_IsBitSet(dataByte, 5));
    31d6:	89 81       	ldd	r24, Y+1	; 0x01
    31d8:	88 2f       	mov	r24, r24
    31da:	90 e0       	ldi	r25, 0x00	; 0
    31dc:	80 72       	andi	r24, 0x20	; 32
    31de:	99 27       	eor	r25, r25
    31e0:	21 e0       	ldi	r18, 0x01	; 1
    31e2:	00 97       	sbiw	r24, 0x00	; 0
    31e4:	09 f4       	brne	.+2      	; 0x31e8 <lcd_SendHigherNibble+0x3c>
    31e6:	20 e0       	ldi	r18, 0x00	; 0
    31e8:	92 2f       	mov	r25, r18
    31ea:	80 91 27 01 	lds	r24, 0x0127
    31ee:	69 2f       	mov	r22, r25
    31f0:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D6, util_IsBitSet(dataByte, 6));
    31f4:	89 81       	ldd	r24, Y+1	; 0x01
    31f6:	88 2f       	mov	r24, r24
    31f8:	90 e0       	ldi	r25, 0x00	; 0
    31fa:	80 74       	andi	r24, 0x40	; 64
    31fc:	99 27       	eor	r25, r25
    31fe:	21 e0       	ldi	r18, 0x01	; 1
    3200:	00 97       	sbiw	r24, 0x00	; 0
    3202:	09 f4       	brne	.+2      	; 0x3206 <lcd_SendHigherNibble+0x5a>
    3204:	20 e0       	ldi	r18, 0x00	; 0
    3206:	92 2f       	mov	r25, r18
    3208:	80 91 28 01 	lds	r24, 0x0128
    320c:	69 2f       	mov	r22, r25
    320e:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D7, util_IsBitSet(dataByte, 7));
    3212:	89 81       	ldd	r24, Y+1	; 0x01
    3214:	88 1f       	adc	r24, r24
    3216:	88 27       	eor	r24, r24
    3218:	88 1f       	adc	r24, r24
    321a:	98 2f       	mov	r25, r24
    321c:	80 91 29 01 	lds	r24, 0x0129
    3220:	69 2f       	mov	r22, r25
    3222:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
}
    3226:	0f 90       	pop	r0
    3228:	df 91       	pop	r29
    322a:	cf 91       	pop	r28
    322c:	08 95       	ret

0000322e <lcd_SendLowerNibble>:
 * I/P Arguments: uint8_t: Lower nibble of the data to be send on LCD4-LCD7 data lines
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
 **************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte) {
    322e:	cf 93       	push	r28
    3230:	df 93       	push	r29
    3232:	1f 92       	push	r1
    3234:	cd b7       	in	r28, 0x3d	; 61
    3236:	de b7       	in	r29, 0x3e	; 62
    3238:	89 83       	std	Y+1, r24	; 0x01
	GPIO_PinWrite(LCDConfig.D0, util_IsBitSet(dataByte, 0));
    323a:	89 81       	ldd	r24, Y+1	; 0x01
    323c:	88 2f       	mov	r24, r24
    323e:	90 e0       	ldi	r25, 0x00	; 0
    3240:	81 70       	andi	r24, 0x01	; 1
    3242:	99 27       	eor	r25, r25
    3244:	21 e0       	ldi	r18, 0x01	; 1
    3246:	00 97       	sbiw	r24, 0x00	; 0
    3248:	09 f4       	brne	.+2      	; 0x324c <lcd_SendLowerNibble+0x1e>
    324a:	20 e0       	ldi	r18, 0x00	; 0
    324c:	92 2f       	mov	r25, r18
    324e:	80 91 22 01 	lds	r24, 0x0122
    3252:	69 2f       	mov	r22, r25
    3254:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D1, util_IsBitSet(dataByte, 1));
    3258:	89 81       	ldd	r24, Y+1	; 0x01
    325a:	88 2f       	mov	r24, r24
    325c:	90 e0       	ldi	r25, 0x00	; 0
    325e:	82 70       	andi	r24, 0x02	; 2
    3260:	99 27       	eor	r25, r25
    3262:	21 e0       	ldi	r18, 0x01	; 1
    3264:	00 97       	sbiw	r24, 0x00	; 0
    3266:	09 f4       	brne	.+2      	; 0x326a <lcd_SendLowerNibble+0x3c>
    3268:	20 e0       	ldi	r18, 0x00	; 0
    326a:	92 2f       	mov	r25, r18
    326c:	80 91 23 01 	lds	r24, 0x0123
    3270:	69 2f       	mov	r22, r25
    3272:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D2, util_IsBitSet(dataByte, 2));
    3276:	89 81       	ldd	r24, Y+1	; 0x01
    3278:	88 2f       	mov	r24, r24
    327a:	90 e0       	ldi	r25, 0x00	; 0
    327c:	84 70       	andi	r24, 0x04	; 4
    327e:	99 27       	eor	r25, r25
    3280:	21 e0       	ldi	r18, 0x01	; 1
    3282:	00 97       	sbiw	r24, 0x00	; 0
    3284:	09 f4       	brne	.+2      	; 0x3288 <lcd_SendLowerNibble+0x5a>
    3286:	20 e0       	ldi	r18, 0x00	; 0
    3288:	92 2f       	mov	r25, r18
    328a:	80 91 24 01 	lds	r24, 0x0124
    328e:	69 2f       	mov	r22, r25
    3290:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.D3, util_IsBitSet(dataByte, 3));
    3294:	89 81       	ldd	r24, Y+1	; 0x01
    3296:	88 2f       	mov	r24, r24
    3298:	90 e0       	ldi	r25, 0x00	; 0
    329a:	88 70       	andi	r24, 0x08	; 8
    329c:	99 27       	eor	r25, r25
    329e:	21 e0       	ldi	r18, 0x01	; 1
    32a0:	00 97       	sbiw	r24, 0x00	; 0
    32a2:	09 f4       	brne	.+2      	; 0x32a6 <lcd_SendLowerNibble+0x78>
    32a4:	20 e0       	ldi	r18, 0x00	; 0
    32a6:	92 2f       	mov	r25, r18
    32a8:	80 91 25 01 	lds	r24, 0x0125
    32ac:	69 2f       	mov	r22, r25
    32ae:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
}
    32b2:	0f 90       	pop	r0
    32b4:	df 91       	pop	r29
    32b6:	cf 91       	pop	r28
    32b8:	08 95       	ret

000032ba <lcd_SendCmdSignals>:
 * I/P Arguments: none
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
 **************************************************************************************************/
static void lcd_SendCmdSignals(void) {
    32ba:	cf 93       	push	r28
    32bc:	df 93       	push	r29
    32be:	cd b7       	in	r28, 0x3d	; 61
    32c0:	de b7       	in	r29, 0x3e	; 62
	GPIO_PinWrite(LCDConfig.RS, 0);
    32c2:	80 91 1f 01 	lds	r24, 0x011F
    32c6:	60 e0       	ldi	r22, 0x00	; 0
    32c8:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.RW, 0);
    32cc:	80 91 20 01 	lds	r24, 0x0120
    32d0:	60 e0       	ldi	r22, 0x00	; 0
    32d2:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.EN, 1);
    32d6:	80 91 21 01 	lds	r24, 0x0121
    32da:	61 e0       	ldi	r22, 0x01	; 1
    32dc:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	DELAY_us(10);
    32e0:	8a e0       	ldi	r24, 0x0A	; 10
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
	GPIO_PinWrite(LCDConfig.EN, 0);
    32e8:	80 91 21 01 	lds	r24, 0x0121
    32ec:	60 e0       	ldi	r22, 0x00	; 0
    32ee:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>

}
    32f2:	df 91       	pop	r29
    32f4:	cf 91       	pop	r28
    32f6:	08 95       	ret

000032f8 <lcd_SendDataSignals>:
 * I/P Arguments: none
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
 **************************************************************************************************/
static void lcd_SendDataSignals(void) {
    32f8:	cf 93       	push	r28
    32fa:	df 93       	push	r29
    32fc:	cd b7       	in	r28, 0x3d	; 61
    32fe:	de b7       	in	r29, 0x3e	; 62
	GPIO_PinWrite(LCDConfig.RS, 1);
    3300:	80 91 1f 01 	lds	r24, 0x011F
    3304:	61 e0       	ldi	r22, 0x01	; 1
    3306:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.RW, 0);
    330a:	80 91 20 01 	lds	r24, 0x0120
    330e:	60 e0       	ldi	r22, 0x00	; 0
    3310:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	GPIO_PinWrite(LCDConfig.EN, 1);
    3314:	80 91 21 01 	lds	r24, 0x0121
    3318:	61 e0       	ldi	r22, 0x01	; 1
    331a:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
	DELAY_us(10);
    331e:	8a e0       	ldi	r24, 0x0A	; 10
    3320:	90 e0       	ldi	r25, 0x00	; 0
    3322:	0e 94 c5 06 	call	0xd8a	; 0xd8a <DELAY_us>
	GPIO_PinWrite(LCDConfig.EN, 0);
    3326:	80 91 21 01 	lds	r24, 0x0121
    332a:	60 e0       	ldi	r22, 0x00	; 0
    332c:	0e 94 8f 0a 	call	0x151e	; 0x151e <GPIO_PinWrite>
}
    3330:	df 91       	pop	r29
    3332:	cf 91       	pop	r28
    3334:	08 95       	ret

00003336 <LCD_RefreshScreen>:

void LCD_RefreshScreen(int *clock, int valueToRefresh) {
    3336:	cf 93       	push	r28
    3338:	df 93       	push	r29
    333a:	00 d0       	rcall	.+0      	; 0x333c <LCD_RefreshScreen+0x6>
    333c:	00 d0       	rcall	.+0      	; 0x333e <LCD_RefreshScreen+0x8>
    333e:	cd b7       	in	r28, 0x3d	; 61
    3340:	de b7       	in	r29, 0x3e	; 62
    3342:	9a 83       	std	Y+2, r25	; 0x02
    3344:	89 83       	std	Y+1, r24	; 0x01
    3346:	7c 83       	std	Y+4, r23	; 0x04
    3348:	6b 83       	std	Y+3, r22	; 0x03
	clock++;
    334a:	89 81       	ldd	r24, Y+1	; 0x01
    334c:	9a 81       	ldd	r25, Y+2	; 0x02
    334e:	02 96       	adiw	r24, 0x02	; 2
    3350:	9a 83       	std	Y+2, r25	; 0x02
    3352:	89 83       	std	Y+1, r24	; 0x01
	if ((*clock) >= valueToRefresh) {
    3354:	89 81       	ldd	r24, Y+1	; 0x01
    3356:	9a 81       	ldd	r25, Y+2	; 0x02
    3358:	fc 01       	movw	r30, r24
    335a:	20 81       	ld	r18, Z
    335c:	31 81       	ldd	r19, Z+1	; 0x01
    335e:	8b 81       	ldd	r24, Y+3	; 0x03
    3360:	9c 81       	ldd	r25, Y+4	; 0x04
    3362:	28 17       	cp	r18, r24
    3364:	39 07       	cpc	r19, r25
    3366:	4c f1       	brlt	.+82     	; 0x33ba <LCD_RefreshScreen+0x84>
		LCD_XYPrintf(0, 0, LCD_BUFFOR[0]);
    3368:	8c ef       	ldi	r24, 0xFC	; 252
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	89 2f       	mov	r24, r25
    336e:	8f 93       	push	r24
    3370:	8c ef       	ldi	r24, 0xFC	; 252
    3372:	90 e0       	ldi	r25, 0x00	; 0
    3374:	8f 93       	push	r24
    3376:	1f 92       	push	r1
    3378:	1f 92       	push	r1
    337a:	1f 92       	push	r1
    337c:	1f 92       	push	r1
    337e:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
    3382:	0f 90       	pop	r0
    3384:	0f 90       	pop	r0
    3386:	0f 90       	pop	r0
    3388:	0f 90       	pop	r0
    338a:	0f 90       	pop	r0
    338c:	0f 90       	pop	r0
		LCD_XYPrintf(1, 0, LCD_BUFFOR[1]);
    338e:	8c e0       	ldi	r24, 0x0C	; 12
    3390:	91 e0       	ldi	r25, 0x01	; 1
    3392:	89 2f       	mov	r24, r25
    3394:	8f 93       	push	r24
    3396:	8c e0       	ldi	r24, 0x0C	; 12
    3398:	91 e0       	ldi	r25, 0x01	; 1
    339a:	8f 93       	push	r24
    339c:	1f 92       	push	r1
    339e:	1f 92       	push	r1
    33a0:	1f 92       	push	r1
    33a2:	81 e0       	ldi	r24, 0x01	; 1
    33a4:	8f 93       	push	r24
    33a6:	0e 94 ab 12 	call	0x2556	; 0x2556 <LCD_XYPrintf>
    33aa:	0f 90       	pop	r0
    33ac:	0f 90       	pop	r0
    33ae:	0f 90       	pop	r0
    33b0:	0f 90       	pop	r0
    33b2:	0f 90       	pop	r0
    33b4:	0f 90       	pop	r0
		clock = 0;
    33b6:	1a 82       	std	Y+2, r1	; 0x02
    33b8:	19 82       	std	Y+1, r1	; 0x01
	}
}
    33ba:	0f 90       	pop	r0
    33bc:	0f 90       	pop	r0
    33be:	0f 90       	pop	r0
    33c0:	0f 90       	pop	r0
    33c2:	df 91       	pop	r29
    33c4:	cf 91       	pop	r28
    33c6:	08 95       	ret

000033c8 <LCD_InitializeSymbols>:

void LCD_InitializeSymbols() {
    33c8:	cf 93       	push	r28
    33ca:	df 93       	push	r29
    33cc:	cd b7       	in	r28, 0x3d	; 61
    33ce:	de b7       	in	r29, 0x3e	; 62
    33d0:	cc 54       	subi	r28, 0x4C	; 76
    33d2:	d1 09       	sbc	r29, r1
    33d4:	0f b6       	in	r0, 0x3f	; 63
    33d6:	f8 94       	cli
    33d8:	de bf       	out	0x3e, r29	; 62
    33da:	0f be       	out	0x3f, r0	; 63
    33dc:	cd bf       	out	0x3d, r28	; 61
	/*
	 *  To generate new hex code of characters use page "https://maxpromer.github.io/LCD-Character-Creator/"
	 */
	uint8_t addresses[8] = { 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78 };
    33de:	88 e0       	ldi	r24, 0x08	; 8
    33e0:	ea ea       	ldi	r30, 0xAA	; 170
    33e2:	f0 e0       	ldi	r31, 0x00	; 0
    33e4:	de 01       	movw	r26, r28
    33e6:	15 96       	adiw	r26, 0x05	; 5
    33e8:	01 90       	ld	r0, Z+
    33ea:	0d 92       	st	X+, r0
    33ec:	8a 95       	dec	r24
    33ee:	e1 f7       	brne	.-8      	; 0x33e8 <LCD_InitializeSymbols+0x20>

	uint8_t symbols[8][8] = {
    33f0:	80 e4       	ldi	r24, 0x40	; 64
    33f2:	e2 eb       	ldi	r30, 0xB2	; 178
    33f4:	f0 e0       	ldi	r31, 0x00	; 0
    33f6:	de 01       	movw	r26, r28
    33f8:	1d 96       	adiw	r26, 0x0d	; 13
    33fa:	01 90       	ld	r0, Z+
    33fc:	0d 92       	st	X+, r0
    33fe:	8a 95       	dec	r24
    3400:	e1 f7       	brne	.-8      	; 0x33fa <LCD_InitializeSymbols+0x32>
			//7 character (padlock) ':'
			{ 0x0E, 0x11, 0x11, 0x11, 0x1F, 0x1B, 0x1B, 0x1F },
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
    3402:	1a 82       	std	Y+2, r1	; 0x02
    3404:	19 82       	std	Y+1, r1	; 0x01
    3406:	33 c0       	rjmp	.+102    	; 0x346e <LCD_InitializeSymbols+0xa6>
		LCD_CmdWrite(addresses[clkAddress]);
    3408:	9e 01       	movw	r18, r28
    340a:	2b 5f       	subi	r18, 0xFB	; 251
    340c:	3f 4f       	sbci	r19, 0xFF	; 255
    340e:	89 81       	ldd	r24, Y+1	; 0x01
    3410:	9a 81       	ldd	r25, Y+2	; 0x02
    3412:	82 0f       	add	r24, r18
    3414:	93 1f       	adc	r25, r19
    3416:	fc 01       	movw	r30, r24
    3418:	80 81       	ld	r24, Z
    341a:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <LCD_CmdWrite>
		for (int clkData = 0; clkData < 8; clkData++) {
    341e:	1c 82       	std	Y+4, r1	; 0x04
    3420:	1b 82       	std	Y+3, r1	; 0x03
    3422:	1b c0       	rjmp	.+54     	; 0x345a <LCD_InitializeSymbols+0x92>
			LCD_DataWrite(symbols[clkAddress][clkData]);
    3424:	89 81       	ldd	r24, Y+1	; 0x01
    3426:	9a 81       	ldd	r25, Y+2	; 0x02
    3428:	88 0f       	add	r24, r24
    342a:	99 1f       	adc	r25, r25
    342c:	88 0f       	add	r24, r24
    342e:	99 1f       	adc	r25, r25
    3430:	88 0f       	add	r24, r24
    3432:	99 1f       	adc	r25, r25
    3434:	9e 01       	movw	r18, r28
    3436:	2f 5f       	subi	r18, 0xFF	; 255
    3438:	3f 4f       	sbci	r19, 0xFF	; 255
    343a:	28 0f       	add	r18, r24
    343c:	39 1f       	adc	r19, r25
    343e:	8b 81       	ldd	r24, Y+3	; 0x03
    3440:	9c 81       	ldd	r25, Y+4	; 0x04
    3442:	82 0f       	add	r24, r18
    3444:	93 1f       	adc	r25, r19
    3446:	0c 96       	adiw	r24, 0x0c	; 12
    3448:	fc 01       	movw	r30, r24
    344a:	80 81       	ld	r24, Z
    344c:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
		LCD_CmdWrite(addresses[clkAddress]);
		for (int clkData = 0; clkData < 8; clkData++) {
    3450:	8b 81       	ldd	r24, Y+3	; 0x03
    3452:	9c 81       	ldd	r25, Y+4	; 0x04
    3454:	01 96       	adiw	r24, 0x01	; 1
    3456:	9c 83       	std	Y+4, r25	; 0x04
    3458:	8b 83       	std	Y+3, r24	; 0x03
    345a:	8b 81       	ldd	r24, Y+3	; 0x03
    345c:	9c 81       	ldd	r25, Y+4	; 0x04
    345e:	88 30       	cpi	r24, 0x08	; 8
    3460:	91 05       	cpc	r25, r1
    3462:	04 f3       	brlt	.-64     	; 0x3424 <LCD_InitializeSymbols+0x5c>
			//7 character (padlock) ':'
			{ 0x0E, 0x11, 0x11, 0x11, 0x1F, 0x1B, 0x1B, 0x1F },
			//8 character (standby) ';'
			{ 0x00, 0x04, 0x04, 0x0E, 0x15, 0x15, 0x11, 0x0E } };

	for (int clkAddress = 0; clkAddress < 8; clkAddress++) {
    3464:	89 81       	ldd	r24, Y+1	; 0x01
    3466:	9a 81       	ldd	r25, Y+2	; 0x02
    3468:	01 96       	adiw	r24, 0x01	; 1
    346a:	9a 83       	std	Y+2, r25	; 0x02
    346c:	89 83       	std	Y+1, r24	; 0x01
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	88 30       	cpi	r24, 0x08	; 8
    3474:	91 05       	cpc	r25, r1
    3476:	44 f2       	brlt	.-112    	; 0x3408 <LCD_InitializeSymbols+0x40>
		LCD_CmdWrite(addresses[clkAddress]);
		for (int clkData = 0; clkData < 8; clkData++) {
			LCD_DataWrite(symbols[clkAddress][clkData]);
		}
	}
}
    3478:	c4 5b       	subi	r28, 0xB4	; 180
    347a:	df 4f       	sbci	r29, 0xFF	; 255
    347c:	0f b6       	in	r0, 0x3f	; 63
    347e:	f8 94       	cli
    3480:	de bf       	out	0x3e, r29	; 62
    3482:	0f be       	out	0x3f, r0	; 63
    3484:	cd bf       	out	0x3d, r28	; 61
    3486:	df 91       	pop	r29
    3488:	cf 91       	pop	r28
    348a:	08 95       	ret

0000348c <LCD_PrintSymbol>:

void LCD_PrintSymbol(int number) {
    348c:	cf 93       	push	r28
    348e:	df 93       	push	r29
    3490:	00 d0       	rcall	.+0      	; 0x3492 <LCD_PrintSymbol+0x6>
    3492:	cd b7       	in	r28, 0x3d	; 61
    3494:	de b7       	in	r29, 0x3e	; 62
    3496:	9a 83       	std	Y+2, r25	; 0x02
    3498:	89 83       	std	Y+1, r24	; 0x01
	if (number == 1)
    349a:	89 81       	ldd	r24, Y+1	; 0x01
    349c:	9a 81       	ldd	r25, Y+2	; 0x02
    349e:	81 30       	cpi	r24, 0x01	; 1
    34a0:	91 05       	cpc	r25, r1
    34a2:	21 f4       	brne	.+8      	; 0x34ac <LCD_PrintSymbol+0x20>
		LCD_DataWrite(0x00);
    34a4:	80 e0       	ldi	r24, 0x00	; 0
    34a6:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
    34aa:	3e c0       	rjmp	.+124    	; 0x3528 <LCD_PrintSymbol+0x9c>
	else if (number == 2)
    34ac:	89 81       	ldd	r24, Y+1	; 0x01
    34ae:	9a 81       	ldd	r25, Y+2	; 0x02
    34b0:	82 30       	cpi	r24, 0x02	; 2
    34b2:	91 05       	cpc	r25, r1
    34b4:	21 f4       	brne	.+8      	; 0x34be <LCD_PrintSymbol+0x32>
		LCD_DataWrite(0x01);
    34b6:	81 e0       	ldi	r24, 0x01	; 1
    34b8:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
    34bc:	35 c0       	rjmp	.+106    	; 0x3528 <LCD_PrintSymbol+0x9c>
	else if (number == 3)
    34be:	89 81       	ldd	r24, Y+1	; 0x01
    34c0:	9a 81       	ldd	r25, Y+2	; 0x02
    34c2:	83 30       	cpi	r24, 0x03	; 3
    34c4:	91 05       	cpc	r25, r1
    34c6:	21 f4       	brne	.+8      	; 0x34d0 <LCD_PrintSymbol+0x44>
		LCD_DataWrite(0x02);
    34c8:	82 e0       	ldi	r24, 0x02	; 2
    34ca:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
    34ce:	2c c0       	rjmp	.+88     	; 0x3528 <LCD_PrintSymbol+0x9c>
	else if (number == 4)
    34d0:	89 81       	ldd	r24, Y+1	; 0x01
    34d2:	9a 81       	ldd	r25, Y+2	; 0x02
    34d4:	84 30       	cpi	r24, 0x04	; 4
    34d6:	91 05       	cpc	r25, r1
    34d8:	21 f4       	brne	.+8      	; 0x34e2 <LCD_PrintSymbol+0x56>
		LCD_DataWrite(0x03);
    34da:	83 e0       	ldi	r24, 0x03	; 3
    34dc:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
    34e0:	23 c0       	rjmp	.+70     	; 0x3528 <LCD_PrintSymbol+0x9c>
	else if (number == 5)
    34e2:	89 81       	ldd	r24, Y+1	; 0x01
    34e4:	9a 81       	ldd	r25, Y+2	; 0x02
    34e6:	85 30       	cpi	r24, 0x05	; 5
    34e8:	91 05       	cpc	r25, r1
    34ea:	21 f4       	brne	.+8      	; 0x34f4 <LCD_PrintSymbol+0x68>
		LCD_DataWrite(0x04);
    34ec:	84 e0       	ldi	r24, 0x04	; 4
    34ee:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
    34f2:	1a c0       	rjmp	.+52     	; 0x3528 <LCD_PrintSymbol+0x9c>
	else if (number == 6)
    34f4:	89 81       	ldd	r24, Y+1	; 0x01
    34f6:	9a 81       	ldd	r25, Y+2	; 0x02
    34f8:	86 30       	cpi	r24, 0x06	; 6
    34fa:	91 05       	cpc	r25, r1
    34fc:	21 f4       	brne	.+8      	; 0x3506 <LCD_PrintSymbol+0x7a>
		LCD_DataWrite(0x05);
    34fe:	85 e0       	ldi	r24, 0x05	; 5
    3500:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
    3504:	11 c0       	rjmp	.+34     	; 0x3528 <LCD_PrintSymbol+0x9c>
	else if (number == 7)
    3506:	89 81       	ldd	r24, Y+1	; 0x01
    3508:	9a 81       	ldd	r25, Y+2	; 0x02
    350a:	87 30       	cpi	r24, 0x07	; 7
    350c:	91 05       	cpc	r25, r1
    350e:	21 f4       	brne	.+8      	; 0x3518 <LCD_PrintSymbol+0x8c>
		LCD_DataWrite(0x06);
    3510:	86 e0       	ldi	r24, 0x06	; 6
    3512:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
    3516:	08 c0       	rjmp	.+16     	; 0x3528 <LCD_PrintSymbol+0x9c>
	else if (number == 8)
    3518:	89 81       	ldd	r24, Y+1	; 0x01
    351a:	9a 81       	ldd	r25, Y+2	; 0x02
    351c:	88 30       	cpi	r24, 0x08	; 8
    351e:	91 05       	cpc	r25, r1
    3520:	19 f4       	brne	.+6      	; 0x3528 <LCD_PrintSymbol+0x9c>
		LCD_DataWrite(0x07);
    3522:	87 e0       	ldi	r24, 0x07	; 7
    3524:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
}
    3528:	0f 90       	pop	r0
    352a:	0f 90       	pop	r0
    352c:	df 91       	pop	r29
    352e:	cf 91       	pop	r28
    3530:	08 95       	ret

00003532 <LCD_PrintBlock>:

void LCD_PrintBlock() {
    3532:	cf 93       	push	r28
    3534:	df 93       	push	r29
    3536:	cd b7       	in	r28, 0x3d	; 61
    3538:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0xFF);
    353a:	8f ef       	ldi	r24, 0xFF	; 255
    353c:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
}
    3540:	df 91       	pop	r29
    3542:	cf 91       	pop	r28
    3544:	08 95       	ret

00003546 <LCD_PrintLArrow>:

void LCD_PrintLArrow() {
    3546:	cf 93       	push	r28
    3548:	df 93       	push	r29
    354a:	cd b7       	in	r28, 0x3d	; 61
    354c:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0x7F);
    354e:	8f e7       	ldi	r24, 0x7F	; 127
    3550:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
}
    3554:	df 91       	pop	r29
    3556:	cf 91       	pop	r28
    3558:	08 95       	ret

0000355a <LCD_PrintRArrow>:

void LCD_PrintRArrow() {
    355a:	cf 93       	push	r28
    355c:	df 93       	push	r29
    355e:	cd b7       	in	r28, 0x3d	; 61
    3560:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0x7E);
    3562:	8e e7       	ldi	r24, 0x7E	; 126
    3564:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
}
    3568:	df 91       	pop	r29
    356a:	cf 91       	pop	r28
    356c:	08 95       	ret

0000356e <LCD_PrintDot>:

void LCD_PrintDot() {
    356e:	cf 93       	push	r28
    3570:	df 93       	push	r29
    3572:	cd b7       	in	r28, 0x3d	; 61
    3574:	de b7       	in	r29, 0x3e	; 62
	LCD_DataWrite(0xA5);
    3576:	85 ea       	ldi	r24, 0xA5	; 165
    3578:	0e 94 32 18 	call	0x3064	; 0x3064 <LCD_DataWrite>
}
    357c:	df 91       	pop	r29
    357e:	cf 91       	pop	r28
    3580:	08 95       	ret

00003582 <UART_Init>:


		    Refer uart.h file for Supported(range) baud rates.		
***************************************************************************************************/
void UART_Init(uint32_t v_baudRate_u32)
{
    3582:	cf 93       	push	r28
    3584:	df 93       	push	r29
    3586:	00 d0       	rcall	.+0      	; 0x3588 <UART_Init+0x6>
    3588:	00 d0       	rcall	.+0      	; 0x358a <UART_Init+0x8>
    358a:	cd b7       	in	r28, 0x3d	; 61
    358c:	de b7       	in	r29, 0x3e	; 62
    358e:	69 83       	std	Y+1, r22	; 0x01
    3590:	7a 83       	std	Y+2, r23	; 0x02
    3592:	8b 83       	std	Y+3, r24	; 0x03
    3594:	9c 83       	std	Y+4, r25	; 0x04
	UCSRB= (1<<RXEN) | (1<<TXEN);                  // Enable Receiver and Transmitter
    3596:	8a e2       	ldi	r24, 0x2A	; 42
    3598:	90 e0       	ldi	r25, 0x00	; 0
    359a:	28 e1       	ldi	r18, 0x18	; 24
    359c:	fc 01       	movw	r30, r24
    359e:	20 83       	st	Z, r18
	UCSRC= (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);   // Asynchronous mode 8-bit data and 1-stop bit
    35a0:	80 e4       	ldi	r24, 0x40	; 64
    35a2:	90 e0       	ldi	r25, 0x00	; 0
    35a4:	26 e8       	ldi	r18, 0x86	; 134
    35a6:	fc 01       	movw	r30, r24
    35a8:	20 83       	st	Z, r18
	UCSRA= 0x00;                                   // Clear the UASRT status register
    35aa:	8b e2       	ldi	r24, 0x2B	; 43
    35ac:	90 e0       	ldi	r25, 0x00	; 0
    35ae:	fc 01       	movw	r30, r24
    35b0:	10 82       	st	Z, r1
	UART_SetBaudRate(v_baudRate_u32);
    35b2:	89 81       	ldd	r24, Y+1	; 0x01
    35b4:	9a 81       	ldd	r25, Y+2	; 0x02
    35b6:	ab 81       	ldd	r26, Y+3	; 0x03
    35b8:	bc 81       	ldd	r27, Y+4	; 0x04
    35ba:	bc 01       	movw	r22, r24
    35bc:	cd 01       	movw	r24, r26
    35be:	0e 94 e8 1a 	call	0x35d0	; 0x35d0 <UART_SetBaudRate>
}
    35c2:	0f 90       	pop	r0
    35c4:	0f 90       	pop	r0
    35c6:	0f 90       	pop	r0
    35c8:	0f 90       	pop	r0
    35ca:	df 91       	pop	r29
    35cc:	cf 91       	pop	r28
    35ce:	08 95       	ret

000035d0 <UART_SetBaudRate>:
                 the default baudrate of 9600 is set.

		    Refer uart.h file for Supported range of baud rates.
***************************************************************************************************/
void UART_SetBaudRate(uint32_t v_baudRate_u32)
{
    35d0:	ef 92       	push	r14
    35d2:	ff 92       	push	r15
    35d4:	0f 93       	push	r16
    35d6:	1f 93       	push	r17
    35d8:	cf 93       	push	r28
    35da:	df 93       	push	r29
    35dc:	cd b7       	in	r28, 0x3d	; 61
    35de:	de b7       	in	r29, 0x3e	; 62
    35e0:	2a 97       	sbiw	r28, 0x0a	; 10
    35e2:	0f b6       	in	r0, 0x3f	; 63
    35e4:	f8 94       	cli
    35e6:	de bf       	out	0x3e, r29	; 62
    35e8:	0f be       	out	0x3f, r0	; 63
    35ea:	cd bf       	out	0x3d, r28	; 61
    35ec:	6b 83       	std	Y+3, r22	; 0x03
    35ee:	7c 83       	std	Y+4, r23	; 0x04
    35f0:	8d 83       	std	Y+5, r24	; 0x05
    35f2:	9e 83       	std	Y+6, r25	; 0x06
	uint16_t RegValue;

	if((v_baudRate_u32 >= C_MinBaudRate_U32) && (v_baudRate_u32<=C_MaxBaudRate_U32))
    35f4:	8b 81       	ldd	r24, Y+3	; 0x03
    35f6:	9c 81       	ldd	r25, Y+4	; 0x04
    35f8:	ad 81       	ldd	r26, Y+5	; 0x05
    35fa:	be 81       	ldd	r27, Y+6	; 0x06
    35fc:	80 36       	cpi	r24, 0x60	; 96
    35fe:	29 e0       	ldi	r18, 0x09	; 9
    3600:	92 07       	cpc	r25, r18
    3602:	a1 05       	cpc	r26, r1
    3604:	b1 05       	cpc	r27, r1
    3606:	08 f4       	brcc	.+2      	; 0x360a <UART_SetBaudRate+0x3a>
    3608:	47 c0       	rjmp	.+142    	; 0x3698 <UART_SetBaudRate+0xc8>
    360a:	8b 81       	ldd	r24, Y+3	; 0x03
    360c:	9c 81       	ldd	r25, Y+4	; 0x04
    360e:	ad 81       	ldd	r26, Y+5	; 0x05
    3610:	be 81       	ldd	r27, Y+6	; 0x06
    3612:	81 30       	cpi	r24, 0x01	; 1
    3614:	e2 ec       	ldi	r30, 0xC2	; 194
    3616:	9e 07       	cpc	r25, r30
    3618:	e1 e0       	ldi	r30, 0x01	; 1
    361a:	ae 07       	cpc	r26, r30
    361c:	b1 05       	cpc	r27, r1
    361e:	e0 f5       	brcc	.+120    	; 0x3698 <UART_SetBaudRate+0xc8>
	{
		/* Check if the requested baudate is within range,
	     If yes then calculate the value to be loaded into baud rate generator. */
		RegValue = M_GetBaudRateGeneratorValue(v_baudRate_u32);
    3620:	2b 81       	ldd	r18, Y+3	; 0x03
    3622:	3c 81       	ldd	r19, Y+4	; 0x04
    3624:	4d 81       	ldd	r20, Y+5	; 0x05
    3626:	5e 81       	ldd	r21, Y+6	; 0x06
    3628:	80 e0       	ldi	r24, 0x00	; 0
    362a:	90 e0       	ldi	r25, 0x00	; 0
    362c:	dc 01       	movw	r26, r24
    362e:	82 1b       	sub	r24, r18
    3630:	93 0b       	sbc	r25, r19
    3632:	a4 0b       	sbc	r26, r20
    3634:	b5 0b       	sbc	r27, r21
    3636:	88 0f       	add	r24, r24
    3638:	99 1f       	adc	r25, r25
    363a:	aa 1f       	adc	r26, r26
    363c:	bb 1f       	adc	r27, r27
    363e:	88 0f       	add	r24, r24
    3640:	99 1f       	adc	r25, r25
    3642:	aa 1f       	adc	r26, r26
    3644:	bb 1f       	adc	r27, r27
    3646:	88 0f       	add	r24, r24
    3648:	99 1f       	adc	r25, r25
    364a:	aa 1f       	adc	r26, r26
    364c:	bb 1f       	adc	r27, r27
    364e:	7c 01       	movw	r14, r24
    3650:	8d 01       	movw	r16, r26
    3652:	fe ee       	ldi	r31, 0xEE	; 238
    3654:	ff 1a       	sub	r15, r31
    3656:	05 48       	sbci	r16, 0x85	; 133
    3658:	1f 4f       	sbci	r17, 0xFF	; 255
    365a:	8b 81       	ldd	r24, Y+3	; 0x03
    365c:	9c 81       	ldd	r25, Y+4	; 0x04
    365e:	ad 81       	ldd	r26, Y+5	; 0x05
    3660:	be 81       	ldd	r27, Y+6	; 0x06
    3662:	88 0f       	add	r24, r24
    3664:	99 1f       	adc	r25, r25
    3666:	aa 1f       	adc	r26, r26
    3668:	bb 1f       	adc	r27, r27
    366a:	88 0f       	add	r24, r24
    366c:	99 1f       	adc	r25, r25
    366e:	aa 1f       	adc	r26, r26
    3670:	bb 1f       	adc	r27, r27
    3672:	88 0f       	add	r24, r24
    3674:	99 1f       	adc	r25, r25
    3676:	aa 1f       	adc	r26, r26
    3678:	bb 1f       	adc	r27, r27
    367a:	88 0f       	add	r24, r24
    367c:	99 1f       	adc	r25, r25
    367e:	aa 1f       	adc	r26, r26
    3680:	bb 1f       	adc	r27, r27
    3682:	9c 01       	movw	r18, r24
    3684:	ad 01       	movw	r20, r26
    3686:	c8 01       	movw	r24, r16
    3688:	b7 01       	movw	r22, r14
    368a:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__udivmodsi4>
    368e:	da 01       	movw	r26, r20
    3690:	c9 01       	movw	r24, r18
    3692:	9a 83       	std	Y+2, r25	; 0x02
    3694:	89 83       	std	Y+1, r24	; 0x01
    3696:	04 c0       	rjmp	.+8      	; 0x36a0 <UART_SetBaudRate+0xd0>
	}
	else
	{
		/*	 Invalid baudrate requested, hence set it to default baudrate of 9600 */
		RegValue = M_GetBaudRateGeneratorValue(9600);
    3698:	83 e3       	ldi	r24, 0x33	; 51
    369a:	90 e0       	ldi	r25, 0x00	; 0
    369c:	9a 83       	std	Y+2, r25	; 0x02
    369e:	89 83       	std	Y+1, r24	; 0x01
	}

	UBRRL = util_ExtractByte0to8(RegValue);
    36a0:	89 e2       	ldi	r24, 0x29	; 41
    36a2:	90 e0       	ldi	r25, 0x00	; 0
    36a4:	29 81       	ldd	r18, Y+1	; 0x01
    36a6:	fc 01       	movw	r30, r24
    36a8:	20 83       	st	Z, r18
	UBRRH = util_ExtractByte8to16(RegValue);
    36aa:	80 e4       	ldi	r24, 0x40	; 64
    36ac:	90 e0       	ldi	r25, 0x00	; 0
    36ae:	29 81       	ldd	r18, Y+1	; 0x01
    36b0:	3a 81       	ldd	r19, Y+2	; 0x02
    36b2:	23 2f       	mov	r18, r19
    36b4:	33 27       	eor	r19, r19
    36b6:	fc 01       	movw	r30, r24
    36b8:	20 83       	st	Z, r18
}
    36ba:	2a 96       	adiw	r28, 0x0a	; 10
    36bc:	0f b6       	in	r0, 0x3f	; 63
    36be:	f8 94       	cli
    36c0:	de bf       	out	0x3e, r29	; 62
    36c2:	0f be       	out	0x3f, r0	; 63
    36c4:	cd bf       	out	0x3d, r28	; 61
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	1f 91       	pop	r17
    36cc:	0f 91       	pop	r16
    36ce:	ff 90       	pop	r15
    36d0:	ef 90       	pop	r14
    36d2:	08 95       	ret

000036d4 <UART_RxChar>:

 * description :This function is used to receive a char from UART module.
                It waits till a char is received and returns it after reception.
***************************************************************************************************/
char UART_RxChar(void)
{
    36d4:	cf 93       	push	r28
    36d6:	df 93       	push	r29
    36d8:	cd b7       	in	r28, 0x3d	; 61
    36da:	de b7       	in	r29, 0x3e	; 62
	while(util_IsBitCleared(UCSRA,RXC));  // Wait till the data is received
    36dc:	00 00       	nop
    36de:	8b e2       	ldi	r24, 0x2B	; 43
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	fc 01       	movw	r30, r24
    36e4:	80 81       	ld	r24, Z
    36e6:	88 23       	and	r24, r24
    36e8:	d4 f7       	brge	.-12     	; 0x36de <UART_RxChar+0xa>
	return(UDR);                          // return the received char
    36ea:	8c e2       	ldi	r24, 0x2C	; 44
    36ec:	90 e0       	ldi	r25, 0x00	; 0
    36ee:	fc 01       	movw	r30, r24
    36f0:	80 81       	ld	r24, Z
}
    36f2:	df 91       	pop	r29
    36f4:	cf 91       	pop	r28
    36f6:	08 95       	ret

000036f8 <UART_TxChar>:
 * Return value	: none.

 * description  :This function is used to transmit a char through UART module.
***************************************************************************************************/
void UART_TxChar(char v_uartData_u8)
{
    36f8:	cf 93       	push	r28
    36fa:	df 93       	push	r29
    36fc:	1f 92       	push	r1
    36fe:	cd b7       	in	r28, 0x3d	; 61
    3700:	de b7       	in	r29, 0x3e	; 62
    3702:	89 83       	std	Y+1, r24	; 0x01
	while(util_IsBitCleared(UCSRA,UDRE)); // Wait till Transmitter(UDR) register becomes Empty
    3704:	00 00       	nop
    3706:	8b e2       	ldi	r24, 0x2B	; 43
    3708:	90 e0       	ldi	r25, 0x00	; 0
    370a:	fc 01       	movw	r30, r24
    370c:	80 81       	ld	r24, Z
    370e:	88 2f       	mov	r24, r24
    3710:	90 e0       	ldi	r25, 0x00	; 0
    3712:	80 72       	andi	r24, 0x20	; 32
    3714:	99 27       	eor	r25, r25
    3716:	00 97       	sbiw	r24, 0x00	; 0
    3718:	b1 f3       	breq	.-20     	; 0x3706 <UART_TxChar+0xe>
	UDR =v_uartData_u8;                              // Load the data to be transmitted
    371a:	8c e2       	ldi	r24, 0x2C	; 44
    371c:	90 e0       	ldi	r25, 0x00	; 0
    371e:	29 81       	ldd	r18, Y+1	; 0x01
    3720:	fc 01       	movw	r30, r24
    3722:	20 83       	st	Z, r18
}
    3724:	0f 90       	pop	r0
    3726:	df 91       	pop	r29
    3728:	cf 91       	pop	r28
    372a:	08 95       	ret

0000372c <UART_TxString>:
               1.The ptr_string points to the first char of the string
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(char *ptr_string)
{
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29
    3730:	00 d0       	rcall	.+0      	; 0x3732 <UART_TxString+0x6>
    3732:	cd b7       	in	r28, 0x3d	; 61
    3734:	de b7       	in	r29, 0x3e	; 62
    3736:	9a 83       	std	Y+2, r25	; 0x02
    3738:	89 83       	std	Y+1, r24	; 0x01
	while(*ptr_string)
    373a:	0b c0       	rjmp	.+22     	; 0x3752 <UART_TxString+0x26>
		UART_TxChar(*ptr_string++);// Loop through the string and transmit char by char
    373c:	89 81       	ldd	r24, Y+1	; 0x01
    373e:	9a 81       	ldd	r25, Y+2	; 0x02
    3740:	9c 01       	movw	r18, r24
    3742:	2f 5f       	subi	r18, 0xFF	; 255
    3744:	3f 4f       	sbci	r19, 0xFF	; 255
    3746:	3a 83       	std	Y+2, r19	; 0x02
    3748:	29 83       	std	Y+1, r18	; 0x01
    374a:	fc 01       	movw	r30, r24
    374c:	80 81       	ld	r24, Z
    374e:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
                    and traverses till the end(NULL CHAR) and transmits a char each time
***************************************************************************************************/
#if ((Enable_UART_TxString==1)|| (Enable_UART_Printf == 1))
void UART_TxString(char *ptr_string)
{
	while(*ptr_string)
    3752:	89 81       	ldd	r24, Y+1	; 0x01
    3754:	9a 81       	ldd	r25, Y+2	; 0x02
    3756:	fc 01       	movw	r30, r24
    3758:	80 81       	ld	r24, Z
    375a:	88 23       	and	r24, r24
    375c:	79 f7       	brne	.-34     	; 0x373c <UART_TxString+0x10>
		UART_TxChar(*ptr_string++);// Loop through the string and transmit char by char
}
    375e:	0f 90       	pop	r0
    3760:	0f 90       	pop	r0
    3762:	df 91       	pop	r29
    3764:	cf 91       	pop	r28
    3766:	08 95       	ret

00003768 <UART_RxString>:
    if not required then comment UART_TxChar(ch) in the code.
  2.BackSlash is not taken care.
***************************************************************************************************/
#if (Enable_UART_RxString==1)
uint8_t UART_RxString(char *ptr_string)
{
    3768:	cf 93       	push	r28
    376a:	df 93       	push	r29
    376c:	00 d0       	rcall	.+0      	; 0x376e <UART_RxString+0x6>
    376e:	00 d0       	rcall	.+0      	; 0x3770 <UART_RxString+0x8>
    3770:	00 d0       	rcall	.+0      	; 0x3772 <UART_RxString+0xa>
    3772:	cd b7       	in	r28, 0x3d	; 61
    3774:	de b7       	in	r29, 0x3e	; 62
    3776:	9e 83       	std	Y+6, r25	; 0x06
    3778:	8d 83       	std	Y+5, r24	; 0x05
	char ch;
    uint8_t len = 0;
    377a:	19 82       	std	Y+1, r1	; 0x01
	for(int clk=0;clk<1000;clk++)
    377c:	1b 82       	std	Y+3, r1	; 0x03
    377e:	1a 82       	std	Y+2, r1	; 0x02
    3780:	2f c0       	rjmp	.+94     	; 0x37e0 <UART_RxString+0x78>
	{
		ch=UART_RxChar();    //Receive a char
    3782:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <UART_RxChar>
    3786:	8c 83       	std	Y+4, r24	; 0x04
		//UART_TxChar(ch);     //Echo back the received char

		if((ch=='\r') || (ch=='\n')) //read till enter key is pressed
    3788:	8c 81       	ldd	r24, Y+4	; 0x04
    378a:	8d 30       	cpi	r24, 0x0D	; 13
    378c:	19 f0       	breq	.+6      	; 0x3794 <UART_RxString+0x2c>
    378e:	8c 81       	ldd	r24, Y+4	; 0x04
    3790:	8a 30       	cpi	r24, 0x0A	; 10
    3792:	51 f4       	brne	.+20     	; 0x37a8 <UART_RxString+0x40>
		{						     //once enter key is pressed null terminate the string
			ptr_string[len]=0;           //and break the loop
    3794:	89 81       	ldd	r24, Y+1	; 0x01
    3796:	88 2f       	mov	r24, r24
    3798:	90 e0       	ldi	r25, 0x00	; 0
    379a:	2d 81       	ldd	r18, Y+5	; 0x05
    379c:	3e 81       	ldd	r19, Y+6	; 0x06
    379e:	82 0f       	add	r24, r18
    37a0:	93 1f       	adc	r25, r19
    37a2:	fc 01       	movw	r30, r24
    37a4:	10 82       	st	Z, r1
			break;				  
    37a6:	22 c0       	rjmp	.+68     	; 0x37ec <UART_RxString+0x84>
		}
        else if((ch=='\b') && (len!=0))
    37a8:	8c 81       	ldd	r24, Y+4	; 0x04
    37aa:	88 30       	cpi	r24, 0x08	; 8
    37ac:	39 f4       	brne	.+14     	; 0x37bc <UART_RxString+0x54>
    37ae:	89 81       	ldd	r24, Y+1	; 0x01
    37b0:	88 23       	and	r24, r24
    37b2:	21 f0       	breq	.+8      	; 0x37bc <UART_RxString+0x54>
        {
		    len--;    //If backspace is pressed then decrement the index to remove the old char
    37b4:	89 81       	ldd	r24, Y+1	; 0x01
    37b6:	81 50       	subi	r24, 0x01	; 1
    37b8:	89 83       	std	Y+1, r24	; 0x01
    37ba:	0d c0       	rjmp	.+26     	; 0x37d6 <UART_RxString+0x6e>
        }
        else
        {
            ptr_string[len]=ch; //copy the char into string and increment the index
    37bc:	89 81       	ldd	r24, Y+1	; 0x01
    37be:	88 2f       	mov	r24, r24
    37c0:	90 e0       	ldi	r25, 0x00	; 0
    37c2:	2d 81       	ldd	r18, Y+5	; 0x05
    37c4:	3e 81       	ldd	r19, Y+6	; 0x06
    37c6:	82 0f       	add	r24, r18
    37c8:	93 1f       	adc	r25, r19
    37ca:	2c 81       	ldd	r18, Y+4	; 0x04
    37cc:	fc 01       	movw	r30, r24
    37ce:	20 83       	st	Z, r18
            len++;
    37d0:	89 81       	ldd	r24, Y+1	; 0x01
    37d2:	8f 5f       	subi	r24, 0xFF	; 255
    37d4:	89 83       	std	Y+1, r24	; 0x01
#if (Enable_UART_RxString==1)
uint8_t UART_RxString(char *ptr_string)
{
	char ch;
    uint8_t len = 0;
	for(int clk=0;clk<1000;clk++)
    37d6:	8a 81       	ldd	r24, Y+2	; 0x02
    37d8:	9b 81       	ldd	r25, Y+3	; 0x03
    37da:	01 96       	adiw	r24, 0x01	; 1
    37dc:	9b 83       	std	Y+3, r25	; 0x03
    37de:	8a 83       	std	Y+2, r24	; 0x02
    37e0:	8a 81       	ldd	r24, Y+2	; 0x02
    37e2:	9b 81       	ldd	r25, Y+3	; 0x03
    37e4:	88 3e       	cpi	r24, 0xE8	; 232
    37e6:	f3 e0       	ldi	r31, 0x03	; 3
    37e8:	9f 07       	cpc	r25, r31
    37ea:	5c f2       	brlt	.-106    	; 0x3782 <UART_RxString+0x1a>
        {
            ptr_string[len]=ch; //copy the char into string and increment the index
            len++;
        }
	}
  return len;   
    37ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    37ee:	26 96       	adiw	r28, 0x06	; 6
    37f0:	0f b6       	in	r0, 0x3f	; 63
    37f2:	f8 94       	cli
    37f4:	de bf       	out	0x3e, r29	; 62
    37f6:	0f be       	out	0x3f, r0	; 63
    37f8:	cd bf       	out	0x3d, r28	; 61
    37fa:	df 91       	pop	r29
    37fc:	cf 91       	pop	r28
    37fe:	08 95       	ret

00003800 <UART_TxNumber>:
                8.(0x12AB,6) then 6-digits ie. 0012AB will be transmitted
                9.(0x12AB,C_DefaultDigitsToTransmit_U8) then 12AB will be transmitted.    
 ***************************************************************************************************/
#if ((Enable_UART_TxNumber==1) || (Enable_UART_TxFloatNumber==1) || (Enable_UART_Printf == 1))
void UART_TxNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToTransmit_u8)
{
    3800:	ff 92       	push	r15
    3802:	0f 93       	push	r16
    3804:	1f 93       	push	r17
    3806:	cf 93       	push	r28
    3808:	df 93       	push	r29
    380a:	cd b7       	in	r28, 0x3d	; 61
    380c:	de b7       	in	r29, 0x3e	; 62
    380e:	69 97       	sbiw	r28, 0x19	; 25
    3810:	0f b6       	in	r0, 0x3f	; 63
    3812:	f8 94       	cli
    3814:	de bf       	out	0x3e, r29	; 62
    3816:	0f be       	out	0x3f, r0	; 63
    3818:	cd bf       	out	0x3d, r28	; 61
    381a:	8c 87       	std	Y+12, r24	; 0x0c
    381c:	4d 87       	std	Y+13, r20	; 0x0d
    381e:	5e 87       	std	Y+14, r21	; 0x0e
    3820:	6f 87       	std	Y+15, r22	; 0x0f
    3822:	78 8b       	std	Y+16, r23	; 0x10
    3824:	29 8b       	std	Y+17, r18	; 0x11
    uint8_t i=0,a[10];
    3826:	19 82       	std	Y+1, r1	; 0x01

    if(C_BINARY_U8 == v_numericSystem_u8)
    3828:	8c 85       	ldd	r24, Y+12	; 0x0c
    382a:	82 30       	cpi	r24, 0x02	; 2
    382c:	69 f5       	brne	.+90     	; 0x3888 <UART_TxNumber+0x88>
    {
        while(v_numOfDigitsToTransmit_u8!=0)
    382e:	28 c0       	rjmp	.+80     	; 0x3880 <UART_TxNumber+0x80>
        {
            /* Start Extracting the bits from the specified bit positions.
             Get the Acsii values of the bits and transmit */
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
    3830:	89 89       	ldd	r24, Y+17	; 0x11
    3832:	88 2f       	mov	r24, r24
    3834:	90 e0       	ldi	r25, 0x00	; 0
    3836:	9c 01       	movw	r18, r24
    3838:	21 50       	subi	r18, 0x01	; 1
    383a:	31 09       	sbc	r19, r1
    383c:	81 e0       	ldi	r24, 0x01	; 1
    383e:	90 e0       	ldi	r25, 0x00	; 0
    3840:	02 c0       	rjmp	.+4      	; 0x3846 <UART_TxNumber+0x46>
    3842:	88 0f       	add	r24, r24
    3844:	99 1f       	adc	r25, r25
    3846:	2a 95       	dec	r18
    3848:	e2 f7       	brpl	.-8      	; 0x3842 <UART_TxNumber+0x42>
    384a:	9c 01       	movw	r18, r24
    384c:	44 27       	eor	r20, r20
    384e:	37 fd       	sbrc	r19, 7
    3850:	40 95       	com	r20
    3852:	54 2f       	mov	r21, r20
    3854:	8d 85       	ldd	r24, Y+13	; 0x0d
    3856:	9e 85       	ldd	r25, Y+14	; 0x0e
    3858:	af 85       	ldd	r26, Y+15	; 0x0f
    385a:	b8 89       	ldd	r27, Y+16	; 0x10
    385c:	82 23       	and	r24, r18
    385e:	93 23       	and	r25, r19
    3860:	a4 23       	and	r26, r20
    3862:	b5 23       	and	r27, r21
    3864:	21 e0       	ldi	r18, 0x01	; 1
    3866:	00 97       	sbiw	r24, 0x00	; 0
    3868:	a1 05       	cpc	r26, r1
    386a:	b1 05       	cpc	r27, r1
    386c:	09 f4       	brne	.+2      	; 0x3870 <UART_TxNumber+0x70>
    386e:	20 e0       	ldi	r18, 0x00	; 0
    3870:	29 83       	std	Y+1, r18	; 0x01
            UART_TxChar(util_Dec2Ascii(i));
    3872:	89 81       	ldd	r24, Y+1	; 0x01
    3874:	80 5d       	subi	r24, 0xD0	; 208
    3876:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
            v_numOfDigitsToTransmit_u8--;
    387a:	89 89       	ldd	r24, Y+17	; 0x11
    387c:	81 50       	subi	r24, 0x01	; 1
    387e:	89 8b       	std	Y+17, r24	; 0x11
{
    uint8_t i=0,a[10];

    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToTransmit_u8!=0)
    3880:	89 89       	ldd	r24, Y+17	; 0x11
    3882:	88 23       	and	r24, r24
    3884:	a9 f6       	brne	.-86     	; 0x3830 <UART_TxNumber+0x30>
    3886:	9e c0       	rjmp	.+316    	; 0x39c4 <UART_TxNumber+0x1c4>
            i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToTransmit_u8-1));
            UART_TxChar(util_Dec2Ascii(i));
            v_numOfDigitsToTransmit_u8--;
        }    
    }     
    else if(v_number_u32==0)
    3888:	8d 85       	ldd	r24, Y+13	; 0x0d
    388a:	9e 85       	ldd	r25, Y+14	; 0x0e
    388c:	af 85       	ldd	r26, Y+15	; 0x0f
    388e:	b8 89       	ldd	r27, Y+16	; 0x10
    3890:	00 97       	sbiw	r24, 0x00	; 0
    3892:	a1 05       	cpc	r26, r1
    3894:	b1 05       	cpc	r27, r1
    3896:	89 f4       	brne	.+34     	; 0x38ba <UART_TxNumber+0xba>
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
    3898:	19 82       	std	Y+1, r1	; 0x01
    389a:	06 c0       	rjmp	.+12     	; 0x38a8 <UART_TxNumber+0xa8>
            UART_TxChar('0');
    389c:	80 e3       	ldi	r24, 0x30	; 48
    389e:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
        }    
    }     
    else if(v_number_u32==0)
    {
        /* If the number is zero then update the array with the same for transmitting */
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
    38a2:	89 81       	ldd	r24, Y+1	; 0x01
    38a4:	8f 5f       	subi	r24, 0xFF	; 255
    38a6:	89 83       	std	Y+1, r24	; 0x01
    38a8:	99 81       	ldd	r25, Y+1	; 0x01
    38aa:	89 89       	ldd	r24, Y+17	; 0x11
    38ac:	98 17       	cp	r25, r24
    38ae:	08 f0       	brcs	.+2      	; 0x38b2 <UART_TxNumber+0xb2>
    38b0:	89 c0       	rjmp	.+274    	; 0x39c4 <UART_TxNumber+0x1c4>
    38b2:	89 81       	ldd	r24, Y+1	; 0x01
    38b4:	8a 30       	cpi	r24, 0x0A	; 10
    38b6:	90 f3       	brcs	.-28     	; 0x389c <UART_TxNumber+0x9c>
    38b8:	85 c0       	rjmp	.+266    	; 0x39c4 <UART_TxNumber+0x1c4>
            UART_TxChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
    38ba:	19 82       	std	Y+1, r1	; 0x01
    38bc:	4f c0       	rjmp	.+158    	; 0x395c <UART_TxNumber+0x15c>
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToTransmit_u8 */
            if(v_number_u32!=0)
    38be:	8d 85       	ldd	r24, Y+13	; 0x0d
    38c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    38c2:	af 85       	ldd	r26, Y+15	; 0x0f
    38c4:	b8 89       	ldd	r27, Y+16	; 0x10
    38c6:	00 97       	sbiw	r24, 0x00	; 0
    38c8:	a1 05       	cpc	r26, r1
    38ca:	b1 05       	cpc	r27, r1
    38cc:	a1 f1       	breq	.+104    	; 0x3936 <UART_TxNumber+0x136>
                First get the remainder and divide the number by 10 each time.

                example for Decimal number:
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
    38ce:	89 81       	ldd	r24, Y+1	; 0x01
    38d0:	08 2f       	mov	r16, r24
    38d2:	10 e0       	ldi	r17, 0x00	; 0
    38d4:	fd 84       	ldd	r15, Y+13	; 0x0d
    38d6:	8c 85       	ldd	r24, Y+12	; 0x0c
    38d8:	28 2f       	mov	r18, r24
    38da:	30 e0       	ldi	r19, 0x00	; 0
    38dc:	40 e0       	ldi	r20, 0x00	; 0
    38de:	50 e0       	ldi	r21, 0x00	; 0
    38e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    38e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    38e4:	af 85       	ldd	r26, Y+15	; 0x0f
    38e6:	b8 89       	ldd	r27, Y+16	; 0x10
    38e8:	bc 01       	movw	r22, r24
    38ea:	cd 01       	movw	r24, r26
    38ec:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__udivmodsi4>
    38f0:	da 01       	movw	r26, r20
    38f2:	c9 01       	movw	r24, r18
    38f4:	98 2f       	mov	r25, r24
    38f6:	8c 85       	ldd	r24, Y+12	; 0x0c
    38f8:	98 9f       	mul	r25, r24
    38fa:	80 2d       	mov	r24, r0
    38fc:	11 24       	eor	r1, r1
    38fe:	2f 2d       	mov	r18, r15
    3900:	28 1b       	sub	r18, r24
    3902:	ce 01       	movw	r24, r28
    3904:	02 96       	adiw	r24, 0x02	; 2
    3906:	80 0f       	add	r24, r16
    3908:	91 1f       	adc	r25, r17
    390a:	fc 01       	movw	r30, r24
    390c:	20 83       	st	Z, r18
                v_number_u32=v_number_u32/v_numericSystem_u8;
    390e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3910:	28 2f       	mov	r18, r24
    3912:	30 e0       	ldi	r19, 0x00	; 0
    3914:	40 e0       	ldi	r20, 0x00	; 0
    3916:	50 e0       	ldi	r21, 0x00	; 0
    3918:	8d 85       	ldd	r24, Y+13	; 0x0d
    391a:	9e 85       	ldd	r25, Y+14	; 0x0e
    391c:	af 85       	ldd	r26, Y+15	; 0x0f
    391e:	b8 89       	ldd	r27, Y+16	; 0x10
    3920:	bc 01       	movw	r22, r24
    3922:	cd 01       	movw	r24, r26
    3924:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__udivmodsi4>
    3928:	da 01       	movw	r26, r20
    392a:	c9 01       	movw	r24, r18
    392c:	8d 87       	std	Y+13, r24	; 0x0d
    392e:	9e 87       	std	Y+14, r25	; 0x0e
    3930:	af 87       	std	Y+15, r26	; 0x0f
    3932:	b8 8b       	std	Y+16, r27	; 0x10
    3934:	10 c0       	rjmp	.+32     	; 0x3956 <UART_TxNumber+0x156>
            }
            else if( (v_numOfDigitsToTransmit_u8 == C_DefaultDigitsToTransmit_U8) ||
    3936:	89 89       	ldd	r24, Y+17	; 0x11
    3938:	8f 3f       	cpi	r24, 0xFF	; 255
    393a:	a9 f0       	breq	.+42     	; 0x3966 <UART_TxNumber+0x166>
    393c:	89 89       	ldd	r24, Y+17	; 0x11
    393e:	8b 30       	cpi	r24, 0x0B	; 11
    3940:	90 f4       	brcc	.+36     	; 0x3966 <UART_TxNumber+0x166>
            else
            {
                /*In case user expects more digits to be transmitted than the actual digits in number,
                  then update the remaining digits with zero.
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
    3942:	89 81       	ldd	r24, Y+1	; 0x01
    3944:	88 2f       	mov	r24, r24
    3946:	90 e0       	ldi	r25, 0x00	; 0
    3948:	9e 01       	movw	r18, r28
    394a:	2e 5f       	subi	r18, 0xFE	; 254
    394c:	3f 4f       	sbci	r19, 0xFF	; 255
    394e:	82 0f       	add	r24, r18
    3950:	93 1f       	adc	r25, r19
    3952:	fc 01       	movw	r30, r24
    3954:	10 82       	st	Z, r1
        for(i=0;((i<v_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
            UART_TxChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToTransmit_u8;i++)
    3956:	89 81       	ldd	r24, Y+1	; 0x01
    3958:	8f 5f       	subi	r24, 0xFF	; 255
    395a:	89 83       	std	Y+1, r24	; 0x01
    395c:	99 81       	ldd	r25, Y+1	; 0x01
    395e:	89 89       	ldd	r24, Y+17	; 0x11
    3960:	98 17       	cp	r25, r24
    3962:	08 f4       	brcc	.+2      	; 0x3966 <UART_TxNumber+0x166>
    3964:	ac cf       	rjmp	.-168    	; 0x38be <UART_TxNumber+0xbe>
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
    3966:	2b c0       	rjmp	.+86     	; 0x39be <UART_TxNumber+0x1be>
        { 
            /* Finally get the ascii values of the digits and transmit*/
            UART_TxChar(util_Hex2Ascii(a[i-1]));
    3968:	89 81       	ldd	r24, Y+1	; 0x01
    396a:	88 2f       	mov	r24, r24
    396c:	90 e0       	ldi	r25, 0x00	; 0
    396e:	01 97       	sbiw	r24, 0x01	; 1
    3970:	9e 01       	movw	r18, r28
    3972:	2e 5f       	subi	r18, 0xFE	; 254
    3974:	3f 4f       	sbci	r19, 0xFF	; 255
    3976:	82 0f       	add	r24, r18
    3978:	93 1f       	adc	r25, r19
    397a:	fc 01       	movw	r30, r24
    397c:	80 81       	ld	r24, Z
    397e:	8a 30       	cpi	r24, 0x0A	; 10
    3980:	68 f0       	brcs	.+26     	; 0x399c <UART_TxNumber+0x19c>
    3982:	89 81       	ldd	r24, Y+1	; 0x01
    3984:	88 2f       	mov	r24, r24
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	01 97       	sbiw	r24, 0x01	; 1
    398a:	9e 01       	movw	r18, r28
    398c:	2e 5f       	subi	r18, 0xFE	; 254
    398e:	3f 4f       	sbci	r19, 0xFF	; 255
    3990:	82 0f       	add	r24, r18
    3992:	93 1f       	adc	r25, r19
    3994:	fc 01       	movw	r30, r24
    3996:	80 81       	ld	r24, Z
    3998:	89 5c       	subi	r24, 0xC9	; 201
    399a:	0c c0       	rjmp	.+24     	; 0x39b4 <UART_TxNumber+0x1b4>
    399c:	89 81       	ldd	r24, Y+1	; 0x01
    399e:	88 2f       	mov	r24, r24
    39a0:	90 e0       	ldi	r25, 0x00	; 0
    39a2:	01 97       	sbiw	r24, 0x01	; 1
    39a4:	9e 01       	movw	r18, r28
    39a6:	2e 5f       	subi	r18, 0xFE	; 254
    39a8:	3f 4f       	sbci	r19, 0xFF	; 255
    39aa:	82 0f       	add	r24, r18
    39ac:	93 1f       	adc	r25, r19
    39ae:	fc 01       	movw	r30, r24
    39b0:	80 81       	ld	r24, Z
    39b2:	80 5d       	subi	r24, 0xD0	; 208
    39b4:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
            i--;
    39b8:	89 81       	ldd	r24, Y+1	; 0x01
    39ba:	81 50       	subi	r24, 0x01	; 1
    39bc:	89 83       	std	Y+1, r24	; 0x01
                Ex: v_number_u32 is 123 and user wants five digits then 00123 has to be transmitted */
                a[i]=0;
            }
        }

        while(i)
    39be:	89 81       	ldd	r24, Y+1	; 0x01
    39c0:	88 23       	and	r24, r24
    39c2:	91 f6       	brne	.-92     	; 0x3968 <UART_TxNumber+0x168>
            i--;
        }
    }


}
    39c4:	69 96       	adiw	r28, 0x19	; 25
    39c6:	0f b6       	in	r0, 0x3f	; 63
    39c8:	f8 94       	cli
    39ca:	de bf       	out	0x3e, r29	; 62
    39cc:	0f be       	out	0x3f, r0	; 63
    39ce:	cd bf       	out	0x3d, r28	; 61
    39d0:	df 91       	pop	r29
    39d2:	cf 91       	pop	r28
    39d4:	1f 91       	pop	r17
    39d6:	0f 91       	pop	r16
    39d8:	ff 90       	pop	r15
    39da:	08 95       	ret

000039dc <UART_TxFloatNumber>:
         Float will be disabled by default as it takes huge controller resources
	     It can be enabled by changing value of Enable_UART_TxFloatNumber to 1 in uart.h	 
 ***************************************************************************************************/
#if (Enable_UART_TxFloatNumber==1)
void UART_TxFloatNumber(float v_floatNumber_f32)
{
    39dc:	cf 93       	push	r28
    39de:	df 93       	push	r29
    39e0:	cd b7       	in	r28, 0x3d	; 61
    39e2:	de b7       	in	r29, 0x3e	; 62
    39e4:	28 97       	sbiw	r28, 0x08	; 8
    39e6:	0f b6       	in	r0, 0x3f	; 63
    39e8:	f8 94       	cli
    39ea:	de bf       	out	0x3e, r29	; 62
    39ec:	0f be       	out	0x3f, r0	; 63
    39ee:	cd bf       	out	0x3d, r28	; 61
    39f0:	6d 83       	std	Y+5, r22	; 0x05
    39f2:	7e 83       	std	Y+6, r23	; 0x06
    39f4:	8f 83       	std	Y+7, r24	; 0x07
    39f6:	98 87       	std	Y+8, r25	; 0x08
      1.Type cast the number to int to get the integer part.
	  2.transmit the extracted integer part followed by a decimal point(.).
	  3.Later the integer part is made zero by subtracting with the extracted integer value.
	  4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

	v_tempNumber_u32 = (uint32_t) v_floatNumber_f32;
    39f8:	6d 81       	ldd	r22, Y+5	; 0x05
    39fa:	7e 81       	ldd	r23, Y+6	; 0x06
    39fc:	8f 81       	ldd	r24, Y+7	; 0x07
    39fe:	98 85       	ldd	r25, Y+8	; 0x08
    3a00:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
    3a04:	dc 01       	movw	r26, r24
    3a06:	cb 01       	movw	r24, r22
    3a08:	89 83       	std	Y+1, r24	; 0x01
    3a0a:	9a 83       	std	Y+2, r25	; 0x02
    3a0c:	ab 83       	std	Y+3, r26	; 0x03
    3a0e:	bc 83       	std	Y+4, r27	; 0x04
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
    3a10:	89 81       	ldd	r24, Y+1	; 0x01
    3a12:	9a 81       	ldd	r25, Y+2	; 0x02
    3a14:	ab 81       	ldd	r26, Y+3	; 0x03
    3a16:	bc 81       	ldd	r27, Y+4	; 0x04
    3a18:	2f ef       	ldi	r18, 0xFF	; 255
    3a1a:	ac 01       	movw	r20, r24
    3a1c:	bd 01       	movw	r22, r26
    3a1e:	8a e0       	ldi	r24, 0x0A	; 10
    3a20:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>

	UART_TxChar('.');
    3a24:	8e e2       	ldi	r24, 0x2E	; 46
    3a26:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>

	v_floatNumber_f32 = v_floatNumber_f32 - v_tempNumber_u32;
    3a2a:	69 81       	ldd	r22, Y+1	; 0x01
    3a2c:	7a 81       	ldd	r23, Y+2	; 0x02
    3a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a30:	9c 81       	ldd	r25, Y+4	; 0x04
    3a32:	0e 94 2d 20 	call	0x405a	; 0x405a <__floatunsisf>
    3a36:	dc 01       	movw	r26, r24
    3a38:	cb 01       	movw	r24, r22
    3a3a:	9c 01       	movw	r18, r24
    3a3c:	ad 01       	movw	r20, r26
    3a3e:	6d 81       	ldd	r22, Y+5	; 0x05
    3a40:	7e 81       	ldd	r23, Y+6	; 0x06
    3a42:	8f 81       	ldd	r24, Y+7	; 0x07
    3a44:	98 85       	ldd	r25, Y+8	; 0x08
    3a46:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <__subsf3>
    3a4a:	dc 01       	movw	r26, r24
    3a4c:	cb 01       	movw	r24, r22
    3a4e:	8d 83       	std	Y+5, r24	; 0x05
    3a50:	9e 83       	std	Y+6, r25	; 0x06
    3a52:	af 83       	std	Y+7, r26	; 0x07
    3a54:	b8 87       	std	Y+8, r27	; 0x08
	v_tempNumber_u32 = v_floatNumber_f32 * 1000000;
    3a56:	20 e0       	ldi	r18, 0x00	; 0
    3a58:	34 e2       	ldi	r19, 0x24	; 36
    3a5a:	44 e7       	ldi	r20, 0x74	; 116
    3a5c:	59 e4       	ldi	r21, 0x49	; 73
    3a5e:	6d 81       	ldd	r22, Y+5	; 0x05
    3a60:	7e 81       	ldd	r23, Y+6	; 0x06
    3a62:	8f 81       	ldd	r24, Y+7	; 0x07
    3a64:	98 85       	ldd	r25, Y+8	; 0x08
    3a66:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <__mulsf3>
    3a6a:	dc 01       	movw	r26, r24
    3a6c:	cb 01       	movw	r24, r22
    3a6e:	bc 01       	movw	r22, r24
    3a70:	cd 01       	movw	r24, r26
    3a72:	0e 94 01 20 	call	0x4002	; 0x4002 <__fixunssfsi>
    3a76:	dc 01       	movw	r26, r24
    3a78:	cb 01       	movw	r24, r22
    3a7a:	89 83       	std	Y+1, r24	; 0x01
    3a7c:	9a 83       	std	Y+2, r25	; 0x02
    3a7e:	ab 83       	std	Y+3, r26	; 0x03
    3a80:	bc 83       	std	Y+4, r27	; 0x04
	UART_TxNumber(C_DECIMAL_U8,v_tempNumber_u32,C_DefaultDigitsToTransmit_U8);
    3a82:	89 81       	ldd	r24, Y+1	; 0x01
    3a84:	9a 81       	ldd	r25, Y+2	; 0x02
    3a86:	ab 81       	ldd	r26, Y+3	; 0x03
    3a88:	bc 81       	ldd	r27, Y+4	; 0x04
    3a8a:	2f ef       	ldi	r18, 0xFF	; 255
    3a8c:	ac 01       	movw	r20, r24
    3a8e:	bd 01       	movw	r22, r26
    3a90:	8a e0       	ldi	r24, 0x0A	; 10
    3a92:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
}
    3a96:	28 96       	adiw	r28, 0x08	; 8
    3a98:	0f b6       	in	r0, 0x3f	; 63
    3a9a:	f8 94       	cli
    3a9c:	de bf       	out	0x3e, r29	; 62
    3a9e:	0f be       	out	0x3f, r0	; 63
    3aa0:	cd bf       	out	0x3d, r28	; 61
    3aa2:	df 91       	pop	r29
    3aa4:	cf 91       	pop	r28
    3aa6:	08 95       	ret

00003aa8 <UART_Printf>:
        uint8_t v_Num_u8;
		UART_Printf("num1:%u",(uint16_t)v_Num_u8); 		 
***************************************************************************************************/
#if ( Enable_UART_Printf   == 1 ) 
void UART_Printf(const char *argList, ...)
{
    3aa8:	cf 93       	push	r28
    3aaa:	df 93       	push	r29
    3aac:	cd b7       	in	r28, 0x3d	; 61
    3aae:	de b7       	in	r29, 0x3e	; 62
    3ab0:	68 97       	sbiw	r28, 0x18	; 24
    3ab2:	0f b6       	in	r0, 0x3f	; 63
    3ab4:	f8 94       	cli
    3ab6:	de bf       	out	0x3e, r29	; 62
    3ab8:	0f be       	out	0x3f, r0	; 63
    3aba:	cd bf       	out	0x3d, r28	; 61
#if (Enable_UART_TxFloatNumber==1)
	double v_floatNum_f32;
#endif	


	va_start(argp, argList);
    3abc:	ce 01       	movw	r24, r28
    3abe:	4f 96       	adiw	r24, 0x1f	; 31
    3ac0:	98 8f       	std	Y+24, r25	; 0x18
    3ac2:	8f 8b       	std	Y+23, r24	; 0x17

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    3ac4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3ac6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3ac8:	9a 83       	std	Y+2, r25	; 0x02
    3aca:	89 83       	std	Y+1, r24	; 0x01
    3acc:	91 c1       	rjmp	.+802    	; 0x3df0 <UART_Printf+0x348>
	{

		ch= *ptr;
    3ace:	89 81       	ldd	r24, Y+1	; 0x01
    3ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad2:	fc 01       	movw	r30, r24
    3ad4:	80 81       	ld	r24, Z
    3ad6:	89 87       	std	Y+9, r24	; 0x09
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
    3ad8:	89 85       	ldd	r24, Y+9	; 0x09
    3ada:	85 32       	cpi	r24, 0x25	; 37
    3adc:	09 f0       	breq	.+2      	; 0x3ae0 <UART_Printf+0x38>
    3ade:	80 c1       	rjmp	.+768    	; 0x3de0 <UART_Printf+0x338>
		{
		    ptr++;
    3ae0:	89 81       	ldd	r24, Y+1	; 0x01
    3ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae4:	01 96       	adiw	r24, 0x01	; 1
    3ae6:	9a 83       	std	Y+2, r25	; 0x02
    3ae8:	89 83       	std	Y+1, r24	; 0x01
		    ch = *ptr;
    3aea:	89 81       	ldd	r24, Y+1	; 0x01
    3aec:	9a 81       	ldd	r25, Y+2	; 0x02
    3aee:	fc 01       	movw	r30, r24
    3af0:	80 81       	ld	r24, Z
    3af2:	89 87       	std	Y+9, r24	; 0x09
		   if((ch>=0x30) && (ch<=0x39))
    3af4:	89 85       	ldd	r24, Y+9	; 0x09
    3af6:	80 33       	cpi	r24, 0x30	; 48
    3af8:	00 f1       	brcs	.+64     	; 0x3b3a <UART_Printf+0x92>
    3afa:	89 85       	ldd	r24, Y+9	; 0x09
    3afc:	8a 33       	cpi	r24, 0x3A	; 58
    3afe:	e8 f4       	brcc	.+58     	; 0x3b3a <UART_Printf+0x92>
			{
			   v_numOfDigitsToTransmit_u8 = 0;
    3b00:	1a 86       	std	Y+10, r1	; 0x0a
			   while((ch>=0x30) && (ch<=0x39))
    3b02:	14 c0       	rjmp	.+40     	; 0x3b2c <UART_Printf+0x84>
			    {
				   v_numOfDigitsToTransmit_u8 = (v_numOfDigitsToTransmit_u8 * 10) + (ch-0x30);
    3b04:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b06:	88 0f       	add	r24, r24
    3b08:	98 2f       	mov	r25, r24
    3b0a:	99 0f       	add	r25, r25
    3b0c:	99 0f       	add	r25, r25
    3b0e:	98 0f       	add	r25, r24
    3b10:	89 85       	ldd	r24, Y+9	; 0x09
    3b12:	89 0f       	add	r24, r25
    3b14:	80 53       	subi	r24, 0x30	; 48
    3b16:	8a 87       	std	Y+10, r24	; 0x0a
				   ptr++;
    3b18:	89 81       	ldd	r24, Y+1	; 0x01
    3b1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b1c:	01 96       	adiw	r24, 0x01	; 1
    3b1e:	9a 83       	std	Y+2, r25	; 0x02
    3b20:	89 83       	std	Y+1, r24	; 0x01
				   ch = *ptr;
    3b22:	89 81       	ldd	r24, Y+1	; 0x01
    3b24:	9a 81       	ldd	r25, Y+2	; 0x02
    3b26:	fc 01       	movw	r30, r24
    3b28:	80 81       	ld	r24, Z
    3b2a:	89 87       	std	Y+9, r24	; 0x09
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
			{
			   v_numOfDigitsToTransmit_u8 = 0;
			   while((ch>=0x30) && (ch<=0x39))
    3b2c:	89 85       	ldd	r24, Y+9	; 0x09
    3b2e:	80 33       	cpi	r24, 0x30	; 48
    3b30:	18 f0       	brcs	.+6      	; 0x3b38 <UART_Printf+0x90>
    3b32:	89 85       	ldd	r24, Y+9	; 0x09
    3b34:	8a 33       	cpi	r24, 0x3A	; 58
    3b36:	30 f3       	brcs	.-52     	; 0x3b04 <UART_Printf+0x5c>
		ch= *ptr;
		if(ch == '%')         /*Check for '%' as there will be format specifier after it */
		{
		    ptr++;
		    ch = *ptr;
		   if((ch>=0x30) && (ch<=0x39))
    3b38:	02 c0       	rjmp	.+4      	; 0x3b3e <UART_Printf+0x96>
				   ch = *ptr;
				}
			}
			else
			{
			  v_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
    3b3a:	8f ef       	ldi	r24, 0xFF	; 255
    3b3c:	8a 87       	std	Y+10, r24	; 0x0a
			}				


			switch(ch)       /* Decode the type of the argument */
    3b3e:	89 85       	ldd	r24, Y+9	; 0x09
    3b40:	88 2f       	mov	r24, r24
    3b42:	90 e0       	ldi	r25, 0x00	; 0
    3b44:	aa 27       	eor	r26, r26
    3b46:	97 fd       	sbrc	r25, 7
    3b48:	a0 95       	com	r26
    3b4a:	ba 2f       	mov	r27, r26
    3b4c:	45 e2       	ldi	r20, 0x25	; 37
    3b4e:	50 e0       	ldi	r21, 0x00	; 0
    3b50:	23 e5       	ldi	r18, 0x53	; 83
    3b52:	30 e0       	ldi	r19, 0x00	; 0
    3b54:	84 1b       	sub	r24, r20
    3b56:	95 0b       	sbc	r25, r21
    3b58:	28 17       	cp	r18, r24
    3b5a:	39 07       	cpc	r19, r25
    3b5c:	08 f4       	brcc	.+2      	; 0x3b60 <UART_Printf+0xb8>
    3b5e:	43 c1       	rjmp	.+646    	; 0x3de6 <UART_Printf+0x33e>
    3b60:	8b 5c       	subi	r24, 0xCB	; 203
    3b62:	9e 4f       	sbci	r25, 0xFE	; 254
    3b64:	fc 01       	movw	r30, r24
    3b66:	0c 94 2a 1f 	jmp	0x3e54	; 0x3e54 <__tablejump2__>
			{
			case 'C':
			case 'c':     /* Argument type is of char, hence read char data from the argp */
				ch = va_arg(argp, int);
    3b6a:	8f 89       	ldd	r24, Y+23	; 0x17
    3b6c:	98 8d       	ldd	r25, Y+24	; 0x18
    3b6e:	9c 01       	movw	r18, r24
    3b70:	2e 5f       	subi	r18, 0xFE	; 254
    3b72:	3f 4f       	sbci	r19, 0xFF	; 255
    3b74:	38 8f       	std	Y+24, r19	; 0x18
    3b76:	2f 8b       	std	Y+23, r18	; 0x17
    3b78:	fc 01       	movw	r30, r24
    3b7a:	80 81       	ld	r24, Z
    3b7c:	91 81       	ldd	r25, Z+1	; 0x01
    3b7e:	89 87       	std	Y+9, r24	; 0x09
				UART_TxChar(ch);
    3b80:	89 85       	ldd	r24, Y+9	; 0x09
    3b82:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
				break;
    3b86:	2b c1       	rjmp	.+598    	; 0x3dde <UART_Printf+0x336>

			case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
				v_num_s16 = va_arg(argp, sint16_t);
    3b88:	8f 89       	ldd	r24, Y+23	; 0x17
    3b8a:	98 8d       	ldd	r25, Y+24	; 0x18
    3b8c:	9c 01       	movw	r18, r24
    3b8e:	2e 5f       	subi	r18, 0xFE	; 254
    3b90:	3f 4f       	sbci	r19, 0xFF	; 255
    3b92:	38 8f       	std	Y+24, r19	; 0x18
    3b94:	2f 8b       	std	Y+23, r18	; 0x17
    3b96:	fc 01       	movw	r30, r24
    3b98:	80 81       	ld	r24, Z
    3b9a:	91 81       	ldd	r25, Z+1	; 0x01
    3b9c:	9c 83       	std	Y+4, r25	; 0x04
    3b9e:	8b 83       	std	Y+3, r24	; 0x03
				if(v_num_s16<0)
    3ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ba4:	99 23       	and	r25, r25
    3ba6:	54 f4       	brge	.+20     	; 0x3bbc <UART_Printf+0x114>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
				   v_num_s16 = -v_num_s16;
    3ba8:	8b 81       	ldd	r24, Y+3	; 0x03
    3baa:	9c 81       	ldd	r25, Y+4	; 0x04
    3bac:	91 95       	neg	r25
    3bae:	81 95       	neg	r24
    3bb0:	91 09       	sbc	r25, r1
    3bb2:	9c 83       	std	Y+4, r25	; 0x04
    3bb4:	8b 83       	std	Y+3, r24	; 0x03
				   UART_TxChar('-');
    3bb6:	8d e2       	ldi	r24, 0x2D	; 45
    3bb8:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToTransmit_u8);
    3bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    3bbe:	9c 81       	ldd	r25, Y+4	; 0x04
    3bc0:	aa 27       	eor	r26, r26
    3bc2:	97 fd       	sbrc	r25, 7
    3bc4:	a0 95       	com	r26
    3bc6:	ba 2f       	mov	r27, r26
    3bc8:	2a 85       	ldd	r18, Y+10	; 0x0a
    3bca:	ac 01       	movw	r20, r24
    3bcc:	bd 01       	movw	r22, r26
    3bce:	8a e0       	ldi	r24, 0x0A	; 10
    3bd0:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;
    3bd4:	04 c1       	rjmp	.+520    	; 0x3dde <UART_Printf+0x336>
				
			case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
				v_num_s32 = va_arg(argp, sint32_t);				
    3bd6:	8f 89       	ldd	r24, Y+23	; 0x17
    3bd8:	98 8d       	ldd	r25, Y+24	; 0x18
    3bda:	9c 01       	movw	r18, r24
    3bdc:	2c 5f       	subi	r18, 0xFC	; 252
    3bde:	3f 4f       	sbci	r19, 0xFF	; 255
    3be0:	38 8f       	std	Y+24, r19	; 0x18
    3be2:	2f 8b       	std	Y+23, r18	; 0x17
    3be4:	fc 01       	movw	r30, r24
    3be6:	80 81       	ld	r24, Z
    3be8:	91 81       	ldd	r25, Z+1	; 0x01
    3bea:	a2 81       	ldd	r26, Z+2	; 0x02
    3bec:	b3 81       	ldd	r27, Z+3	; 0x03
    3bee:	8d 83       	std	Y+5, r24	; 0x05
    3bf0:	9e 83       	std	Y+6, r25	; 0x06
    3bf2:	af 83       	std	Y+7, r26	; 0x07
    3bf4:	b8 87       	std	Y+8, r27	; 0x08
				if(v_num_s32<0)
    3bf6:	8d 81       	ldd	r24, Y+5	; 0x05
    3bf8:	9e 81       	ldd	r25, Y+6	; 0x06
    3bfa:	af 81       	ldd	r26, Y+7	; 0x07
    3bfc:	b8 85       	ldd	r27, Y+8	; 0x08
    3bfe:	bb 23       	and	r27, r27
    3c00:	94 f4       	brge	.+36     	; 0x3c26 <UART_Printf+0x17e>
				 { /* If the number is -ve then display the 2's complement along with '-' sign */
				   v_num_s32 = -v_num_s32;
    3c02:	8d 81       	ldd	r24, Y+5	; 0x05
    3c04:	9e 81       	ldd	r25, Y+6	; 0x06
    3c06:	af 81       	ldd	r26, Y+7	; 0x07
    3c08:	b8 85       	ldd	r27, Y+8	; 0x08
    3c0a:	b0 95       	com	r27
    3c0c:	a0 95       	com	r26
    3c0e:	90 95       	com	r25
    3c10:	81 95       	neg	r24
    3c12:	9f 4f       	sbci	r25, 0xFF	; 255
    3c14:	af 4f       	sbci	r26, 0xFF	; 255
    3c16:	bf 4f       	sbci	r27, 0xFF	; 255
    3c18:	8d 83       	std	Y+5, r24	; 0x05
    3c1a:	9e 83       	std	Y+6, r25	; 0x06
    3c1c:	af 83       	std	Y+7, r26	; 0x07
    3c1e:	b8 87       	std	Y+8, r27	; 0x08
				   UART_TxChar('-');
    3c20:	8d e2       	ldi	r24, 0x2D	; 45
    3c22:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
				 }
				UART_TxNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToTransmit_u8);			
    3c26:	8d 81       	ldd	r24, Y+5	; 0x05
    3c28:	9e 81       	ldd	r25, Y+6	; 0x06
    3c2a:	af 81       	ldd	r26, Y+7	; 0x07
    3c2c:	b8 85       	ldd	r27, Y+8	; 0x08
    3c2e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3c30:	ac 01       	movw	r20, r24
    3c32:	bd 01       	movw	r22, r26
    3c34:	8a e0       	ldi	r24, 0x0A	; 10
    3c36:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;	
    3c3a:	d1 c0       	rjmp	.+418    	; 0x3dde <UART_Printf+0x336>

			case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
				v_num_u16 = va_arg(argp, uint16_t);			
    3c3c:	8f 89       	ldd	r24, Y+23	; 0x17
    3c3e:	98 8d       	ldd	r25, Y+24	; 0x18
    3c40:	9c 01       	movw	r18, r24
    3c42:	2e 5f       	subi	r18, 0xFE	; 254
    3c44:	3f 4f       	sbci	r19, 0xFF	; 255
    3c46:	38 8f       	std	Y+24, r19	; 0x18
    3c48:	2f 8b       	std	Y+23, r18	; 0x17
    3c4a:	fc 01       	movw	r30, r24
    3c4c:	80 81       	ld	r24, Z
    3c4e:	91 81       	ldd	r25, Z+1	; 0x01
    3c50:	9c 87       	std	Y+12, r25	; 0x0c
    3c52:	8b 87       	std	Y+11, r24	; 0x0b
				UART_TxNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToTransmit_u8);				
    3c54:	8b 85       	ldd	r24, Y+11	; 0x0b
    3c56:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c58:	cc 01       	movw	r24, r24
    3c5a:	a0 e0       	ldi	r26, 0x00	; 0
    3c5c:	b0 e0       	ldi	r27, 0x00	; 0
    3c5e:	2a 85       	ldd	r18, Y+10	; 0x0a
    3c60:	ac 01       	movw	r20, r24
    3c62:	bd 01       	movw	r22, r26
    3c64:	8a e0       	ldi	r24, 0x0A	; 10
    3c66:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;
    3c6a:	b9 c0       	rjmp	.+370    	; 0x3dde <UART_Printf+0x336>
			
			case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
				v_num_u32 = va_arg(argp, uint32_t);			
    3c6c:	8f 89       	ldd	r24, Y+23	; 0x17
    3c6e:	98 8d       	ldd	r25, Y+24	; 0x18
    3c70:	9c 01       	movw	r18, r24
    3c72:	2c 5f       	subi	r18, 0xFC	; 252
    3c74:	3f 4f       	sbci	r19, 0xFF	; 255
    3c76:	38 8f       	std	Y+24, r19	; 0x18
    3c78:	2f 8b       	std	Y+23, r18	; 0x17
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	80 81       	ld	r24, Z
    3c7e:	91 81       	ldd	r25, Z+1	; 0x01
    3c80:	a2 81       	ldd	r26, Z+2	; 0x02
    3c82:	b3 81       	ldd	r27, Z+3	; 0x03
    3c84:	8d 87       	std	Y+13, r24	; 0x0d
    3c86:	9e 87       	std	Y+14, r25	; 0x0e
    3c88:	af 87       	std	Y+15, r26	; 0x0f
    3c8a:	b8 8b       	std	Y+16, r27	; 0x10
				UART_TxNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    3c8c:	8d 85       	ldd	r24, Y+13	; 0x0d
    3c8e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3c90:	af 85       	ldd	r26, Y+15	; 0x0f
    3c92:	b8 89       	ldd	r27, Y+16	; 0x10
    3c94:	2a 85       	ldd	r18, Y+10	; 0x0a
    3c96:	ac 01       	movw	r20, r24
    3c98:	bd 01       	movw	r22, r26
    3c9a:	8a e0       	ldi	r24, 0x0A	; 10
    3c9c:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;			
    3ca0:	9e c0       	rjmp	.+316    	; 0x3dde <UART_Printf+0x336>

			case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u16 = va_arg(argp, uint16_t);				
    3ca2:	8f 89       	ldd	r24, Y+23	; 0x17
    3ca4:	98 8d       	ldd	r25, Y+24	; 0x18
    3ca6:	9c 01       	movw	r18, r24
    3ca8:	2e 5f       	subi	r18, 0xFE	; 254
    3caa:	3f 4f       	sbci	r19, 0xFF	; 255
    3cac:	38 8f       	std	Y+24, r19	; 0x18
    3cae:	2f 8b       	std	Y+23, r18	; 0x17
    3cb0:	fc 01       	movw	r30, r24
    3cb2:	80 81       	ld	r24, Z
    3cb4:	91 81       	ldd	r25, Z+1	; 0x01
    3cb6:	9c 87       	std	Y+12, r25	; 0x0c
    3cb8:	8b 87       	std	Y+11, r24	; 0x0b
				UART_TxNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
    3cba:	8b 85       	ldd	r24, Y+11	; 0x0b
    3cbc:	9c 85       	ldd	r25, Y+12	; 0x0c
    3cbe:	cc 01       	movw	r24, r24
    3cc0:	a0 e0       	ldi	r26, 0x00	; 0
    3cc2:	b0 e0       	ldi	r27, 0x00	; 0
    3cc4:	2a 85       	ldd	r18, Y+10	; 0x0a
    3cc6:	ac 01       	movw	r20, r24
    3cc8:	bd 01       	movw	r22, r26
    3cca:	80 e1       	ldi	r24, 0x10	; 16
    3ccc:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;
    3cd0:	86 c0       	rjmp	.+268    	; 0x3dde <UART_Printf+0x336>

			case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
				v_num_u32 = va_arg(argp, uint32_t);						
    3cd2:	8f 89       	ldd	r24, Y+23	; 0x17
    3cd4:	98 8d       	ldd	r25, Y+24	; 0x18
    3cd6:	9c 01       	movw	r18, r24
    3cd8:	2c 5f       	subi	r18, 0xFC	; 252
    3cda:	3f 4f       	sbci	r19, 0xFF	; 255
    3cdc:	38 8f       	std	Y+24, r19	; 0x18
    3cde:	2f 8b       	std	Y+23, r18	; 0x17
    3ce0:	fc 01       	movw	r30, r24
    3ce2:	80 81       	ld	r24, Z
    3ce4:	91 81       	ldd	r25, Z+1	; 0x01
    3ce6:	a2 81       	ldd	r26, Z+2	; 0x02
    3ce8:	b3 81       	ldd	r27, Z+3	; 0x03
    3cea:	8d 87       	std	Y+13, r24	; 0x0d
    3cec:	9e 87       	std	Y+14, r25	; 0x0e
    3cee:	af 87       	std	Y+15, r26	; 0x0f
    3cf0:	b8 8b       	std	Y+16, r27	; 0x10
				UART_TxNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    3cf2:	8d 85       	ldd	r24, Y+13	; 0x0d
    3cf4:	9e 85       	ldd	r25, Y+14	; 0x0e
    3cf6:	af 85       	ldd	r26, Y+15	; 0x0f
    3cf8:	b8 89       	ldd	r27, Y+16	; 0x10
    3cfa:	2a 85       	ldd	r18, Y+10	; 0x0a
    3cfc:	ac 01       	movw	r20, r24
    3cfe:	bd 01       	movw	r22, r26
    3d00:	80 e1       	ldi	r24, 0x10	; 16
    3d02:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;
    3d06:	6b c0       	rjmp	.+214    	; 0x3dde <UART_Printf+0x336>

			
			case 'b':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u16 = va_arg(argp, uint16_t);		
    3d08:	8f 89       	ldd	r24, Y+23	; 0x17
    3d0a:	98 8d       	ldd	r25, Y+24	; 0x18
    3d0c:	9c 01       	movw	r18, r24
    3d0e:	2e 5f       	subi	r18, 0xFE	; 254
    3d10:	3f 4f       	sbci	r19, 0xFF	; 255
    3d12:	38 8f       	std	Y+24, r19	; 0x18
    3d14:	2f 8b       	std	Y+23, r18	; 0x17
    3d16:	fc 01       	movw	r30, r24
    3d18:	80 81       	ld	r24, Z
    3d1a:	91 81       	ldd	r25, Z+1	; 0x01
    3d1c:	9c 87       	std	Y+12, r25	; 0x0c
    3d1e:	8b 87       	std	Y+11, r24	; 0x0b
				
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    3d20:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d22:	8f 3f       	cpi	r24, 0xFF	; 255
    3d24:	11 f4       	brne	.+4      	; 0x3d2a <UART_Printf+0x282>
				   v_numOfDigitsToTransmit_u8 = 16;
    3d26:	80 e1       	ldi	r24, 0x10	; 16
    3d28:	8a 87       	std	Y+10, r24	; 0x0a
               
				UART_TxNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToTransmit_u8);			
    3d2a:	8b 85       	ldd	r24, Y+11	; 0x0b
    3d2c:	9c 85       	ldd	r25, Y+12	; 0x0c
    3d2e:	cc 01       	movw	r24, r24
    3d30:	a0 e0       	ldi	r26, 0x00	; 0
    3d32:	b0 e0       	ldi	r27, 0x00	; 0
    3d34:	2a 85       	ldd	r18, Y+10	; 0x0a
    3d36:	ac 01       	movw	r20, r24
    3d38:	bd 01       	movw	r22, r26
    3d3a:	82 e0       	ldi	r24, 0x02	; 2
    3d3c:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;
    3d40:	4e c0       	rjmp	.+156    	; 0x3dde <UART_Printf+0x336>

			case 'B':  /* Argument type is of binary,Read int and convert to binary */
				v_num_u32 = va_arg(argp, uint32_t);			
    3d42:	8f 89       	ldd	r24, Y+23	; 0x17
    3d44:	98 8d       	ldd	r25, Y+24	; 0x18
    3d46:	9c 01       	movw	r18, r24
    3d48:	2c 5f       	subi	r18, 0xFC	; 252
    3d4a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d4c:	38 8f       	std	Y+24, r19	; 0x18
    3d4e:	2f 8b       	std	Y+23, r18	; 0x17
    3d50:	fc 01       	movw	r30, r24
    3d52:	80 81       	ld	r24, Z
    3d54:	91 81       	ldd	r25, Z+1	; 0x01
    3d56:	a2 81       	ldd	r26, Z+2	; 0x02
    3d58:	b3 81       	ldd	r27, Z+3	; 0x03
    3d5a:	8d 87       	std	Y+13, r24	; 0x0d
    3d5c:	9e 87       	std	Y+14, r25	; 0x0e
    3d5e:	af 87       	std	Y+15, r26	; 0x0f
    3d60:	b8 8b       	std	Y+16, r27	; 0x10
                
				if(v_numOfDigitsToTransmit_u8 == C_MaxDigitsToTransmitUsingPrintf_U8)
    3d62:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d64:	8f 3f       	cpi	r24, 0xFF	; 255
    3d66:	11 f4       	brne	.+4      	; 0x3d6c <UART_Printf+0x2c4>
				   v_numOfDigitsToTransmit_u8 = 32;		
    3d68:	80 e2       	ldi	r24, 0x20	; 32
    3d6a:	8a 87       	std	Y+10, r24	; 0x0a
               
				UART_TxNumber(C_BINARY_U8,v_num_u32,v_numOfDigitsToTransmit_u8);				
    3d6c:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d6e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3d70:	af 85       	ldd	r26, Y+15	; 0x0f
    3d72:	b8 89       	ldd	r27, Y+16	; 0x10
    3d74:	2a 85       	ldd	r18, Y+10	; 0x0a
    3d76:	ac 01       	movw	r20, r24
    3d78:	bd 01       	movw	r22, r26
    3d7a:	82 e0       	ldi	r24, 0x02	; 2
    3d7c:	0e 94 00 1c 	call	0x3800	; 0x3800 <UART_TxNumber>
				break;
    3d80:	2e c0       	rjmp	.+92     	; 0x3dde <UART_Printf+0x336>


			case 'F':
			case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_UART_TxFloatNumber==1)				
				v_floatNum_f32 = va_arg(argp, double);				
    3d82:	8f 89       	ldd	r24, Y+23	; 0x17
    3d84:	98 8d       	ldd	r25, Y+24	; 0x18
    3d86:	9c 01       	movw	r18, r24
    3d88:	2c 5f       	subi	r18, 0xFC	; 252
    3d8a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d8c:	38 8f       	std	Y+24, r19	; 0x18
    3d8e:	2f 8b       	std	Y+23, r18	; 0x17
    3d90:	fc 01       	movw	r30, r24
    3d92:	80 81       	ld	r24, Z
    3d94:	91 81       	ldd	r25, Z+1	; 0x01
    3d96:	a2 81       	ldd	r26, Z+2	; 0x02
    3d98:	b3 81       	ldd	r27, Z+3	; 0x03
    3d9a:	89 8b       	std	Y+17, r24	; 0x11
    3d9c:	9a 8b       	std	Y+18, r25	; 0x12
    3d9e:	ab 8b       	std	Y+19, r26	; 0x13
    3da0:	bc 8b       	std	Y+20, r27	; 0x14
				UART_TxFloatNumber(v_floatNum_f32);
    3da2:	89 89       	ldd	r24, Y+17	; 0x11
    3da4:	9a 89       	ldd	r25, Y+18	; 0x12
    3da6:	ab 89       	ldd	r26, Y+19	; 0x13
    3da8:	bc 89       	ldd	r27, Y+20	; 0x14
    3daa:	bc 01       	movw	r22, r24
    3dac:	cd 01       	movw	r24, r26
    3dae:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <UART_TxFloatNumber>
#endif            
				break;                
    3db2:	15 c0       	rjmp	.+42     	; 0x3dde <UART_Printf+0x336>


			case 'S':
			case 's': /* Argument type is of string, hence get the pointer to sting passed */
				str = va_arg(argp, char *);
    3db4:	8f 89       	ldd	r24, Y+23	; 0x17
    3db6:	98 8d       	ldd	r25, Y+24	; 0x18
    3db8:	9c 01       	movw	r18, r24
    3dba:	2e 5f       	subi	r18, 0xFE	; 254
    3dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    3dbe:	38 8f       	std	Y+24, r19	; 0x18
    3dc0:	2f 8b       	std	Y+23, r18	; 0x17
    3dc2:	fc 01       	movw	r30, r24
    3dc4:	80 81       	ld	r24, Z
    3dc6:	91 81       	ldd	r25, Z+1	; 0x01
    3dc8:	9e 8b       	std	Y+22, r25	; 0x16
    3dca:	8d 8b       	std	Y+21, r24	; 0x15
				UART_TxString(str);			
    3dcc:	8d 89       	ldd	r24, Y+21	; 0x15
    3dce:	9e 89       	ldd	r25, Y+22	; 0x16
    3dd0:	0e 94 96 1b 	call	0x372c	; 0x372c <UART_TxString>
				break;
    3dd4:	04 c0       	rjmp	.+8      	; 0x3dde <UART_Printf+0x336>

			case '%':
				UART_TxChar('%');
    3dd6:	85 e2       	ldi	r24, 0x25	; 37
    3dd8:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>
				break;
    3ddc:	00 00       	nop
    3dde:	03 c0       	rjmp	.+6      	; 0x3de6 <UART_Printf+0x33e>
			}
		}
		else
		{
			/* As '%' is not detected transmit the char passed */
			UART_TxChar(ch);
    3de0:	89 85       	ldd	r24, Y+9	; 0x09
    3de2:	0e 94 7c 1b 	call	0x36f8	; 0x36f8 <UART_TxChar>


	va_start(argp, argList);

	/* Loop through the list to extract all the input arguments */
	for(ptr = argList; *ptr != '\0'; ptr++)
    3de6:	89 81       	ldd	r24, Y+1	; 0x01
    3de8:	9a 81       	ldd	r25, Y+2	; 0x02
    3dea:	01 96       	adiw	r24, 0x01	; 1
    3dec:	9a 83       	std	Y+2, r25	; 0x02
    3dee:	89 83       	std	Y+1, r24	; 0x01
    3df0:	89 81       	ldd	r24, Y+1	; 0x01
    3df2:	9a 81       	ldd	r25, Y+2	; 0x02
    3df4:	fc 01       	movw	r30, r24
    3df6:	80 81       	ld	r24, Z
    3df8:	88 23       	and	r24, r24
    3dfa:	09 f0       	breq	.+2      	; 0x3dfe <UART_Printf+0x356>
    3dfc:	68 ce       	rjmp	.-816    	; 0x3ace <UART_Printf+0x26>
			UART_TxChar(ch);
		}
	}

	va_end(argp);
}
    3dfe:	68 96       	adiw	r28, 0x18	; 24
    3e00:	0f b6       	in	r0, 0x3f	; 63
    3e02:	f8 94       	cli
    3e04:	de bf       	out	0x3e, r29	; 62
    3e06:	0f be       	out	0x3f, r0	; 63
    3e08:	cd bf       	out	0x3d, r28	; 61
    3e0a:	df 91       	pop	r29
    3e0c:	cf 91       	pop	r28
    3e0e:	08 95       	ret

00003e10 <__udivmodsi4>:
    3e10:	a1 e2       	ldi	r26, 0x21	; 33
    3e12:	1a 2e       	mov	r1, r26
    3e14:	aa 1b       	sub	r26, r26
    3e16:	bb 1b       	sub	r27, r27
    3e18:	fd 01       	movw	r30, r26
    3e1a:	0d c0       	rjmp	.+26     	; 0x3e36 <__udivmodsi4_ep>

00003e1c <__udivmodsi4_loop>:
    3e1c:	aa 1f       	adc	r26, r26
    3e1e:	bb 1f       	adc	r27, r27
    3e20:	ee 1f       	adc	r30, r30
    3e22:	ff 1f       	adc	r31, r31
    3e24:	a2 17       	cp	r26, r18
    3e26:	b3 07       	cpc	r27, r19
    3e28:	e4 07       	cpc	r30, r20
    3e2a:	f5 07       	cpc	r31, r21
    3e2c:	20 f0       	brcs	.+8      	; 0x3e36 <__udivmodsi4_ep>
    3e2e:	a2 1b       	sub	r26, r18
    3e30:	b3 0b       	sbc	r27, r19
    3e32:	e4 0b       	sbc	r30, r20
    3e34:	f5 0b       	sbc	r31, r21

00003e36 <__udivmodsi4_ep>:
    3e36:	66 1f       	adc	r22, r22
    3e38:	77 1f       	adc	r23, r23
    3e3a:	88 1f       	adc	r24, r24
    3e3c:	99 1f       	adc	r25, r25
    3e3e:	1a 94       	dec	r1
    3e40:	69 f7       	brne	.-38     	; 0x3e1c <__udivmodsi4_loop>
    3e42:	60 95       	com	r22
    3e44:	70 95       	com	r23
    3e46:	80 95       	com	r24
    3e48:	90 95       	com	r25
    3e4a:	9b 01       	movw	r18, r22
    3e4c:	ac 01       	movw	r20, r24
    3e4e:	bd 01       	movw	r22, r26
    3e50:	cf 01       	movw	r24, r30
    3e52:	08 95       	ret

00003e54 <__tablejump2__>:
    3e54:	ee 0f       	add	r30, r30
    3e56:	ff 1f       	adc	r31, r31

00003e58 <__tablejump__>:
    3e58:	05 90       	lpm	r0, Z+
    3e5a:	f4 91       	lpm	r31, Z
    3e5c:	e0 2d       	mov	r30, r0
    3e5e:	09 94       	ijmp

00003e60 <__subsf3>:
    3e60:	50 58       	subi	r21, 0x80	; 128

00003e62 <__addsf3>:
    3e62:	bb 27       	eor	r27, r27
    3e64:	aa 27       	eor	r26, r26
    3e66:	0e d0       	rcall	.+28     	; 0x3e84 <__addsf3x>
    3e68:	70 c1       	rjmp	.+736    	; 0x414a <__fp_round>
    3e6a:	61 d1       	rcall	.+706    	; 0x412e <__fp_pscA>
    3e6c:	30 f0       	brcs	.+12     	; 0x3e7a <__addsf3+0x18>
    3e6e:	66 d1       	rcall	.+716    	; 0x413c <__fp_pscB>
    3e70:	20 f0       	brcs	.+8      	; 0x3e7a <__addsf3+0x18>
    3e72:	31 f4       	brne	.+12     	; 0x3e80 <__addsf3+0x1e>
    3e74:	9f 3f       	cpi	r25, 0xFF	; 255
    3e76:	11 f4       	brne	.+4      	; 0x3e7c <__addsf3+0x1a>
    3e78:	1e f4       	brtc	.+6      	; 0x3e80 <__addsf3+0x1e>
    3e7a:	56 c1       	rjmp	.+684    	; 0x4128 <__fp_nan>
    3e7c:	0e f4       	brtc	.+2      	; 0x3e80 <__addsf3+0x1e>
    3e7e:	e0 95       	com	r30
    3e80:	e7 fb       	bst	r30, 7
    3e82:	4c c1       	rjmp	.+664    	; 0x411c <__fp_inf>

00003e84 <__addsf3x>:
    3e84:	e9 2f       	mov	r30, r25
    3e86:	72 d1       	rcall	.+740    	; 0x416c <__fp_split3>
    3e88:	80 f3       	brcs	.-32     	; 0x3e6a <__addsf3+0x8>
    3e8a:	ba 17       	cp	r27, r26
    3e8c:	62 07       	cpc	r22, r18
    3e8e:	73 07       	cpc	r23, r19
    3e90:	84 07       	cpc	r24, r20
    3e92:	95 07       	cpc	r25, r21
    3e94:	18 f0       	brcs	.+6      	; 0x3e9c <__addsf3x+0x18>
    3e96:	71 f4       	brne	.+28     	; 0x3eb4 <__addsf3x+0x30>
    3e98:	9e f5       	brtc	.+102    	; 0x3f00 <__addsf3x+0x7c>
    3e9a:	8a c1       	rjmp	.+788    	; 0x41b0 <__fp_zero>
    3e9c:	0e f4       	brtc	.+2      	; 0x3ea0 <__addsf3x+0x1c>
    3e9e:	e0 95       	com	r30
    3ea0:	0b 2e       	mov	r0, r27
    3ea2:	ba 2f       	mov	r27, r26
    3ea4:	a0 2d       	mov	r26, r0
    3ea6:	0b 01       	movw	r0, r22
    3ea8:	b9 01       	movw	r22, r18
    3eaa:	90 01       	movw	r18, r0
    3eac:	0c 01       	movw	r0, r24
    3eae:	ca 01       	movw	r24, r20
    3eb0:	a0 01       	movw	r20, r0
    3eb2:	11 24       	eor	r1, r1
    3eb4:	ff 27       	eor	r31, r31
    3eb6:	59 1b       	sub	r21, r25
    3eb8:	99 f0       	breq	.+38     	; 0x3ee0 <__addsf3x+0x5c>
    3eba:	59 3f       	cpi	r21, 0xF9	; 249
    3ebc:	50 f4       	brcc	.+20     	; 0x3ed2 <__addsf3x+0x4e>
    3ebe:	50 3e       	cpi	r21, 0xE0	; 224
    3ec0:	68 f1       	brcs	.+90     	; 0x3f1c <__addsf3x+0x98>
    3ec2:	1a 16       	cp	r1, r26
    3ec4:	f0 40       	sbci	r31, 0x00	; 0
    3ec6:	a2 2f       	mov	r26, r18
    3ec8:	23 2f       	mov	r18, r19
    3eca:	34 2f       	mov	r19, r20
    3ecc:	44 27       	eor	r20, r20
    3ece:	58 5f       	subi	r21, 0xF8	; 248
    3ed0:	f3 cf       	rjmp	.-26     	; 0x3eb8 <__addsf3x+0x34>
    3ed2:	46 95       	lsr	r20
    3ed4:	37 95       	ror	r19
    3ed6:	27 95       	ror	r18
    3ed8:	a7 95       	ror	r26
    3eda:	f0 40       	sbci	r31, 0x00	; 0
    3edc:	53 95       	inc	r21
    3ede:	c9 f7       	brne	.-14     	; 0x3ed2 <__addsf3x+0x4e>
    3ee0:	7e f4       	brtc	.+30     	; 0x3f00 <__addsf3x+0x7c>
    3ee2:	1f 16       	cp	r1, r31
    3ee4:	ba 0b       	sbc	r27, r26
    3ee6:	62 0b       	sbc	r22, r18
    3ee8:	73 0b       	sbc	r23, r19
    3eea:	84 0b       	sbc	r24, r20
    3eec:	ba f0       	brmi	.+46     	; 0x3f1c <__addsf3x+0x98>
    3eee:	91 50       	subi	r25, 0x01	; 1
    3ef0:	a1 f0       	breq	.+40     	; 0x3f1a <__addsf3x+0x96>
    3ef2:	ff 0f       	add	r31, r31
    3ef4:	bb 1f       	adc	r27, r27
    3ef6:	66 1f       	adc	r22, r22
    3ef8:	77 1f       	adc	r23, r23
    3efa:	88 1f       	adc	r24, r24
    3efc:	c2 f7       	brpl	.-16     	; 0x3eee <__addsf3x+0x6a>
    3efe:	0e c0       	rjmp	.+28     	; 0x3f1c <__addsf3x+0x98>
    3f00:	ba 0f       	add	r27, r26
    3f02:	62 1f       	adc	r22, r18
    3f04:	73 1f       	adc	r23, r19
    3f06:	84 1f       	adc	r24, r20
    3f08:	48 f4       	brcc	.+18     	; 0x3f1c <__addsf3x+0x98>
    3f0a:	87 95       	ror	r24
    3f0c:	77 95       	ror	r23
    3f0e:	67 95       	ror	r22
    3f10:	b7 95       	ror	r27
    3f12:	f7 95       	ror	r31
    3f14:	9e 3f       	cpi	r25, 0xFE	; 254
    3f16:	08 f0       	brcs	.+2      	; 0x3f1a <__addsf3x+0x96>
    3f18:	b3 cf       	rjmp	.-154    	; 0x3e80 <__addsf3+0x1e>
    3f1a:	93 95       	inc	r25
    3f1c:	88 0f       	add	r24, r24
    3f1e:	08 f0       	brcs	.+2      	; 0x3f22 <__addsf3x+0x9e>
    3f20:	99 27       	eor	r25, r25
    3f22:	ee 0f       	add	r30, r30
    3f24:	97 95       	ror	r25
    3f26:	87 95       	ror	r24
    3f28:	08 95       	ret

00003f2a <__cmpsf2>:
    3f2a:	d4 d0       	rcall	.+424    	; 0x40d4 <__fp_cmp>
    3f2c:	08 f4       	brcc	.+2      	; 0x3f30 <__cmpsf2+0x6>
    3f2e:	81 e0       	ldi	r24, 0x01	; 1
    3f30:	08 95       	ret

00003f32 <__divsf3>:
    3f32:	0c d0       	rcall	.+24     	; 0x3f4c <__divsf3x>
    3f34:	0a c1       	rjmp	.+532    	; 0x414a <__fp_round>
    3f36:	02 d1       	rcall	.+516    	; 0x413c <__fp_pscB>
    3f38:	40 f0       	brcs	.+16     	; 0x3f4a <__divsf3+0x18>
    3f3a:	f9 d0       	rcall	.+498    	; 0x412e <__fp_pscA>
    3f3c:	30 f0       	brcs	.+12     	; 0x3f4a <__divsf3+0x18>
    3f3e:	21 f4       	brne	.+8      	; 0x3f48 <__divsf3+0x16>
    3f40:	5f 3f       	cpi	r21, 0xFF	; 255
    3f42:	19 f0       	breq	.+6      	; 0x3f4a <__divsf3+0x18>
    3f44:	eb c0       	rjmp	.+470    	; 0x411c <__fp_inf>
    3f46:	51 11       	cpse	r21, r1
    3f48:	34 c1       	rjmp	.+616    	; 0x41b2 <__fp_szero>
    3f4a:	ee c0       	rjmp	.+476    	; 0x4128 <__fp_nan>

00003f4c <__divsf3x>:
    3f4c:	0f d1       	rcall	.+542    	; 0x416c <__fp_split3>
    3f4e:	98 f3       	brcs	.-26     	; 0x3f36 <__divsf3+0x4>

00003f50 <__divsf3_pse>:
    3f50:	99 23       	and	r25, r25
    3f52:	c9 f3       	breq	.-14     	; 0x3f46 <__divsf3+0x14>
    3f54:	55 23       	and	r21, r21
    3f56:	b1 f3       	breq	.-20     	; 0x3f44 <__divsf3+0x12>
    3f58:	95 1b       	sub	r25, r21
    3f5a:	55 0b       	sbc	r21, r21
    3f5c:	bb 27       	eor	r27, r27
    3f5e:	aa 27       	eor	r26, r26
    3f60:	62 17       	cp	r22, r18
    3f62:	73 07       	cpc	r23, r19
    3f64:	84 07       	cpc	r24, r20
    3f66:	38 f0       	brcs	.+14     	; 0x3f76 <__divsf3_pse+0x26>
    3f68:	9f 5f       	subi	r25, 0xFF	; 255
    3f6a:	5f 4f       	sbci	r21, 0xFF	; 255
    3f6c:	22 0f       	add	r18, r18
    3f6e:	33 1f       	adc	r19, r19
    3f70:	44 1f       	adc	r20, r20
    3f72:	aa 1f       	adc	r26, r26
    3f74:	a9 f3       	breq	.-22     	; 0x3f60 <__divsf3_pse+0x10>
    3f76:	33 d0       	rcall	.+102    	; 0x3fde <__divsf3_pse+0x8e>
    3f78:	0e 2e       	mov	r0, r30
    3f7a:	3a f0       	brmi	.+14     	; 0x3f8a <__divsf3_pse+0x3a>
    3f7c:	e0 e8       	ldi	r30, 0x80	; 128
    3f7e:	30 d0       	rcall	.+96     	; 0x3fe0 <__divsf3_pse+0x90>
    3f80:	91 50       	subi	r25, 0x01	; 1
    3f82:	50 40       	sbci	r21, 0x00	; 0
    3f84:	e6 95       	lsr	r30
    3f86:	00 1c       	adc	r0, r0
    3f88:	ca f7       	brpl	.-14     	; 0x3f7c <__divsf3_pse+0x2c>
    3f8a:	29 d0       	rcall	.+82     	; 0x3fde <__divsf3_pse+0x8e>
    3f8c:	fe 2f       	mov	r31, r30
    3f8e:	27 d0       	rcall	.+78     	; 0x3fde <__divsf3_pse+0x8e>
    3f90:	66 0f       	add	r22, r22
    3f92:	77 1f       	adc	r23, r23
    3f94:	88 1f       	adc	r24, r24
    3f96:	bb 1f       	adc	r27, r27
    3f98:	26 17       	cp	r18, r22
    3f9a:	37 07       	cpc	r19, r23
    3f9c:	48 07       	cpc	r20, r24
    3f9e:	ab 07       	cpc	r26, r27
    3fa0:	b0 e8       	ldi	r27, 0x80	; 128
    3fa2:	09 f0       	breq	.+2      	; 0x3fa6 <__divsf3_pse+0x56>
    3fa4:	bb 0b       	sbc	r27, r27
    3fa6:	80 2d       	mov	r24, r0
    3fa8:	bf 01       	movw	r22, r30
    3faa:	ff 27       	eor	r31, r31
    3fac:	93 58       	subi	r25, 0x83	; 131
    3fae:	5f 4f       	sbci	r21, 0xFF	; 255
    3fb0:	2a f0       	brmi	.+10     	; 0x3fbc <__divsf3_pse+0x6c>
    3fb2:	9e 3f       	cpi	r25, 0xFE	; 254
    3fb4:	51 05       	cpc	r21, r1
    3fb6:	68 f0       	brcs	.+26     	; 0x3fd2 <__divsf3_pse+0x82>
    3fb8:	b1 c0       	rjmp	.+354    	; 0x411c <__fp_inf>
    3fba:	fb c0       	rjmp	.+502    	; 0x41b2 <__fp_szero>
    3fbc:	5f 3f       	cpi	r21, 0xFF	; 255
    3fbe:	ec f3       	brlt	.-6      	; 0x3fba <__divsf3_pse+0x6a>
    3fc0:	98 3e       	cpi	r25, 0xE8	; 232
    3fc2:	dc f3       	brlt	.-10     	; 0x3fba <__divsf3_pse+0x6a>
    3fc4:	86 95       	lsr	r24
    3fc6:	77 95       	ror	r23
    3fc8:	67 95       	ror	r22
    3fca:	b7 95       	ror	r27
    3fcc:	f7 95       	ror	r31
    3fce:	9f 5f       	subi	r25, 0xFF	; 255
    3fd0:	c9 f7       	brne	.-14     	; 0x3fc4 <__divsf3_pse+0x74>
    3fd2:	88 0f       	add	r24, r24
    3fd4:	91 1d       	adc	r25, r1
    3fd6:	96 95       	lsr	r25
    3fd8:	87 95       	ror	r24
    3fda:	97 f9       	bld	r25, 7
    3fdc:	08 95       	ret
    3fde:	e1 e0       	ldi	r30, 0x01	; 1
    3fe0:	66 0f       	add	r22, r22
    3fe2:	77 1f       	adc	r23, r23
    3fe4:	88 1f       	adc	r24, r24
    3fe6:	bb 1f       	adc	r27, r27
    3fe8:	62 17       	cp	r22, r18
    3fea:	73 07       	cpc	r23, r19
    3fec:	84 07       	cpc	r24, r20
    3fee:	ba 07       	cpc	r27, r26
    3ff0:	20 f0       	brcs	.+8      	; 0x3ffa <__divsf3_pse+0xaa>
    3ff2:	62 1b       	sub	r22, r18
    3ff4:	73 0b       	sbc	r23, r19
    3ff6:	84 0b       	sbc	r24, r20
    3ff8:	ba 0b       	sbc	r27, r26
    3ffa:	ee 1f       	adc	r30, r30
    3ffc:	88 f7       	brcc	.-30     	; 0x3fe0 <__divsf3_pse+0x90>
    3ffe:	e0 95       	com	r30
    4000:	08 95       	ret

00004002 <__fixunssfsi>:
    4002:	bc d0       	rcall	.+376    	; 0x417c <__fp_splitA>
    4004:	88 f0       	brcs	.+34     	; 0x4028 <__fixunssfsi+0x26>
    4006:	9f 57       	subi	r25, 0x7F	; 127
    4008:	90 f0       	brcs	.+36     	; 0x402e <__fixunssfsi+0x2c>
    400a:	b9 2f       	mov	r27, r25
    400c:	99 27       	eor	r25, r25
    400e:	b7 51       	subi	r27, 0x17	; 23
    4010:	a0 f0       	brcs	.+40     	; 0x403a <__fixunssfsi+0x38>
    4012:	d1 f0       	breq	.+52     	; 0x4048 <__fixunssfsi+0x46>
    4014:	66 0f       	add	r22, r22
    4016:	77 1f       	adc	r23, r23
    4018:	88 1f       	adc	r24, r24
    401a:	99 1f       	adc	r25, r25
    401c:	1a f0       	brmi	.+6      	; 0x4024 <__fixunssfsi+0x22>
    401e:	ba 95       	dec	r27
    4020:	c9 f7       	brne	.-14     	; 0x4014 <__fixunssfsi+0x12>
    4022:	12 c0       	rjmp	.+36     	; 0x4048 <__fixunssfsi+0x46>
    4024:	b1 30       	cpi	r27, 0x01	; 1
    4026:	81 f0       	breq	.+32     	; 0x4048 <__fixunssfsi+0x46>
    4028:	c3 d0       	rcall	.+390    	; 0x41b0 <__fp_zero>
    402a:	b1 e0       	ldi	r27, 0x01	; 1
    402c:	08 95       	ret
    402e:	c0 c0       	rjmp	.+384    	; 0x41b0 <__fp_zero>
    4030:	67 2f       	mov	r22, r23
    4032:	78 2f       	mov	r23, r24
    4034:	88 27       	eor	r24, r24
    4036:	b8 5f       	subi	r27, 0xF8	; 248
    4038:	39 f0       	breq	.+14     	; 0x4048 <__fixunssfsi+0x46>
    403a:	b9 3f       	cpi	r27, 0xF9	; 249
    403c:	cc f3       	brlt	.-14     	; 0x4030 <__fixunssfsi+0x2e>
    403e:	86 95       	lsr	r24
    4040:	77 95       	ror	r23
    4042:	67 95       	ror	r22
    4044:	b3 95       	inc	r27
    4046:	d9 f7       	brne	.-10     	; 0x403e <__fixunssfsi+0x3c>
    4048:	3e f4       	brtc	.+14     	; 0x4058 <__fixunssfsi+0x56>
    404a:	90 95       	com	r25
    404c:	80 95       	com	r24
    404e:	70 95       	com	r23
    4050:	61 95       	neg	r22
    4052:	7f 4f       	sbci	r23, 0xFF	; 255
    4054:	8f 4f       	sbci	r24, 0xFF	; 255
    4056:	9f 4f       	sbci	r25, 0xFF	; 255
    4058:	08 95       	ret

0000405a <__floatunsisf>:
    405a:	e8 94       	clt
    405c:	09 c0       	rjmp	.+18     	; 0x4070 <__floatsisf+0x12>

0000405e <__floatsisf>:
    405e:	97 fb       	bst	r25, 7
    4060:	3e f4       	brtc	.+14     	; 0x4070 <__floatsisf+0x12>
    4062:	90 95       	com	r25
    4064:	80 95       	com	r24
    4066:	70 95       	com	r23
    4068:	61 95       	neg	r22
    406a:	7f 4f       	sbci	r23, 0xFF	; 255
    406c:	8f 4f       	sbci	r24, 0xFF	; 255
    406e:	9f 4f       	sbci	r25, 0xFF	; 255
    4070:	99 23       	and	r25, r25
    4072:	a9 f0       	breq	.+42     	; 0x409e <__floatsisf+0x40>
    4074:	f9 2f       	mov	r31, r25
    4076:	96 e9       	ldi	r25, 0x96	; 150
    4078:	bb 27       	eor	r27, r27
    407a:	93 95       	inc	r25
    407c:	f6 95       	lsr	r31
    407e:	87 95       	ror	r24
    4080:	77 95       	ror	r23
    4082:	67 95       	ror	r22
    4084:	b7 95       	ror	r27
    4086:	f1 11       	cpse	r31, r1
    4088:	f8 cf       	rjmp	.-16     	; 0x407a <__floatsisf+0x1c>
    408a:	fa f4       	brpl	.+62     	; 0x40ca <__floatsisf+0x6c>
    408c:	bb 0f       	add	r27, r27
    408e:	11 f4       	brne	.+4      	; 0x4094 <__floatsisf+0x36>
    4090:	60 ff       	sbrs	r22, 0
    4092:	1b c0       	rjmp	.+54     	; 0x40ca <__floatsisf+0x6c>
    4094:	6f 5f       	subi	r22, 0xFF	; 255
    4096:	7f 4f       	sbci	r23, 0xFF	; 255
    4098:	8f 4f       	sbci	r24, 0xFF	; 255
    409a:	9f 4f       	sbci	r25, 0xFF	; 255
    409c:	16 c0       	rjmp	.+44     	; 0x40ca <__floatsisf+0x6c>
    409e:	88 23       	and	r24, r24
    40a0:	11 f0       	breq	.+4      	; 0x40a6 <__floatsisf+0x48>
    40a2:	96 e9       	ldi	r25, 0x96	; 150
    40a4:	11 c0       	rjmp	.+34     	; 0x40c8 <__floatsisf+0x6a>
    40a6:	77 23       	and	r23, r23
    40a8:	21 f0       	breq	.+8      	; 0x40b2 <__floatsisf+0x54>
    40aa:	9e e8       	ldi	r25, 0x8E	; 142
    40ac:	87 2f       	mov	r24, r23
    40ae:	76 2f       	mov	r23, r22
    40b0:	05 c0       	rjmp	.+10     	; 0x40bc <__floatsisf+0x5e>
    40b2:	66 23       	and	r22, r22
    40b4:	71 f0       	breq	.+28     	; 0x40d2 <__floatsisf+0x74>
    40b6:	96 e8       	ldi	r25, 0x86	; 134
    40b8:	86 2f       	mov	r24, r22
    40ba:	70 e0       	ldi	r23, 0x00	; 0
    40bc:	60 e0       	ldi	r22, 0x00	; 0
    40be:	2a f0       	brmi	.+10     	; 0x40ca <__floatsisf+0x6c>
    40c0:	9a 95       	dec	r25
    40c2:	66 0f       	add	r22, r22
    40c4:	77 1f       	adc	r23, r23
    40c6:	88 1f       	adc	r24, r24
    40c8:	da f7       	brpl	.-10     	; 0x40c0 <__floatsisf+0x62>
    40ca:	88 0f       	add	r24, r24
    40cc:	96 95       	lsr	r25
    40ce:	87 95       	ror	r24
    40d0:	97 f9       	bld	r25, 7
    40d2:	08 95       	ret

000040d4 <__fp_cmp>:
    40d4:	99 0f       	add	r25, r25
    40d6:	00 08       	sbc	r0, r0
    40d8:	55 0f       	add	r21, r21
    40da:	aa 0b       	sbc	r26, r26
    40dc:	e0 e8       	ldi	r30, 0x80	; 128
    40de:	fe ef       	ldi	r31, 0xFE	; 254
    40e0:	16 16       	cp	r1, r22
    40e2:	17 06       	cpc	r1, r23
    40e4:	e8 07       	cpc	r30, r24
    40e6:	f9 07       	cpc	r31, r25
    40e8:	c0 f0       	brcs	.+48     	; 0x411a <__fp_cmp+0x46>
    40ea:	12 16       	cp	r1, r18
    40ec:	13 06       	cpc	r1, r19
    40ee:	e4 07       	cpc	r30, r20
    40f0:	f5 07       	cpc	r31, r21
    40f2:	98 f0       	brcs	.+38     	; 0x411a <__fp_cmp+0x46>
    40f4:	62 1b       	sub	r22, r18
    40f6:	73 0b       	sbc	r23, r19
    40f8:	84 0b       	sbc	r24, r20
    40fa:	95 0b       	sbc	r25, r21
    40fc:	39 f4       	brne	.+14     	; 0x410c <__fp_cmp+0x38>
    40fe:	0a 26       	eor	r0, r26
    4100:	61 f0       	breq	.+24     	; 0x411a <__fp_cmp+0x46>
    4102:	23 2b       	or	r18, r19
    4104:	24 2b       	or	r18, r20
    4106:	25 2b       	or	r18, r21
    4108:	21 f4       	brne	.+8      	; 0x4112 <__fp_cmp+0x3e>
    410a:	08 95       	ret
    410c:	0a 26       	eor	r0, r26
    410e:	09 f4       	brne	.+2      	; 0x4112 <__fp_cmp+0x3e>
    4110:	a1 40       	sbci	r26, 0x01	; 1
    4112:	a6 95       	lsr	r26
    4114:	8f ef       	ldi	r24, 0xFF	; 255
    4116:	81 1d       	adc	r24, r1
    4118:	81 1d       	adc	r24, r1
    411a:	08 95       	ret

0000411c <__fp_inf>:
    411c:	97 f9       	bld	r25, 7
    411e:	9f 67       	ori	r25, 0x7F	; 127
    4120:	80 e8       	ldi	r24, 0x80	; 128
    4122:	70 e0       	ldi	r23, 0x00	; 0
    4124:	60 e0       	ldi	r22, 0x00	; 0
    4126:	08 95       	ret

00004128 <__fp_nan>:
    4128:	9f ef       	ldi	r25, 0xFF	; 255
    412a:	80 ec       	ldi	r24, 0xC0	; 192
    412c:	08 95       	ret

0000412e <__fp_pscA>:
    412e:	00 24       	eor	r0, r0
    4130:	0a 94       	dec	r0
    4132:	16 16       	cp	r1, r22
    4134:	17 06       	cpc	r1, r23
    4136:	18 06       	cpc	r1, r24
    4138:	09 06       	cpc	r0, r25
    413a:	08 95       	ret

0000413c <__fp_pscB>:
    413c:	00 24       	eor	r0, r0
    413e:	0a 94       	dec	r0
    4140:	12 16       	cp	r1, r18
    4142:	13 06       	cpc	r1, r19
    4144:	14 06       	cpc	r1, r20
    4146:	05 06       	cpc	r0, r21
    4148:	08 95       	ret

0000414a <__fp_round>:
    414a:	09 2e       	mov	r0, r25
    414c:	03 94       	inc	r0
    414e:	00 0c       	add	r0, r0
    4150:	11 f4       	brne	.+4      	; 0x4156 <__fp_round+0xc>
    4152:	88 23       	and	r24, r24
    4154:	52 f0       	brmi	.+20     	; 0x416a <__fp_round+0x20>
    4156:	bb 0f       	add	r27, r27
    4158:	40 f4       	brcc	.+16     	; 0x416a <__fp_round+0x20>
    415a:	bf 2b       	or	r27, r31
    415c:	11 f4       	brne	.+4      	; 0x4162 <__fp_round+0x18>
    415e:	60 ff       	sbrs	r22, 0
    4160:	04 c0       	rjmp	.+8      	; 0x416a <__fp_round+0x20>
    4162:	6f 5f       	subi	r22, 0xFF	; 255
    4164:	7f 4f       	sbci	r23, 0xFF	; 255
    4166:	8f 4f       	sbci	r24, 0xFF	; 255
    4168:	9f 4f       	sbci	r25, 0xFF	; 255
    416a:	08 95       	ret

0000416c <__fp_split3>:
    416c:	57 fd       	sbrc	r21, 7
    416e:	90 58       	subi	r25, 0x80	; 128
    4170:	44 0f       	add	r20, r20
    4172:	55 1f       	adc	r21, r21
    4174:	59 f0       	breq	.+22     	; 0x418c <__fp_splitA+0x10>
    4176:	5f 3f       	cpi	r21, 0xFF	; 255
    4178:	71 f0       	breq	.+28     	; 0x4196 <__fp_splitA+0x1a>
    417a:	47 95       	ror	r20

0000417c <__fp_splitA>:
    417c:	88 0f       	add	r24, r24
    417e:	97 fb       	bst	r25, 7
    4180:	99 1f       	adc	r25, r25
    4182:	61 f0       	breq	.+24     	; 0x419c <__fp_splitA+0x20>
    4184:	9f 3f       	cpi	r25, 0xFF	; 255
    4186:	79 f0       	breq	.+30     	; 0x41a6 <__fp_splitA+0x2a>
    4188:	87 95       	ror	r24
    418a:	08 95       	ret
    418c:	12 16       	cp	r1, r18
    418e:	13 06       	cpc	r1, r19
    4190:	14 06       	cpc	r1, r20
    4192:	55 1f       	adc	r21, r21
    4194:	f2 cf       	rjmp	.-28     	; 0x417a <__fp_split3+0xe>
    4196:	46 95       	lsr	r20
    4198:	f1 df       	rcall	.-30     	; 0x417c <__fp_splitA>
    419a:	08 c0       	rjmp	.+16     	; 0x41ac <__fp_splitA+0x30>
    419c:	16 16       	cp	r1, r22
    419e:	17 06       	cpc	r1, r23
    41a0:	18 06       	cpc	r1, r24
    41a2:	99 1f       	adc	r25, r25
    41a4:	f1 cf       	rjmp	.-30     	; 0x4188 <__fp_splitA+0xc>
    41a6:	86 95       	lsr	r24
    41a8:	71 05       	cpc	r23, r1
    41aa:	61 05       	cpc	r22, r1
    41ac:	08 94       	sec
    41ae:	08 95       	ret

000041b0 <__fp_zero>:
    41b0:	e8 94       	clt

000041b2 <__fp_szero>:
    41b2:	bb 27       	eor	r27, r27
    41b4:	66 27       	eor	r22, r22
    41b6:	77 27       	eor	r23, r23
    41b8:	cb 01       	movw	r24, r22
    41ba:	97 f9       	bld	r25, 7
    41bc:	08 95       	ret

000041be <__gesf2>:
    41be:	8a df       	rcall	.-236    	; 0x40d4 <__fp_cmp>
    41c0:	08 f4       	brcc	.+2      	; 0x41c4 <__gesf2+0x6>
    41c2:	8f ef       	ldi	r24, 0xFF	; 255
    41c4:	08 95       	ret

000041c6 <__mulsf3>:
    41c6:	0b d0       	rcall	.+22     	; 0x41de <__mulsf3x>
    41c8:	c0 cf       	rjmp	.-128    	; 0x414a <__fp_round>
    41ca:	b1 df       	rcall	.-158    	; 0x412e <__fp_pscA>
    41cc:	28 f0       	brcs	.+10     	; 0x41d8 <__mulsf3+0x12>
    41ce:	b6 df       	rcall	.-148    	; 0x413c <__fp_pscB>
    41d0:	18 f0       	brcs	.+6      	; 0x41d8 <__mulsf3+0x12>
    41d2:	95 23       	and	r25, r21
    41d4:	09 f0       	breq	.+2      	; 0x41d8 <__mulsf3+0x12>
    41d6:	a2 cf       	rjmp	.-188    	; 0x411c <__fp_inf>
    41d8:	a7 cf       	rjmp	.-178    	; 0x4128 <__fp_nan>
    41da:	11 24       	eor	r1, r1
    41dc:	ea cf       	rjmp	.-44     	; 0x41b2 <__fp_szero>

000041de <__mulsf3x>:
    41de:	c6 df       	rcall	.-116    	; 0x416c <__fp_split3>
    41e0:	a0 f3       	brcs	.-24     	; 0x41ca <__mulsf3+0x4>

000041e2 <__mulsf3_pse>:
    41e2:	95 9f       	mul	r25, r21
    41e4:	d1 f3       	breq	.-12     	; 0x41da <__mulsf3+0x14>
    41e6:	95 0f       	add	r25, r21
    41e8:	50 e0       	ldi	r21, 0x00	; 0
    41ea:	55 1f       	adc	r21, r21
    41ec:	62 9f       	mul	r22, r18
    41ee:	f0 01       	movw	r30, r0
    41f0:	72 9f       	mul	r23, r18
    41f2:	bb 27       	eor	r27, r27
    41f4:	f0 0d       	add	r31, r0
    41f6:	b1 1d       	adc	r27, r1
    41f8:	63 9f       	mul	r22, r19
    41fa:	aa 27       	eor	r26, r26
    41fc:	f0 0d       	add	r31, r0
    41fe:	b1 1d       	adc	r27, r1
    4200:	aa 1f       	adc	r26, r26
    4202:	64 9f       	mul	r22, r20
    4204:	66 27       	eor	r22, r22
    4206:	b0 0d       	add	r27, r0
    4208:	a1 1d       	adc	r26, r1
    420a:	66 1f       	adc	r22, r22
    420c:	82 9f       	mul	r24, r18
    420e:	22 27       	eor	r18, r18
    4210:	b0 0d       	add	r27, r0
    4212:	a1 1d       	adc	r26, r1
    4214:	62 1f       	adc	r22, r18
    4216:	73 9f       	mul	r23, r19
    4218:	b0 0d       	add	r27, r0
    421a:	a1 1d       	adc	r26, r1
    421c:	62 1f       	adc	r22, r18
    421e:	83 9f       	mul	r24, r19
    4220:	a0 0d       	add	r26, r0
    4222:	61 1d       	adc	r22, r1
    4224:	22 1f       	adc	r18, r18
    4226:	74 9f       	mul	r23, r20
    4228:	33 27       	eor	r19, r19
    422a:	a0 0d       	add	r26, r0
    422c:	61 1d       	adc	r22, r1
    422e:	23 1f       	adc	r18, r19
    4230:	84 9f       	mul	r24, r20
    4232:	60 0d       	add	r22, r0
    4234:	21 1d       	adc	r18, r1
    4236:	82 2f       	mov	r24, r18
    4238:	76 2f       	mov	r23, r22
    423a:	6a 2f       	mov	r22, r26
    423c:	11 24       	eor	r1, r1
    423e:	9f 57       	subi	r25, 0x7F	; 127
    4240:	50 40       	sbci	r21, 0x00	; 0
    4242:	8a f0       	brmi	.+34     	; 0x4266 <__mulsf3_pse+0x84>
    4244:	e1 f0       	breq	.+56     	; 0x427e <__mulsf3_pse+0x9c>
    4246:	88 23       	and	r24, r24
    4248:	4a f0       	brmi	.+18     	; 0x425c <__mulsf3_pse+0x7a>
    424a:	ee 0f       	add	r30, r30
    424c:	ff 1f       	adc	r31, r31
    424e:	bb 1f       	adc	r27, r27
    4250:	66 1f       	adc	r22, r22
    4252:	77 1f       	adc	r23, r23
    4254:	88 1f       	adc	r24, r24
    4256:	91 50       	subi	r25, 0x01	; 1
    4258:	50 40       	sbci	r21, 0x00	; 0
    425a:	a9 f7       	brne	.-22     	; 0x4246 <__mulsf3_pse+0x64>
    425c:	9e 3f       	cpi	r25, 0xFE	; 254
    425e:	51 05       	cpc	r21, r1
    4260:	70 f0       	brcs	.+28     	; 0x427e <__mulsf3_pse+0x9c>
    4262:	5c cf       	rjmp	.-328    	; 0x411c <__fp_inf>
    4264:	a6 cf       	rjmp	.-180    	; 0x41b2 <__fp_szero>
    4266:	5f 3f       	cpi	r21, 0xFF	; 255
    4268:	ec f3       	brlt	.-6      	; 0x4264 <__mulsf3_pse+0x82>
    426a:	98 3e       	cpi	r25, 0xE8	; 232
    426c:	dc f3       	brlt	.-10     	; 0x4264 <__mulsf3_pse+0x82>
    426e:	86 95       	lsr	r24
    4270:	77 95       	ror	r23
    4272:	67 95       	ror	r22
    4274:	b7 95       	ror	r27
    4276:	f7 95       	ror	r31
    4278:	e7 95       	ror	r30
    427a:	9f 5f       	subi	r25, 0xFF	; 255
    427c:	c1 f7       	brne	.-16     	; 0x426e <__mulsf3_pse+0x8c>
    427e:	fe 2b       	or	r31, r30
    4280:	88 0f       	add	r24, r24
    4282:	91 1d       	adc	r25, r1
    4284:	96 95       	lsr	r25
    4286:	87 95       	ror	r24
    4288:	97 f9       	bld	r25, 7
    428a:	08 95       	ret

0000428c <_exit>:
    428c:	f8 94       	cli

0000428e <__stop_program>:
    428e:	ff cf       	rjmp	.-2      	; 0x428e <__stop_program>
